//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include "Absyn.H"

/********************   Main    ********************/
Main::Main(ListTLDeclaration *p1, ListDeclaration *p2) { listtldeclaration_ = p1; listdeclaration_ = p2; }
Main::Main(const Main & other) {   listtldeclaration_ = other.listtldeclaration_->clone();
  listdeclaration_ = other.listdeclaration_->clone();

}
Main &Main::operator=(const Main & other) {
  Main tmp(other);
  swap(tmp);
  return *this;
}
void Main::swap(Main & other) {
  std::swap(listtldeclaration_, other.listtldeclaration_);
  std::swap(listdeclaration_, other.listdeclaration_);

}

Main::~Main() { delete(listtldeclaration_); delete(listdeclaration_); }

void Main::accept(Visitor *v) { v->visitMain(this); }
Main *Main::clone() const {
  return new Main(*this);
}

/********************   DImport    ********************/
DImport::DImport(Ident p1) { ident_ = p1; }
DImport::DImport(const DImport & other) {   ident_ = other.ident_;

}
DImport &DImport::operator=(const DImport & other) {
  DImport tmp(other);
  swap(tmp);
  return *this;
}
void DImport::swap(DImport & other) {
  std::swap(ident_, other.ident_);

}

DImport::~DImport() { }

void DImport::accept(Visitor *v) { v->visitDImport(this); }
DImport *DImport::clone() const {
  return new DImport(*this);
}

/********************   DExpose    ********************/
DExpose::DExpose(Ident p1) { ident_ = p1; }
DExpose::DExpose(const DExpose & other) {   ident_ = other.ident_;

}
DExpose &DExpose::operator=(const DExpose & other) {
  DExpose tmp(other);
  swap(tmp);
  return *this;
}
void DExpose::swap(DExpose & other) {
  std::swap(ident_, other.ident_);

}

DExpose::~DExpose() { }

void DExpose::accept(Visitor *v) { v->visitDExpose(this); }
DExpose *DExpose::clone() const {
  return new DExpose(*this);
}

/********************   DNamespace    ********************/
DNamespace::DNamespace(Ident p1, ListDeclaration *p2) { ident_ = p1; listdeclaration_ = p2; }
DNamespace::DNamespace(const DNamespace & other) {   ident_ = other.ident_;
  listdeclaration_ = other.listdeclaration_->clone();

}
DNamespace &DNamespace::operator=(const DNamespace & other) {
  DNamespace tmp(other);
  swap(tmp);
  return *this;
}
void DNamespace::swap(DNamespace & other) {
  std::swap(ident_, other.ident_);
  std::swap(listdeclaration_, other.listdeclaration_);

}

DNamespace::~DNamespace() { delete(listdeclaration_); }

void DNamespace::accept(Visitor *v) { v->visitDNamespace(this); }
DNamespace *DNamespace::clone() const {
  return new DNamespace(*this);
}

/********************   DDefaultFunction    ********************/
DDefaultFunction::DDefaultFunction(ListFunctionSpecifier *p1, Ident p2, ListParameterDeclaration *p3, ListStatement *p4) { listfunctionspecifier_ = p1; ident_ = p2; listparameterdeclaration_ = p3; liststatement_ = p4; }
DDefaultFunction::DDefaultFunction(const DDefaultFunction & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  ident_ = other.ident_;
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();
  liststatement_ = other.liststatement_->clone();

}
DDefaultFunction &DDefaultFunction::operator=(const DDefaultFunction & other) {
  DDefaultFunction tmp(other);
  swap(tmp);
  return *this;
}
void DDefaultFunction::swap(DDefaultFunction & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(ident_, other.ident_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);
  std::swap(liststatement_, other.liststatement_);

}

DDefaultFunction::~DDefaultFunction() { delete(listfunctionspecifier_); delete(listparameterdeclaration_); delete(liststatement_); }

void DDefaultFunction::accept(Visitor *v) { v->visitDDefaultFunction(this); }
DDefaultFunction *DDefaultFunction::clone() const {
  return new DDefaultFunction(*this);
}

/********************   DFunction    ********************/
DFunction::DFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4, ListStatement *p5) { listfunctionspecifier_ = p1; type_ = p2; ident_ = p3; listparameterdeclaration_ = p4; liststatement_ = p5; }
DFunction::DFunction(const DFunction & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();
  liststatement_ = other.liststatement_->clone();

}
DFunction &DFunction::operator=(const DFunction & other) {
  DFunction tmp(other);
  swap(tmp);
  return *this;
}
void DFunction::swap(DFunction & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);
  std::swap(liststatement_, other.liststatement_);

}

DFunction::~DFunction() { delete(listfunctionspecifier_); delete(type_); delete(listparameterdeclaration_); delete(liststatement_); }

void DFunction::accept(Visitor *v) { v->visitDFunction(this); }
DFunction *DFunction::clone() const {
  return new DFunction(*this);
}

/********************   DOperator    ********************/
DOperator::DOperator(ListFunctionSpecifier *p1, Type *p2, OperatorName *p3, ListParameterDeclaration *p4, ListStatement *p5) { listfunctionspecifier_ = p1; type_ = p2; operatorname_ = p3; listparameterdeclaration_ = p4; liststatement_ = p5; }
DOperator::DOperator(const DOperator & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  type_ = other.type_->clone();
  operatorname_ = other.operatorname_->clone();
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();
  liststatement_ = other.liststatement_->clone();

}
DOperator &DOperator::operator=(const DOperator & other) {
  DOperator tmp(other);
  swap(tmp);
  return *this;
}
void DOperator::swap(DOperator & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(type_, other.type_);
  std::swap(operatorname_, other.operatorname_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);
  std::swap(liststatement_, other.liststatement_);

}

DOperator::~DOperator() { delete(listfunctionspecifier_); delete(type_); delete(operatorname_); delete(listparameterdeclaration_); delete(liststatement_); }

void DOperator::accept(Visitor *v) { v->visitDOperator(this); }
DOperator *DOperator::clone() const {
  return new DOperator(*this);
}

/********************   DOperatorInfo    ********************/
DOperatorInfo::DOperatorInfo(OperatorTrait *p1) { operatortrait_ = p1; }
DOperatorInfo::DOperatorInfo(const DOperatorInfo & other) {   operatortrait_ = other.operatortrait_->clone();

}
DOperatorInfo &DOperatorInfo::operator=(const DOperatorInfo & other) {
  DOperatorInfo tmp(other);
  swap(tmp);
  return *this;
}
void DOperatorInfo::swap(DOperatorInfo & other) {
  std::swap(operatortrait_, other.operatortrait_);

}

DOperatorInfo::~DOperatorInfo() { delete(operatortrait_); }

void DOperatorInfo::accept(Visitor *v) { v->visitDOperatorInfo(this); }
DOperatorInfo *DOperatorInfo::clone() const {
  return new DOperatorInfo(*this);
}

/********************   DTypeDecl    ********************/
DTypeDecl::DTypeDecl(ListTypeSpecifier *p1, Type *p2, Ident p3) { listtypespecifier_ = p1; type_ = p2; ident_ = p3; }
DTypeDecl::DTypeDecl(const DTypeDecl & other) {   listtypespecifier_ = other.listtypespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
DTypeDecl &DTypeDecl::operator=(const DTypeDecl & other) {
  DTypeDecl tmp(other);
  swap(tmp);
  return *this;
}
void DTypeDecl::swap(DTypeDecl & other) {
  std::swap(listtypespecifier_, other.listtypespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

DTypeDecl::~DTypeDecl() { delete(listtypespecifier_); delete(type_); }

void DTypeDecl::accept(Visitor *v) { v->visitDTypeDecl(this); }
DTypeDecl *DTypeDecl::clone() const {
  return new DTypeDecl(*this);
}

/********************   DExtern    ********************/
DExtern::DExtern(Prototype *p1) { prototype_ = p1; }
DExtern::DExtern(const DExtern & other) {   prototype_ = other.prototype_->clone();

}
DExtern &DExtern::operator=(const DExtern & other) {
  DExtern tmp(other);
  swap(tmp);
  return *this;
}
void DExtern::swap(DExtern & other) {
  std::swap(prototype_, other.prototype_);

}

DExtern::~DExtern() { delete(prototype_); }

void DExtern::accept(Visitor *v) { v->visitDExtern(this); }
DExtern *DExtern::clone() const {
  return new DExtern(*this);
}

/********************   DIVariable    ********************/
DIVariable::DIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; expression_ = p4; }
DIVariable::DIVariable(const DIVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
DIVariable &DIVariable::operator=(const DIVariable & other) {
  DIVariable tmp(other);
  swap(tmp);
  return *this;
}
void DIVariable::swap(DIVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

DIVariable::~DIVariable() { delete(listvariablespecifier_); delete(type_); delete(expression_); }

void DIVariable::accept(Visitor *v) { v->visitDIVariable(this); }
DIVariable *DIVariable::clone() const {
  return new DIVariable(*this);
}

/********************   DVariable    ********************/
DVariable::DVariable(ListVariableSpecifier *p1, Type *p2, Ident p3) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; }
DVariable::DVariable(const DVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
DVariable &DVariable::operator=(const DVariable & other) {
  DVariable tmp(other);
  swap(tmp);
  return *this;
}
void DVariable::swap(DVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

DVariable::~DVariable() { delete(listvariablespecifier_); delete(type_); }

void DVariable::accept(Visitor *v) { v->visitDVariable(this); }
DVariable *DVariable::clone() const {
  return new DVariable(*this);
}

/********************   PFunction    ********************/
PFunction::PFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4) { listfunctionspecifier_ = p1; type_ = p2; ident_ = p3; listparameterdeclaration_ = p4; }
PFunction::PFunction(const PFunction & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();

}
PFunction &PFunction::operator=(const PFunction & other) {
  PFunction tmp(other);
  swap(tmp);
  return *this;
}
void PFunction::swap(PFunction & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);

}

PFunction::~PFunction() { delete(listfunctionspecifier_); delete(type_); delete(listparameterdeclaration_); }

void PFunction::accept(Visitor *v) { v->visitPFunction(this); }
PFunction *PFunction::clone() const {
  return new PFunction(*this);
}

/********************   ONOp    ********************/
ONOp::ONOp(Operator p1) { operator_ = p1; }
ONOp::ONOp(const ONOp & other) {   operator_ = other.operator_;

}
ONOp &ONOp::operator=(const ONOp & other) {
  ONOp tmp(other);
  swap(tmp);
  return *this;
}
void ONOp::swap(ONOp & other) {
  std::swap(operator_, other.operator_);

}

ONOp::~ONOp() { }

void ONOp::accept(Visitor *v) { v->visitONOp(this); }
ONOp *ONOp::clone() const {
  return new ONOp(*this);
}

/********************   ONLnot    ********************/
ONLnot::ONLnot() { }
ONLnot::ONLnot(const ONLnot & other) { 
}
ONLnot &ONLnot::operator=(const ONLnot & other) {
  ONLnot tmp(other);
  swap(tmp);
  return *this;
}
void ONLnot::swap(ONLnot & other) {

}

ONLnot::~ONLnot() { }

void ONLnot::accept(Visitor *v) { v->visitONLnot(this); }
ONLnot *ONLnot::clone() const {
  return new ONLnot(*this);
}

/********************   ONPreInc    ********************/
ONPreInc::ONPreInc() { }
ONPreInc::ONPreInc(const ONPreInc & other) { 
}
ONPreInc &ONPreInc::operator=(const ONPreInc & other) {
  ONPreInc tmp(other);
  swap(tmp);
  return *this;
}
void ONPreInc::swap(ONPreInc & other) {

}

ONPreInc::~ONPreInc() { }

void ONPreInc::accept(Visitor *v) { v->visitONPreInc(this); }
ONPreInc *ONPreInc::clone() const {
  return new ONPreInc(*this);
}

/********************   ONPreDec    ********************/
ONPreDec::ONPreDec() { }
ONPreDec::ONPreDec(const ONPreDec & other) { 
}
ONPreDec &ONPreDec::operator=(const ONPreDec & other) {
  ONPreDec tmp(other);
  swap(tmp);
  return *this;
}
void ONPreDec::swap(ONPreDec & other) {

}

ONPreDec::~ONPreDec() { }

void ONPreDec::accept(Visitor *v) { v->visitONPreDec(this); }
ONPreDec *ONPreDec::clone() const {
  return new ONPreDec(*this);
}

/********************   ONBnot    ********************/
ONBnot::ONBnot() { }
ONBnot::ONBnot(const ONBnot & other) { 
}
ONBnot &ONBnot::operator=(const ONBnot & other) {
  ONBnot tmp(other);
  swap(tmp);
  return *this;
}
void ONBnot::swap(ONBnot & other) {

}

ONBnot::~ONBnot() { }

void ONBnot::accept(Visitor *v) { v->visitONBnot(this); }
ONBnot *ONBnot::clone() const {
  return new ONBnot(*this);
}

/********************   ONMul    ********************/
ONMul::ONMul() { }
ONMul::ONMul(const ONMul & other) { 
}
ONMul &ONMul::operator=(const ONMul & other) {
  ONMul tmp(other);
  swap(tmp);
  return *this;
}
void ONMul::swap(ONMul & other) {

}

ONMul::~ONMul() { }

void ONMul::accept(Visitor *v) { v->visitONMul(this); }
ONMul *ONMul::clone() const {
  return new ONMul(*this);
}

/********************   ONDiv    ********************/
ONDiv::ONDiv() { }
ONDiv::ONDiv(const ONDiv & other) { 
}
ONDiv &ONDiv::operator=(const ONDiv & other) {
  ONDiv tmp(other);
  swap(tmp);
  return *this;
}
void ONDiv::swap(ONDiv & other) {

}

ONDiv::~ONDiv() { }

void ONDiv::accept(Visitor *v) { v->visitONDiv(this); }
ONDiv *ONDiv::clone() const {
  return new ONDiv(*this);
}

/********************   ONMod    ********************/
ONMod::ONMod() { }
ONMod::ONMod(const ONMod & other) { 
}
ONMod &ONMod::operator=(const ONMod & other) {
  ONMod tmp(other);
  swap(tmp);
  return *this;
}
void ONMod::swap(ONMod & other) {

}

ONMod::~ONMod() { }

void ONMod::accept(Visitor *v) { v->visitONMod(this); }
ONMod *ONMod::clone() const {
  return new ONMod(*this);
}

/********************   ONAdd    ********************/
ONAdd::ONAdd() { }
ONAdd::ONAdd(const ONAdd & other) { 
}
ONAdd &ONAdd::operator=(const ONAdd & other) {
  ONAdd tmp(other);
  swap(tmp);
  return *this;
}
void ONAdd::swap(ONAdd & other) {

}

ONAdd::~ONAdd() { }

void ONAdd::accept(Visitor *v) { v->visitONAdd(this); }
ONAdd *ONAdd::clone() const {
  return new ONAdd(*this);
}

/********************   ONSub    ********************/
ONSub::ONSub() { }
ONSub::ONSub(const ONSub & other) { 
}
ONSub &ONSub::operator=(const ONSub & other) {
  ONSub tmp(other);
  swap(tmp);
  return *this;
}
void ONSub::swap(ONSub & other) {

}

ONSub::~ONSub() { }

void ONSub::accept(Visitor *v) { v->visitONSub(this); }
ONSub *ONSub::clone() const {
  return new ONSub(*this);
}

/********************   ONLSh    ********************/
ONLSh::ONLSh() { }
ONLSh::ONLSh(const ONLSh & other) { 
}
ONLSh &ONLSh::operator=(const ONLSh & other) {
  ONLSh tmp(other);
  swap(tmp);
  return *this;
}
void ONLSh::swap(ONLSh & other) {

}

ONLSh::~ONLSh() { }

void ONLSh::accept(Visitor *v) { v->visitONLSh(this); }
ONLSh *ONLSh::clone() const {
  return new ONLSh(*this);
}

/********************   ONRSh    ********************/
ONRSh::ONRSh() { }
ONRSh::ONRSh(const ONRSh & other) { 
}
ONRSh &ONRSh::operator=(const ONRSh & other) {
  ONRSh tmp(other);
  swap(tmp);
  return *this;
}
void ONRSh::swap(ONRSh & other) {

}

ONRSh::~ONRSh() { }

void ONRSh::accept(Visitor *v) { v->visitONRSh(this); }
ONRSh *ONRSh::clone() const {
  return new ONRSh(*this);
}

/********************   ONLT    ********************/
ONLT::ONLT() { }
ONLT::ONLT(const ONLT & other) { 
}
ONLT &ONLT::operator=(const ONLT & other) {
  ONLT tmp(other);
  swap(tmp);
  return *this;
}
void ONLT::swap(ONLT & other) {

}

ONLT::~ONLT() { }

void ONLT::accept(Visitor *v) { v->visitONLT(this); }
ONLT *ONLT::clone() const {
  return new ONLT(*this);
}

/********************   ONGT    ********************/
ONGT::ONGT() { }
ONGT::ONGT(const ONGT & other) { 
}
ONGT &ONGT::operator=(const ONGT & other) {
  ONGT tmp(other);
  swap(tmp);
  return *this;
}
void ONGT::swap(ONGT & other) {

}

ONGT::~ONGT() { }

void ONGT::accept(Visitor *v) { v->visitONGT(this); }
ONGT *ONGT::clone() const {
  return new ONGT(*this);
}

/********************   ONLE    ********************/
ONLE::ONLE() { }
ONLE::ONLE(const ONLE & other) { 
}
ONLE &ONLE::operator=(const ONLE & other) {
  ONLE tmp(other);
  swap(tmp);
  return *this;
}
void ONLE::swap(ONLE & other) {

}

ONLE::~ONLE() { }

void ONLE::accept(Visitor *v) { v->visitONLE(this); }
ONLE *ONLE::clone() const {
  return new ONLE(*this);
}

/********************   ONGE    ********************/
ONGE::ONGE() { }
ONGE::ONGE(const ONGE & other) { 
}
ONGE &ONGE::operator=(const ONGE & other) {
  ONGE tmp(other);
  swap(tmp);
  return *this;
}
void ONGE::swap(ONGE & other) {

}

ONGE::~ONGE() { }

void ONGE::accept(Visitor *v) { v->visitONGE(this); }
ONGE *ONGE::clone() const {
  return new ONGE(*this);
}

/********************   ONE    ********************/
ONE::ONE() { }
ONE::ONE(const ONE & other) { 
}
ONE &ONE::operator=(const ONE & other) {
  ONE tmp(other);
  swap(tmp);
  return *this;
}
void ONE::swap(ONE & other) {

}

ONE::~ONE() { }

void ONE::accept(Visitor *v) { v->visitONE(this); }
ONE *ONE::clone() const {
  return new ONE(*this);
}

/********************   ONNE    ********************/
ONNE::ONNE() { }
ONNE::ONNE(const ONNE & other) { 
}
ONNE &ONNE::operator=(const ONNE & other) {
  ONNE tmp(other);
  swap(tmp);
  return *this;
}
void ONNE::swap(ONNE & other) {

}

ONNE::~ONNE() { }

void ONNE::accept(Visitor *v) { v->visitONNE(this); }
ONNE *ONNE::clone() const {
  return new ONNE(*this);
}

/********************   ONBand    ********************/
ONBand::ONBand() { }
ONBand::ONBand(const ONBand & other) { 
}
ONBand &ONBand::operator=(const ONBand & other) {
  ONBand tmp(other);
  swap(tmp);
  return *this;
}
void ONBand::swap(ONBand & other) {

}

ONBand::~ONBand() { }

void ONBand::accept(Visitor *v) { v->visitONBand(this); }
ONBand *ONBand::clone() const {
  return new ONBand(*this);
}

/********************   ONBor    ********************/
ONBor::ONBor() { }
ONBor::ONBor(const ONBor & other) { 
}
ONBor &ONBor::operator=(const ONBor & other) {
  ONBor tmp(other);
  swap(tmp);
  return *this;
}
void ONBor::swap(ONBor & other) {

}

ONBor::~ONBor() { }

void ONBor::accept(Visitor *v) { v->visitONBor(this); }
ONBor *ONBor::clone() const {
  return new ONBor(*this);
}

/********************   ONBxor    ********************/
ONBxor::ONBxor() { }
ONBxor::ONBxor(const ONBxor & other) { 
}
ONBxor &ONBxor::operator=(const ONBxor & other) {
  ONBxor tmp(other);
  swap(tmp);
  return *this;
}
void ONBxor::swap(ONBxor & other) {

}

ONBxor::~ONBxor() { }

void ONBxor::accept(Visitor *v) { v->visitONBxor(this); }
ONBxor *ONBxor::clone() const {
  return new ONBxor(*this);
}

/********************   ONLand    ********************/
ONLand::ONLand() { }
ONLand::ONLand(const ONLand & other) { 
}
ONLand &ONLand::operator=(const ONLand & other) {
  ONLand tmp(other);
  swap(tmp);
  return *this;
}
void ONLand::swap(ONLand & other) {

}

ONLand::~ONLand() { }

void ONLand::accept(Visitor *v) { v->visitONLand(this); }
ONLand *ONLand::clone() const {
  return new ONLand(*this);
}

/********************   ONLor    ********************/
ONLor::ONLor() { }
ONLor::ONLor(const ONLor & other) { 
}
ONLor &ONLor::operator=(const ONLor & other) {
  ONLor tmp(other);
  swap(tmp);
  return *this;
}
void ONLor::swap(ONLor & other) {

}

ONLor::~ONLor() { }

void ONLor::accept(Visitor *v) { v->visitONLor(this); }
ONLor *ONLor::clone() const {
  return new ONLor(*this);
}

/********************   ONLxor    ********************/
ONLxor::ONLxor() { }
ONLxor::ONLxor(const ONLxor & other) { 
}
ONLxor &ONLxor::operator=(const ONLxor & other) {
  ONLxor tmp(other);
  swap(tmp);
  return *this;
}
void ONLxor::swap(ONLxor & other) {

}

ONLxor::~ONLxor() { }

void ONLxor::accept(Visitor *v) { v->visitONLxor(this); }
ONLxor *ONLxor::clone() const {
  return new ONLxor(*this);
}

/********************   OTIdentity    ********************/
OTIdentity::OTIdentity(Type *p1, OperatorName *p2, Expression *p3) { type_ = p1; operatorname_ = p2; expression_ = p3; }
OTIdentity::OTIdentity(const OTIdentity & other) {   type_ = other.type_->clone();
  operatorname_ = other.operatorname_->clone();
  expression_ = other.expression_->clone();

}
OTIdentity &OTIdentity::operator=(const OTIdentity & other) {
  OTIdentity tmp(other);
  swap(tmp);
  return *this;
}
void OTIdentity::swap(OTIdentity & other) {
  std::swap(type_, other.type_);
  std::swap(operatorname_, other.operatorname_);
  std::swap(expression_, other.expression_);

}

OTIdentity::~OTIdentity() { delete(type_); delete(operatorname_); delete(expression_); }

void OTIdentity::accept(Visitor *v) { v->visitOTIdentity(this); }
OTIdentity *OTIdentity::clone() const {
  return new OTIdentity(*this);
}

/********************   FSEntryPoint    ********************/
FSEntryPoint::FSEntryPoint() { }
FSEntryPoint::FSEntryPoint(const FSEntryPoint & other) { 
}
FSEntryPoint &FSEntryPoint::operator=(const FSEntryPoint & other) {
  FSEntryPoint tmp(other);
  swap(tmp);
  return *this;
}
void FSEntryPoint::swap(FSEntryPoint & other) {

}

FSEntryPoint::~FSEntryPoint() { }

void FSEntryPoint::accept(Visitor *v) { v->visitFSEntryPoint(this); }
FSEntryPoint *FSEntryPoint::clone() const {
  return new FSEntryPoint(*this);
}

/********************   FSPure    ********************/
FSPure::FSPure() { }
FSPure::FSPure(const FSPure & other) { 
}
FSPure &FSPure::operator=(const FSPure & other) {
  FSPure tmp(other);
  swap(tmp);
  return *this;
}
void FSPure::swap(FSPure & other) {

}

FSPure::~FSPure() { }

void FSPure::accept(Visitor *v) { v->visitFSPure(this); }
FSPure *FSPure::clone() const {
  return new FSPure(*this);
}

/********************   FSInline    ********************/
FSInline::FSInline() { }
FSInline::FSInline(const FSInline & other) { 
}
FSInline &FSInline::operator=(const FSInline & other) {
  FSInline tmp(other);
  swap(tmp);
  return *this;
}
void FSInline::swap(FSInline & other) {

}

FSInline::~FSInline() { }

void FSInline::accept(Visitor *v) { v->visitFSInline(this); }
FSInline *FSInline::clone() const {
  return new FSInline(*this);
}

/********************   FSAssociative    ********************/
FSAssociative::FSAssociative() { }
FSAssociative::FSAssociative(const FSAssociative & other) { 
}
FSAssociative &FSAssociative::operator=(const FSAssociative & other) {
  FSAssociative tmp(other);
  swap(tmp);
  return *this;
}
void FSAssociative::swap(FSAssociative & other) {

}

FSAssociative::~FSAssociative() { }

void FSAssociative::accept(Visitor *v) { v->visitFSAssociative(this); }
FSAssociative *FSAssociative::clone() const {
  return new FSAssociative(*this);
}

/********************   FSCommutative    ********************/
FSCommutative::FSCommutative() { }
FSCommutative::FSCommutative(const FSCommutative & other) { 
}
FSCommutative &FSCommutative::operator=(const FSCommutative & other) {
  FSCommutative tmp(other);
  swap(tmp);
  return *this;
}
void FSCommutative::swap(FSCommutative & other) {

}

FSCommutative::~FSCommutative() { }

void FSCommutative::accept(Visitor *v) { v->visitFSCommutative(this); }
FSCommutative *FSCommutative::clone() const {
  return new FSCommutative(*this);
}

/********************   FSAntiCommutative    ********************/
FSAntiCommutative::FSAntiCommutative() { }
FSAntiCommutative::FSAntiCommutative(const FSAntiCommutative & other) { 
}
FSAntiCommutative &FSAntiCommutative::operator=(const FSAntiCommutative & other) {
  FSAntiCommutative tmp(other);
  swap(tmp);
  return *this;
}
void FSAntiCommutative::swap(FSAntiCommutative & other) {

}

FSAntiCommutative::~FSAntiCommutative() { }

void FSAntiCommutative::accept(Visitor *v) { v->visitFSAntiCommutative(this); }
FSAntiCommutative *FSAntiCommutative::clone() const {
  return new FSAntiCommutative(*this);
}

/********************   FSInverse    ********************/
FSInverse::FSInverse(OperatorName *p1) { operatorname_ = p1; }
FSInverse::FSInverse(const FSInverse & other) {   operatorname_ = other.operatorname_->clone();

}
FSInverse &FSInverse::operator=(const FSInverse & other) {
  FSInverse tmp(other);
  swap(tmp);
  return *this;
}
void FSInverse::swap(FSInverse & other) {
  std::swap(operatorname_, other.operatorname_);

}

FSInverse::~FSInverse() { delete(operatorname_); }

void FSInverse::accept(Visitor *v) { v->visitFSInverse(this); }
FSInverse *FSInverse::clone() const {
  return new FSInverse(*this);
}

/********************   FSSelfInverse    ********************/
FSSelfInverse::FSSelfInverse() { }
FSSelfInverse::FSSelfInverse(const FSSelfInverse & other) { 
}
FSSelfInverse &FSSelfInverse::operator=(const FSSelfInverse & other) {
  FSSelfInverse tmp(other);
  swap(tmp);
  return *this;
}
void FSSelfInverse::swap(FSSelfInverse & other) {

}

FSSelfInverse::~FSSelfInverse() { }

void FSSelfInverse::accept(Visitor *v) { v->visitFSSelfInverse(this); }
FSSelfInverse *FSSelfInverse::clone() const {
  return new FSSelfInverse(*this);
}

/********************   VSConst    ********************/
VSConst::VSConst() { }
VSConst::VSConst(const VSConst & other) { 
}
VSConst &VSConst::operator=(const VSConst & other) {
  VSConst tmp(other);
  swap(tmp);
  return *this;
}
void VSConst::swap(VSConst & other) {

}

VSConst::~VSConst() { }

void VSConst::accept(Visitor *v) { v->visitVSConst(this); }
VSConst *VSConst::clone() const {
  return new VSConst(*this);
}

/********************   TSAlign    ********************/
TSAlign::TSAlign(Integer p1) { integer_ = p1; }
TSAlign::TSAlign(const TSAlign & other) {   integer_ = other.integer_;

}
TSAlign &TSAlign::operator=(const TSAlign & other) {
  TSAlign tmp(other);
  swap(tmp);
  return *this;
}
void TSAlign::swap(TSAlign & other) {
  std::swap(integer_, other.integer_);

}

TSAlign::~TSAlign() { }

void TSAlign::accept(Visitor *v) { v->visitTSAlign(this); }
TSAlign *TSAlign::clone() const {
  return new TSAlign(*this);
}

/********************   TSGeneric    ********************/
TSGeneric::TSGeneric(ListGenericParam *p1) { listgenericparam_ = p1; }
TSGeneric::TSGeneric(const TSGeneric & other) {   listgenericparam_ = other.listgenericparam_->clone();

}
TSGeneric &TSGeneric::operator=(const TSGeneric & other) {
  TSGeneric tmp(other);
  swap(tmp);
  return *this;
}
void TSGeneric::swap(TSGeneric & other) {
  std::swap(listgenericparam_, other.listgenericparam_);

}

TSGeneric::~TSGeneric() { delete(listgenericparam_); }

void TSGeneric::accept(Visitor *v) { v->visitTSGeneric(this); }
TSGeneric *TSGeneric::clone() const {
  return new TSGeneric(*this);
}

/********************   TSGParam    ********************/
TSGParam::TSGParam(Ident p1) { ident_ = p1; }
TSGParam::TSGParam(const TSGParam & other) {   ident_ = other.ident_;

}
TSGParam &TSGParam::operator=(const TSGParam & other) {
  TSGParam tmp(other);
  swap(tmp);
  return *this;
}
void TSGParam::swap(TSGParam & other) {
  std::swap(ident_, other.ident_);

}

TSGParam::~TSGParam() { }

void TSGParam::accept(Visitor *v) { v->visitTSGParam(this); }
TSGParam *TSGParam::clone() const {
  return new TSGParam(*this);
}

/********************   TAddress    ********************/
TAddress::TAddress() { }
TAddress::TAddress(const TAddress & other) { 
}
TAddress &TAddress::operator=(const TAddress & other) {
  TAddress tmp(other);
  swap(tmp);
  return *this;
}
void TAddress::swap(TAddress & other) {

}

TAddress::~TAddress() { }

void TAddress::accept(Visitor *v) { v->visitTAddress(this); }
TAddress *TAddress::clone() const {
  return new TAddress(*this);
}

/********************   TByte    ********************/
TByte::TByte() { }
TByte::TByte(const TByte & other) { 
}
TByte &TByte::operator=(const TByte & other) {
  TByte tmp(other);
  swap(tmp);
  return *this;
}
void TByte::swap(TByte & other) {

}

TByte::~TByte() { }

void TByte::accept(Visitor *v) { v->visitTByte(this); }
TByte *TByte::clone() const {
  return new TByte(*this);
}

/********************   TCustom    ********************/
TCustom::TCustom(Ident p1) { ident_ = p1; }
TCustom::TCustom(const TCustom & other) {   ident_ = other.ident_;

}
TCustom &TCustom::operator=(const TCustom & other) {
  TCustom tmp(other);
  swap(tmp);
  return *this;
}
void TCustom::swap(TCustom & other) {
  std::swap(ident_, other.ident_);

}

TCustom::~TCustom() { }

void TCustom::accept(Visitor *v) { v->visitTCustom(this); }
TCustom *TCustom::clone() const {
  return new TCustom(*this);
}

/********************   TFixedArray    ********************/
TFixedArray::TFixedArray(Type *p1, Integer p2) { type_ = p1; integer_ = p2; }
TFixedArray::TFixedArray(const TFixedArray & other) {   type_ = other.type_->clone();
  integer_ = other.integer_;

}
TFixedArray &TFixedArray::operator=(const TFixedArray & other) {
  TFixedArray tmp(other);
  swap(tmp);
  return *this;
}
void TFixedArray::swap(TFixedArray & other) {
  std::swap(type_, other.type_);
  std::swap(integer_, other.integer_);

}

TFixedArray::~TFixedArray() { delete(type_); }

void TFixedArray::accept(Visitor *v) { v->visitTFixedArray(this); }
TFixedArray *TFixedArray::clone() const {
  return new TFixedArray(*this);
}

/********************   TGenericArray    ********************/
TGenericArray::TGenericArray(Type *p1) { type_ = p1; }
TGenericArray::TGenericArray(const TGenericArray & other) {   type_ = other.type_->clone();

}
TGenericArray &TGenericArray::operator=(const TGenericArray & other) {
  TGenericArray tmp(other);
  swap(tmp);
  return *this;
}
void TGenericArray::swap(TGenericArray & other) {
  std::swap(type_, other.type_);

}

TGenericArray::~TGenericArray() { delete(type_); }

void TGenericArray::accept(Visitor *v) { v->visitTGenericArray(this); }
TGenericArray *TGenericArray::clone() const {
  return new TGenericArray(*this);
}

/********************   TStruct    ********************/
TStruct::TStruct(ListStructMemberDeclaration *p1) { liststructmemberdeclaration_ = p1; }
TStruct::TStruct(const TStruct & other) {   liststructmemberdeclaration_ = other.liststructmemberdeclaration_->clone();

}
TStruct &TStruct::operator=(const TStruct & other) {
  TStruct tmp(other);
  swap(tmp);
  return *this;
}
void TStruct::swap(TStruct & other) {
  std::swap(liststructmemberdeclaration_, other.liststructmemberdeclaration_);

}

TStruct::~TStruct() { delete(liststructmemberdeclaration_); }

void TStruct::accept(Visitor *v) { v->visitTStruct(this); }
TStruct *TStruct::clone() const {
  return new TStruct(*this);
}

/********************   SMDMemberDeclaration    ********************/
SMDMemberDeclaration::SMDMemberDeclaration(Type *p1, Ident p2) { type_ = p1; ident_ = p2; }
SMDMemberDeclaration::SMDMemberDeclaration(const SMDMemberDeclaration & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;

}
SMDMemberDeclaration &SMDMemberDeclaration::operator=(const SMDMemberDeclaration & other) {
  SMDMemberDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void SMDMemberDeclaration::swap(SMDMemberDeclaration & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

SMDMemberDeclaration::~SMDMemberDeclaration() { delete(type_); }

void SMDMemberDeclaration::accept(Visitor *v) { v->visitSMDMemberDeclaration(this); }
SMDMemberDeclaration *SMDMemberDeclaration::clone() const {
  return new SMDMemberDeclaration(*this);
}

/********************   SMDAnonMemberDeclaration    ********************/
SMDAnonMemberDeclaration::SMDAnonMemberDeclaration(Type *p1) { type_ = p1; }
SMDAnonMemberDeclaration::SMDAnonMemberDeclaration(const SMDAnonMemberDeclaration & other) {   type_ = other.type_->clone();

}
SMDAnonMemberDeclaration &SMDAnonMemberDeclaration::operator=(const SMDAnonMemberDeclaration & other) {
  SMDAnonMemberDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void SMDAnonMemberDeclaration::swap(SMDAnonMemberDeclaration & other) {
  std::swap(type_, other.type_);

}

SMDAnonMemberDeclaration::~SMDAnonMemberDeclaration() { delete(type_); }

void SMDAnonMemberDeclaration::accept(Visitor *v) { v->visitSMDAnonMemberDeclaration(this); }
SMDAnonMemberDeclaration *SMDAnonMemberDeclaration::clone() const {
  return new SMDAnonMemberDeclaration(*this);
}

/********************   PDAutoParameter    ********************/
PDAutoParameter::PDAutoParameter(ListVariableSpecifier *p1, Ident p2) { listvariablespecifier_ = p1; ident_ = p2; }
PDAutoParameter::PDAutoParameter(const PDAutoParameter & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  ident_ = other.ident_;

}
PDAutoParameter &PDAutoParameter::operator=(const PDAutoParameter & other) {
  PDAutoParameter tmp(other);
  swap(tmp);
  return *this;
}
void PDAutoParameter::swap(PDAutoParameter & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(ident_, other.ident_);

}

PDAutoParameter::~PDAutoParameter() { delete(listvariablespecifier_); }

void PDAutoParameter::accept(Visitor *v) { v->visitPDAutoParameter(this); }
PDAutoParameter *PDAutoParameter::clone() const {
  return new PDAutoParameter(*this);
}

/********************   PDTypedParameter    ********************/
PDTypedParameter::PDTypedParameter(ListVariableSpecifier *p1, Type *p2, Ident p3) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; }
PDTypedParameter::PDTypedParameter(const PDTypedParameter & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
PDTypedParameter &PDTypedParameter::operator=(const PDTypedParameter & other) {
  PDTypedParameter tmp(other);
  swap(tmp);
  return *this;
}
void PDTypedParameter::swap(PDTypedParameter & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

PDTypedParameter::~PDTypedParameter() { delete(listvariablespecifier_); delete(type_); }

void PDTypedParameter::accept(Visitor *v) { v->visitPDTypedParameter(this); }
PDTypedParameter *PDTypedParameter::clone() const {
  return new PDTypedParameter(*this);
}

/********************   SReturn    ********************/
SReturn::SReturn(Expression *p1) { expression_ = p1; }
SReturn::SReturn(const SReturn & other) {   expression_ = other.expression_->clone();

}
SReturn &SReturn::operator=(const SReturn & other) {
  SReturn tmp(other);
  swap(tmp);
  return *this;
}
void SReturn::swap(SReturn & other) {
  std::swap(expression_, other.expression_);

}

SReturn::~SReturn() { delete(expression_); }

void SReturn::accept(Visitor *v) { v->visitSReturn(this); }
SReturn *SReturn::clone() const {
  return new SReturn(*this);
}

/********************   SExpression    ********************/
SExpression::SExpression(Expression *p1) { expression_ = p1; }
SExpression::SExpression(const SExpression & other) {   expression_ = other.expression_->clone();

}
SExpression &SExpression::operator=(const SExpression & other) {
  SExpression tmp(other);
  swap(tmp);
  return *this;
}
void SExpression::swap(SExpression & other) {
  std::swap(expression_, other.expression_);

}

SExpression::~SExpression() { delete(expression_); }

void SExpression::accept(Visitor *v) { v->visitSExpression(this); }
SExpression *SExpression::clone() const {
  return new SExpression(*this);
}

/********************   SScope    ********************/
SScope::SScope(ListStatement *p1) { liststatement_ = p1; }
SScope::SScope(const SScope & other) {   liststatement_ = other.liststatement_->clone();

}
SScope &SScope::operator=(const SScope & other) {
  SScope tmp(other);
  swap(tmp);
  return *this;
}
void SScope::swap(SScope & other) {
  std::swap(liststatement_, other.liststatement_);

}

SScope::~SScope() { delete(liststatement_); }

void SScope::accept(Visitor *v) { v->visitSScope(this); }
SScope *SScope::clone() const {
  return new SScope(*this);
}

/********************   SIf    ********************/
SIf::SIf(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SIf::SIf(const SIf & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SIf &SIf::operator=(const SIf & other) {
  SIf tmp(other);
  swap(tmp);
  return *this;
}
void SIf::swap(SIf & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SIf::~SIf() { delete(expression_); delete(liststatement_); }

void SIf::accept(Visitor *v) { v->visitSIf(this); }
SIf *SIf::clone() const {
  return new SIf(*this);
}

/********************   SIfElse    ********************/
SIfElse::SIfElse(Expression *p1, ListStatement *p2, ListStatement *p3) { expression_ = p1; liststatement_1 = p2; liststatement_2 = p3; }
SIfElse::SIfElse(const SIfElse & other) {   expression_ = other.expression_->clone();
  liststatement_1 = other.liststatement_1->clone();
  liststatement_2 = other.liststatement_2->clone();

}
SIfElse &SIfElse::operator=(const SIfElse & other) {
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}
void SIfElse::swap(SIfElse & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_1, other.liststatement_1);
  std::swap(liststatement_2, other.liststatement_2);

}

SIfElse::~SIfElse() { delete(expression_); delete(liststatement_1); delete(liststatement_2); }

void SIfElse::accept(Visitor *v) { v->visitSIfElse(this); }
SIfElse *SIfElse::clone() const {
  return new SIfElse(*this);
}

/********************   SLoop    ********************/
SLoop::SLoop(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SLoop::SLoop(const SLoop & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SLoop &SLoop::operator=(const SLoop & other) {
  SLoop tmp(other);
  swap(tmp);
  return *this;
}
void SLoop::swap(SLoop & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SLoop::~SLoop() { delete(expression_); delete(liststatement_); }

void SLoop::accept(Visitor *v) { v->visitSLoop(this); }
SLoop *SLoop::clone() const {
  return new SLoop(*this);
}

/********************   SWhile    ********************/
SWhile::SWhile(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SWhile::SWhile(const SWhile & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SWhile &SWhile::operator=(const SWhile & other) {
  SWhile tmp(other);
  swap(tmp);
  return *this;
}
void SWhile::swap(SWhile & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SWhile::~SWhile() { delete(expression_); delete(liststatement_); }

void SWhile::accept(Visitor *v) { v->visitSWhile(this); }
SWhile *SWhile::clone() const {
  return new SWhile(*this);
}

/********************   SUntil    ********************/
SUntil::SUntil(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SUntil::SUntil(const SUntil & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SUntil &SUntil::operator=(const SUntil & other) {
  SUntil tmp(other);
  swap(tmp);
  return *this;
}
void SUntil::swap(SUntil & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SUntil::~SUntil() { delete(expression_); delete(liststatement_); }

void SUntil::accept(Visitor *v) { v->visitSUntil(this); }
SUntil *SUntil::clone() const {
  return new SUntil(*this);
}

/********************   SFor    ********************/
SFor::SFor(ListExpression *p1, Expression *p2, ListExpression *p3, ListStatement *p4) { listexpression_1 = p1; expression_ = p2; listexpression_2 = p3; liststatement_ = p4; }
SFor::SFor(const SFor & other) {   listexpression_1 = other.listexpression_1->clone();
  expression_ = other.expression_->clone();
  listexpression_2 = other.listexpression_2->clone();
  liststatement_ = other.liststatement_->clone();

}
SFor &SFor::operator=(const SFor & other) {
  SFor tmp(other);
  swap(tmp);
  return *this;
}
void SFor::swap(SFor & other) {
  std::swap(listexpression_1, other.listexpression_1);
  std::swap(expression_, other.expression_);
  std::swap(listexpression_2, other.listexpression_2);
  std::swap(liststatement_, other.liststatement_);

}

SFor::~SFor() { delete(listexpression_1); delete(expression_); delete(listexpression_2); delete(liststatement_); }

void SFor::accept(Visitor *v) { v->visitSFor(this); }
SFor *SFor::clone() const {
  return new SFor(*this);
}

/********************   SForEach    ********************/
SForEach::SForEach(Ident p1, Expression *p2, ListStatement *p3) { ident_ = p1; expression_ = p2; liststatement_ = p3; }
SForEach::SForEach(const SForEach & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SForEach &SForEach::operator=(const SForEach & other) {
  SForEach tmp(other);
  swap(tmp);
  return *this;
}
void SForEach::swap(SForEach & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SForEach::~SForEach() { delete(expression_); delete(liststatement_); }

void SForEach::accept(Visitor *v) { v->visitSForEach(this); }
SForEach *SForEach::clone() const {
  return new SForEach(*this);
}

/********************   SForAll    ********************/
SForAll::SForAll(Ident p1, Expression *p2, ListStatement *p3) { ident_ = p1; expression_ = p2; liststatement_ = p3; }
SForAll::SForAll(const SForAll & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SForAll &SForAll::operator=(const SForAll & other) {
  SForAll tmp(other);
  swap(tmp);
  return *this;
}
void SForAll::swap(SForAll & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SForAll::~SForAll() { delete(expression_); delete(liststatement_); }

void SForAll::accept(Visitor *v) { v->visitSForAll(this); }
SForAll *SForAll::clone() const {
  return new SForAll(*this);
}

/********************   SBreak    ********************/
SBreak::SBreak() { }
SBreak::SBreak(const SBreak & other) { 
}
SBreak &SBreak::operator=(const SBreak & other) {
  SBreak tmp(other);
  swap(tmp);
  return *this;
}
void SBreak::swap(SBreak & other) {

}

SBreak::~SBreak() { }

void SBreak::accept(Visitor *v) { v->visitSBreak(this); }
SBreak *SBreak::clone() const {
  return new SBreak(*this);
}

/********************   SContinue    ********************/
SContinue::SContinue() { }
SContinue::SContinue(const SContinue & other) { 
}
SContinue &SContinue::operator=(const SContinue & other) {
  SContinue tmp(other);
  swap(tmp);
  return *this;
}
void SContinue::swap(SContinue & other) {

}

SContinue::~SContinue() { }

void SContinue::accept(Visitor *v) { v->visitSContinue(this); }
SContinue *SContinue::clone() const {
  return new SContinue(*this);
}

/********************   SBreakpoint    ********************/
SBreakpoint::SBreakpoint() { }
SBreakpoint::SBreakpoint(const SBreakpoint & other) { 
}
SBreakpoint &SBreakpoint::operator=(const SBreakpoint & other) {
  SBreakpoint tmp(other);
  swap(tmp);
  return *this;
}
void SBreakpoint::swap(SBreakpoint & other) {

}

SBreakpoint::~SBreakpoint() { }

void SBreakpoint::accept(Visitor *v) { v->visitSBreakpoint(this); }
SBreakpoint *SBreakpoint::clone() const {
  return new SBreakpoint(*this);
}

/********************   SIVariable    ********************/
SIVariable::SIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; expression_ = p4; }
SIVariable::SIVariable(const SIVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
SIVariable &SIVariable::operator=(const SIVariable & other) {
  SIVariable tmp(other);
  swap(tmp);
  return *this;
}
void SIVariable::swap(SIVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

SIVariable::~SIVariable() { delete(listvariablespecifier_); delete(type_); delete(expression_); }

void SIVariable::accept(Visitor *v) { v->visitSIVariable(this); }
SIVariable *SIVariable::clone() const {
  return new SIVariable(*this);
}

/********************   SVariable    ********************/
SVariable::SVariable(ListVariableSpecifier *p1, Type *p2, Ident p3) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; }
SVariable::SVariable(const SVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
SVariable &SVariable::operator=(const SVariable & other) {
  SVariable tmp(other);
  swap(tmp);
  return *this;
}
void SVariable::swap(SVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

SVariable::~SVariable() { delete(listvariablespecifier_); delete(type_); }

void SVariable::accept(Visitor *v) { v->visitSVariable(this); }
SVariable *SVariable::clone() const {
  return new SVariable(*this);
}

/********************   RVIdent    ********************/
RVIdent::RVIdent(Ident p1) { ident_ = p1; }
RVIdent::RVIdent(const RVIdent & other) {   ident_ = other.ident_;

}
RVIdent &RVIdent::operator=(const RVIdent & other) {
  RVIdent tmp(other);
  swap(tmp);
  return *this;
}
void RVIdent::swap(RVIdent & other) {
  std::swap(ident_, other.ident_);

}

RVIdent::~RVIdent() { }

void RVIdent::accept(Visitor *v) { v->visitRVIdent(this); }
RVIdent *RVIdent::clone() const {
  return new RVIdent(*this);
}

/********************   RVQualified    ********************/
RVQualified::RVQualified(Ident p1, RValue *p2) { ident_ = p1; rvalue_ = p2; }
RVQualified::RVQualified(const RVQualified & other) {   ident_ = other.ident_;
  rvalue_ = other.rvalue_->clone();

}
RVQualified &RVQualified::operator=(const RVQualified & other) {
  RVQualified tmp(other);
  swap(tmp);
  return *this;
}
void RVQualified::swap(RVQualified & other) {
  std::swap(ident_, other.ident_);
  std::swap(rvalue_, other.rvalue_);

}

RVQualified::~RVQualified() { delete(rvalue_); }

void RVQualified::accept(Visitor *v) { v->visitRVQualified(this); }
RVQualified *RVQualified::clone() const {
  return new RVQualified(*this);
}

/********************   EDouble    ********************/
EDouble::EDouble(Double p1) { double_ = p1; }
EDouble::EDouble(const EDouble & other) {   double_ = other.double_;

}
EDouble &EDouble::operator=(const EDouble & other) {
  EDouble tmp(other);
  swap(tmp);
  return *this;
}
void EDouble::swap(EDouble & other) {
  std::swap(double_, other.double_);

}

EDouble::~EDouble() { }

void EDouble::accept(Visitor *v) { v->visitEDouble(this); }
EDouble *EDouble::clone() const {
  return new EDouble(*this);
}

/********************   EInteger    ********************/
EInteger::EInteger(Integer p1) { integer_ = p1; }
EInteger::EInteger(const EInteger & other) {   integer_ = other.integer_;

}
EInteger &EInteger::operator=(const EInteger & other) {
  EInteger tmp(other);
  swap(tmp);
  return *this;
}
void EInteger::swap(EInteger & other) {
  std::swap(integer_, other.integer_);

}

EInteger::~EInteger() { }

void EInteger::accept(Visitor *v) { v->visitEInteger(this); }
EInteger *EInteger::clone() const {
  return new EInteger(*this);
}

/********************   EString    ********************/
EString::EString(CString p1) { cstring_ = p1; }
EString::EString(const EString & other) {   cstring_ = other.cstring_;

}
EString &EString::operator=(const EString & other) {
  EString tmp(other);
  swap(tmp);
  return *this;
}
void EString::swap(EString & other) {
  std::swap(cstring_, other.cstring_);

}

EString::~EString() { }

void EString::accept(Visitor *v) { v->visitEString(this); }
EString *EString::clone() const {
  return new EString(*this);
}

/********************   EChar    ********************/
EChar::EChar(CChar p1) { cchar_ = p1; }
EChar::EChar(const EChar & other) {   cchar_ = other.cchar_;

}
EChar &EChar::operator=(const EChar & other) {
  EChar tmp(other);
  swap(tmp);
  return *this;
}
void EChar::swap(EChar & other) {
  std::swap(cchar_, other.cchar_);

}

EChar::~EChar() { }

void EChar::accept(Visitor *v) { v->visitEChar(this); }
EChar *EChar::clone() const {
  return new EChar(*this);
}

/********************   EPi    ********************/
EPi::EPi() { }
EPi::EPi(const EPi & other) { 
}
EPi &EPi::operator=(const EPi & other) {
  EPi tmp(other);
  swap(tmp);
  return *this;
}
void EPi::swap(EPi & other) {

}

EPi::~EPi() { }

void EPi::accept(Visitor *v) { v->visitEPi(this); }
EPi *EPi::clone() const {
  return new EPi(*this);
}

/********************   ERValue    ********************/
ERValue::ERValue(RValue *p1) { rvalue_ = p1; }
ERValue::ERValue(const ERValue & other) {   rvalue_ = other.rvalue_->clone();

}
ERValue &ERValue::operator=(const ERValue & other) {
  ERValue tmp(other);
  swap(tmp);
  return *this;
}
void ERValue::swap(ERValue & other) {
  std::swap(rvalue_, other.rvalue_);

}

ERValue::~ERValue() { delete(rvalue_); }

void ERValue::accept(Visitor *v) { v->visitERValue(this); }
ERValue *ERValue::clone() const {
  return new ERValue(*this);
}

/********************   EArray    ********************/
EArray::EArray(ListExpression *p1) { listexpression_ = p1; }
EArray::EArray(const EArray & other) {   listexpression_ = other.listexpression_->clone();

}
EArray &EArray::operator=(const EArray & other) {
  EArray tmp(other);
  swap(tmp);
  return *this;
}
void EArray::swap(EArray & other) {
  std::swap(listexpression_, other.listexpression_);

}

EArray::~EArray() { delete(listexpression_); }

void EArray::accept(Visitor *v) { v->visitEArray(this); }
EArray *EArray::clone() const {
  return new EArray(*this);
}

/********************   EList    ********************/
EList::EList(ListExpression *p1) { listexpression_ = p1; }
EList::EList(const EList & other) {   listexpression_ = other.listexpression_->clone();

}
EList &EList::operator=(const EList & other) {
  EList tmp(other);
  swap(tmp);
  return *this;
}
void EList::swap(EList & other) {
  std::swap(listexpression_, other.listexpression_);

}

EList::~EList() { delete(listexpression_); }

void EList::accept(Visitor *v) { v->visitEList(this); }
EList *EList::clone() const {
  return new EList(*this);
}

/********************   EAComp    ********************/
EAComp::EAComp(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
EAComp::EAComp(const EAComp & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
EAComp &EAComp::operator=(const EAComp & other) {
  EAComp tmp(other);
  swap(tmp);
  return *this;
}
void EAComp::swap(EAComp & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

EAComp::~EAComp() { delete(expression_); delete(listexpression_); }

void EAComp::accept(Visitor *v) { v->visitEAComp(this); }
EAComp *EAComp::clone() const {
  return new EAComp(*this);
}

/********************   ELComp    ********************/
ELComp::ELComp(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
ELComp::ELComp(const ELComp & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
ELComp &ELComp::operator=(const ELComp & other) {
  ELComp tmp(other);
  swap(tmp);
  return *this;
}
void ELComp::swap(ELComp & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

ELComp::~ELComp() { delete(expression_); delete(listexpression_); }

void ELComp::accept(Visitor *v) { v->visitELComp(this); }
ELComp *ELComp::clone() const {
  return new ELComp(*this);
}

/********************   EIndex    ********************/
EIndex::EIndex(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIndex::EIndex(const EIndex & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIndex &EIndex::operator=(const EIndex & other) {
  EIndex tmp(other);
  swap(tmp);
  return *this;
}
void EIndex::swap(EIndex & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIndex::~EIndex() { delete(expression_1); delete(expression_2); }

void EIndex::accept(Visitor *v) { v->visitEIndex(this); }
EIndex *EIndex::clone() const {
  return new EIndex(*this);
}

/********************   ESimpleCall    ********************/
ESimpleCall::ESimpleCall(RValue *p1) { rvalue_ = p1; }
ESimpleCall::ESimpleCall(const ESimpleCall & other) {   rvalue_ = other.rvalue_->clone();

}
ESimpleCall &ESimpleCall::operator=(const ESimpleCall & other) {
  ESimpleCall tmp(other);
  swap(tmp);
  return *this;
}
void ESimpleCall::swap(ESimpleCall & other) {
  std::swap(rvalue_, other.rvalue_);

}

ESimpleCall::~ESimpleCall() { delete(rvalue_); }

void ESimpleCall::accept(Visitor *v) { v->visitESimpleCall(this); }
ESimpleCall *ESimpleCall::clone() const {
  return new ESimpleCall(*this);
}

/********************   ECall    ********************/
ECall::ECall(RValue *p1, ListExpression *p2) { rvalue_ = p1; listexpression_ = p2; }
ECall::ECall(const ECall & other) {   rvalue_ = other.rvalue_->clone();
  listexpression_ = other.listexpression_->clone();

}
ECall &ECall::operator=(const ECall & other) {
  ECall tmp(other);
  swap(tmp);
  return *this;
}
void ECall::swap(ECall & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(listexpression_, other.listexpression_);

}

ECall::~ECall() { delete(rvalue_); delete(listexpression_); }

void ECall::accept(Visitor *v) { v->visitECall(this); }
ECall *ECall::clone() const {
  return new ECall(*this);
}

/********************   EPostInc    ********************/
EPostInc::EPostInc(RValue *p1) { rvalue_ = p1; }
EPostInc::EPostInc(const EPostInc & other) {   rvalue_ = other.rvalue_->clone();

}
EPostInc &EPostInc::operator=(const EPostInc & other) {
  EPostInc tmp(other);
  swap(tmp);
  return *this;
}
void EPostInc::swap(EPostInc & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPostInc::~EPostInc() { delete(rvalue_); }

void EPostInc::accept(Visitor *v) { v->visitEPostInc(this); }
EPostInc *EPostInc::clone() const {
  return new EPostInc(*this);
}

/********************   EPostDec    ********************/
EPostDec::EPostDec(RValue *p1) { rvalue_ = p1; }
EPostDec::EPostDec(const EPostDec & other) {   rvalue_ = other.rvalue_->clone();

}
EPostDec &EPostDec::operator=(const EPostDec & other) {
  EPostDec tmp(other);
  swap(tmp);
  return *this;
}
void EPostDec::swap(EPostDec & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPostDec::~EPostDec() { delete(rvalue_); }

void EPostDec::accept(Visitor *v) { v->visitEPostDec(this); }
EPostDec *EPostDec::clone() const {
  return new EPostDec(*this);
}

/********************   EIntrinAddB    ********************/
EIntrinAddB::EIntrinAddB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAddB::EIntrinAddB(const EIntrinAddB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAddB &EIntrinAddB::operator=(const EIntrinAddB & other) {
  EIntrinAddB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAddB::swap(EIntrinAddB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAddB::~EIntrinAddB() { delete(expression_1); delete(expression_2); }

void EIntrinAddB::accept(Visitor *v) { v->visitEIntrinAddB(this); }
EIntrinAddB *EIntrinAddB::clone() const {
  return new EIntrinAddB(*this);
}

/********************   EIntrinSubB    ********************/
EIntrinSubB::EIntrinSubB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSubB::EIntrinSubB(const EIntrinSubB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSubB &EIntrinSubB::operator=(const EIntrinSubB & other) {
  EIntrinSubB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSubB::swap(EIntrinSubB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSubB::~EIntrinSubB() { delete(expression_1); delete(expression_2); }

void EIntrinSubB::accept(Visitor *v) { v->visitEIntrinSubB(this); }
EIntrinSubB *EIntrinSubB::clone() const {
  return new EIntrinSubB(*this);
}

/********************   EIntrinMulB    ********************/
EIntrinMulB::EIntrinMulB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMulB::EIntrinMulB(const EIntrinMulB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMulB &EIntrinMulB::operator=(const EIntrinMulB & other) {
  EIntrinMulB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMulB::swap(EIntrinMulB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMulB::~EIntrinMulB() { delete(expression_1); delete(expression_2); }

void EIntrinMulB::accept(Visitor *v) { v->visitEIntrinMulB(this); }
EIntrinMulB *EIntrinMulB::clone() const {
  return new EIntrinMulB(*this);
}

/********************   EIntrinUdivB    ********************/
EIntrinUdivB::EIntrinUdivB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdivB::EIntrinUdivB(const EIntrinUdivB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdivB &EIntrinUdivB::operator=(const EIntrinUdivB & other) {
  EIntrinUdivB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdivB::swap(EIntrinUdivB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdivB::~EIntrinUdivB() { delete(expression_1); delete(expression_2); }

void EIntrinUdivB::accept(Visitor *v) { v->visitEIntrinUdivB(this); }
EIntrinUdivB *EIntrinUdivB::clone() const {
  return new EIntrinUdivB(*this);
}

/********************   EIntrinSdivB    ********************/
EIntrinSdivB::EIntrinSdivB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSdivB::EIntrinSdivB(const EIntrinSdivB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdivB &EIntrinSdivB::operator=(const EIntrinSdivB & other) {
  EIntrinSdivB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdivB::swap(EIntrinSdivB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdivB::~EIntrinSdivB() { delete(expression_1); delete(expression_2); }

void EIntrinSdivB::accept(Visitor *v) { v->visitEIntrinSdivB(this); }
EIntrinSdivB *EIntrinSdivB::clone() const {
  return new EIntrinSdivB(*this);
}

/********************   EIntrinUremB    ********************/
EIntrinUremB::EIntrinUremB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUremB::EIntrinUremB(const EIntrinUremB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUremB &EIntrinUremB::operator=(const EIntrinUremB & other) {
  EIntrinUremB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUremB::swap(EIntrinUremB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUremB::~EIntrinUremB() { delete(expression_1); delete(expression_2); }

void EIntrinUremB::accept(Visitor *v) { v->visitEIntrinUremB(this); }
EIntrinUremB *EIntrinUremB::clone() const {
  return new EIntrinUremB(*this);
}

/********************   EIntrinSremB    ********************/
EIntrinSremB::EIntrinSremB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSremB::EIntrinSremB(const EIntrinSremB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSremB &EIntrinSremB::operator=(const EIntrinSremB & other) {
  EIntrinSremB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSremB::swap(EIntrinSremB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSremB::~EIntrinSremB() { delete(expression_1); delete(expression_2); }

void EIntrinSremB::accept(Visitor *v) { v->visitEIntrinSremB(this); }
EIntrinSremB *EIntrinSremB::clone() const {
  return new EIntrinSremB(*this);
}

/********************   EIntrinAndB    ********************/
EIntrinAndB::EIntrinAndB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAndB::EIntrinAndB(const EIntrinAndB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAndB &EIntrinAndB::operator=(const EIntrinAndB & other) {
  EIntrinAndB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAndB::swap(EIntrinAndB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAndB::~EIntrinAndB() { delete(expression_1); delete(expression_2); }

void EIntrinAndB::accept(Visitor *v) { v->visitEIntrinAndB(this); }
EIntrinAndB *EIntrinAndB::clone() const {
  return new EIntrinAndB(*this);
}

/********************   EIntrinOrB    ********************/
EIntrinOrB::EIntrinOrB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinOrB::EIntrinOrB(const EIntrinOrB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinOrB &EIntrinOrB::operator=(const EIntrinOrB & other) {
  EIntrinOrB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinOrB::swap(EIntrinOrB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinOrB::~EIntrinOrB() { delete(expression_1); delete(expression_2); }

void EIntrinOrB::accept(Visitor *v) { v->visitEIntrinOrB(this); }
EIntrinOrB *EIntrinOrB::clone() const {
  return new EIntrinOrB(*this);
}

/********************   EIntrinXorB    ********************/
EIntrinXorB::EIntrinXorB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinXorB::EIntrinXorB(const EIntrinXorB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinXorB &EIntrinXorB::operator=(const EIntrinXorB & other) {
  EIntrinXorB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinXorB::swap(EIntrinXorB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinXorB::~EIntrinXorB() { delete(expression_1); delete(expression_2); }

void EIntrinXorB::accept(Visitor *v) { v->visitEIntrinXorB(this); }
EIntrinXorB *EIntrinXorB::clone() const {
  return new EIntrinXorB(*this);
}

/********************   EIntrinShlB    ********************/
EIntrinShlB::EIntrinShlB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinShlB::EIntrinShlB(const EIntrinShlB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShlB &EIntrinShlB::operator=(const EIntrinShlB & other) {
  EIntrinShlB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShlB::swap(EIntrinShlB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShlB::~EIntrinShlB() { delete(expression_1); delete(expression_2); }

void EIntrinShlB::accept(Visitor *v) { v->visitEIntrinShlB(this); }
EIntrinShlB *EIntrinShlB::clone() const {
  return new EIntrinShlB(*this);
}

/********************   EIntrinLshrB    ********************/
EIntrinLshrB::EIntrinLshrB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinLshrB::EIntrinLshrB(const EIntrinLshrB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshrB &EIntrinLshrB::operator=(const EIntrinLshrB & other) {
  EIntrinLshrB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshrB::swap(EIntrinLshrB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshrB::~EIntrinLshrB() { delete(expression_1); delete(expression_2); }

void EIntrinLshrB::accept(Visitor *v) { v->visitEIntrinLshrB(this); }
EIntrinLshrB *EIntrinLshrB::clone() const {
  return new EIntrinLshrB(*this);
}

/********************   EIntrinAshrB    ********************/
EIntrinAshrB::EIntrinAshrB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAshrB::EIntrinAshrB(const EIntrinAshrB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshrB &EIntrinAshrB::operator=(const EIntrinAshrB & other) {
  EIntrinAshrB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshrB::swap(EIntrinAshrB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshrB::~EIntrinAshrB() { delete(expression_1); delete(expression_2); }

void EIntrinAshrB::accept(Visitor *v) { v->visitEIntrinAshrB(this); }
EIntrinAshrB *EIntrinAshrB::clone() const {
  return new EIntrinAshrB(*this);
}

/********************   EIntrinNotB    ********************/
EIntrinNotB::EIntrinNotB(Expression *p1) { expression_ = p1; }
EIntrinNotB::EIntrinNotB(const EIntrinNotB & other) {   expression_ = other.expression_->clone();

}
EIntrinNotB &EIntrinNotB::operator=(const EIntrinNotB & other) {
  EIntrinNotB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNotB::swap(EIntrinNotB & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNotB::~EIntrinNotB() { delete(expression_); }

void EIntrinNotB::accept(Visitor *v) { v->visitEIntrinNotB(this); }
EIntrinNotB *EIntrinNotB::clone() const {
  return new EIntrinNotB(*this);
}

/********************   EIntrinNegB    ********************/
EIntrinNegB::EIntrinNegB(Expression *p1) { expression_ = p1; }
EIntrinNegB::EIntrinNegB(const EIntrinNegB & other) {   expression_ = other.expression_->clone();

}
EIntrinNegB &EIntrinNegB::operator=(const EIntrinNegB & other) {
  EIntrinNegB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNegB::swap(EIntrinNegB & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNegB::~EIntrinNegB() { delete(expression_); }

void EIntrinNegB::accept(Visitor *v) { v->visitEIntrinNegB(this); }
EIntrinNegB *EIntrinNegB::clone() const {
  return new EIntrinNegB(*this);
}

/********************   EIntrinCEqB    ********************/
EIntrinCEqB::EIntrinCEqB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCEqB::EIntrinCEqB(const EIntrinCEqB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCEqB &EIntrinCEqB::operator=(const EIntrinCEqB & other) {
  EIntrinCEqB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCEqB::swap(EIntrinCEqB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCEqB::~EIntrinCEqB() { delete(expression_1); delete(expression_2); }

void EIntrinCEqB::accept(Visitor *v) { v->visitEIntrinCEqB(this); }
EIntrinCEqB *EIntrinCEqB::clone() const {
  return new EIntrinCEqB(*this);
}

/********************   EIntrinCNeB    ********************/
EIntrinCNeB::EIntrinCNeB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCNeB::EIntrinCNeB(const EIntrinCNeB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCNeB &EIntrinCNeB::operator=(const EIntrinCNeB & other) {
  EIntrinCNeB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCNeB::swap(EIntrinCNeB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCNeB::~EIntrinCNeB() { delete(expression_1); delete(expression_2); }

void EIntrinCNeB::accept(Visitor *v) { v->visitEIntrinCNeB(this); }
EIntrinCNeB *EIntrinCNeB::clone() const {
  return new EIntrinCNeB(*this);
}

/********************   EIntrinCLtB    ********************/
EIntrinCLtB::EIntrinCLtB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLtB::EIntrinCLtB(const EIntrinCLtB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLtB &EIntrinCLtB::operator=(const EIntrinCLtB & other) {
  EIntrinCLtB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLtB::swap(EIntrinCLtB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLtB::~EIntrinCLtB() { delete(expression_1); delete(expression_2); }

void EIntrinCLtB::accept(Visitor *v) { v->visitEIntrinCLtB(this); }
EIntrinCLtB *EIntrinCLtB::clone() const {
  return new EIntrinCLtB(*this);
}

/********************   EIntrinCGtB    ********************/
EIntrinCGtB::EIntrinCGtB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGtB::EIntrinCGtB(const EIntrinCGtB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGtB &EIntrinCGtB::operator=(const EIntrinCGtB & other) {
  EIntrinCGtB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGtB::swap(EIntrinCGtB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGtB::~EIntrinCGtB() { delete(expression_1); delete(expression_2); }

void EIntrinCGtB::accept(Visitor *v) { v->visitEIntrinCGtB(this); }
EIntrinCGtB *EIntrinCGtB::clone() const {
  return new EIntrinCGtB(*this);
}

/********************   EIntrinCLeB    ********************/
EIntrinCLeB::EIntrinCLeB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLeB::EIntrinCLeB(const EIntrinCLeB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLeB &EIntrinCLeB::operator=(const EIntrinCLeB & other) {
  EIntrinCLeB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLeB::swap(EIntrinCLeB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLeB::~EIntrinCLeB() { delete(expression_1); delete(expression_2); }

void EIntrinCLeB::accept(Visitor *v) { v->visitEIntrinCLeB(this); }
EIntrinCLeB *EIntrinCLeB::clone() const {
  return new EIntrinCLeB(*this);
}

/********************   EIntrinCGeB    ********************/
EIntrinCGeB::EIntrinCGeB(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGeB::EIntrinCGeB(const EIntrinCGeB & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGeB &EIntrinCGeB::operator=(const EIntrinCGeB & other) {
  EIntrinCGeB tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGeB::swap(EIntrinCGeB & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGeB::~EIntrinCGeB() { delete(expression_1); delete(expression_2); }

void EIntrinCGeB::accept(Visitor *v) { v->visitEIntrinCGeB(this); }
EIntrinCGeB *EIntrinCGeB::clone() const {
  return new EIntrinCGeB(*this);
}

/********************   EIntrinAdd2B    ********************/
EIntrinAdd2B::EIntrinAdd2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd2B::EIntrinAdd2B(const EIntrinAdd2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd2B &EIntrinAdd2B::operator=(const EIntrinAdd2B & other) {
  EIntrinAdd2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd2B::swap(EIntrinAdd2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd2B::~EIntrinAdd2B() { delete(expression_1); delete(expression_2); }

void EIntrinAdd2B::accept(Visitor *v) { v->visitEIntrinAdd2B(this); }
EIntrinAdd2B *EIntrinAdd2B::clone() const {
  return new EIntrinAdd2B(*this);
}

/********************   EIntrinSub2B    ********************/
EIntrinSub2B::EIntrinSub2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub2B::EIntrinSub2B(const EIntrinSub2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub2B &EIntrinSub2B::operator=(const EIntrinSub2B & other) {
  EIntrinSub2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub2B::swap(EIntrinSub2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub2B::~EIntrinSub2B() { delete(expression_1); delete(expression_2); }

void EIntrinSub2B::accept(Visitor *v) { v->visitEIntrinSub2B(this); }
EIntrinSub2B *EIntrinSub2B::clone() const {
  return new EIntrinSub2B(*this);
}

/********************   EIntrinMul2B    ********************/
EIntrinMul2B::EIntrinMul2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul2B::EIntrinMul2B(const EIntrinMul2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul2B &EIntrinMul2B::operator=(const EIntrinMul2B & other) {
  EIntrinMul2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul2B::swap(EIntrinMul2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul2B::~EIntrinMul2B() { delete(expression_1); delete(expression_2); }

void EIntrinMul2B::accept(Visitor *v) { v->visitEIntrinMul2B(this); }
EIntrinMul2B *EIntrinMul2B::clone() const {
  return new EIntrinMul2B(*this);
}

/********************   EIntrinUdiv2B    ********************/
EIntrinUdiv2B::EIntrinUdiv2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv2B::EIntrinUdiv2B(const EIntrinUdiv2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv2B &EIntrinUdiv2B::operator=(const EIntrinUdiv2B & other) {
  EIntrinUdiv2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv2B::swap(EIntrinUdiv2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv2B::~EIntrinUdiv2B() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv2B::accept(Visitor *v) { v->visitEIntrinUdiv2B(this); }
EIntrinUdiv2B *EIntrinUdiv2B::clone() const {
  return new EIntrinUdiv2B(*this);
}

/********************   EIntrinSdiv2B    ********************/
EIntrinSdiv2B::EIntrinSdiv2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSdiv2B::EIntrinSdiv2B(const EIntrinSdiv2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdiv2B &EIntrinSdiv2B::operator=(const EIntrinSdiv2B & other) {
  EIntrinSdiv2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdiv2B::swap(EIntrinSdiv2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdiv2B::~EIntrinSdiv2B() { delete(expression_1); delete(expression_2); }

void EIntrinSdiv2B::accept(Visitor *v) { v->visitEIntrinSdiv2B(this); }
EIntrinSdiv2B *EIntrinSdiv2B::clone() const {
  return new EIntrinSdiv2B(*this);
}

/********************   EIntrinUrem2B    ********************/
EIntrinUrem2B::EIntrinUrem2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem2B::EIntrinUrem2B(const EIntrinUrem2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem2B &EIntrinUrem2B::operator=(const EIntrinUrem2B & other) {
  EIntrinUrem2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem2B::swap(EIntrinUrem2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem2B::~EIntrinUrem2B() { delete(expression_1); delete(expression_2); }

void EIntrinUrem2B::accept(Visitor *v) { v->visitEIntrinUrem2B(this); }
EIntrinUrem2B *EIntrinUrem2B::clone() const {
  return new EIntrinUrem2B(*this);
}

/********************   EIntrinSrem2B    ********************/
EIntrinSrem2B::EIntrinSrem2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSrem2B::EIntrinSrem2B(const EIntrinSrem2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSrem2B &EIntrinSrem2B::operator=(const EIntrinSrem2B & other) {
  EIntrinSrem2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSrem2B::swap(EIntrinSrem2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSrem2B::~EIntrinSrem2B() { delete(expression_1); delete(expression_2); }

void EIntrinSrem2B::accept(Visitor *v) { v->visitEIntrinSrem2B(this); }
EIntrinSrem2B *EIntrinSrem2B::clone() const {
  return new EIntrinSrem2B(*this);
}

/********************   EIntrinAnd2B    ********************/
EIntrinAnd2B::EIntrinAnd2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAnd2B::EIntrinAnd2B(const EIntrinAnd2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAnd2B &EIntrinAnd2B::operator=(const EIntrinAnd2B & other) {
  EIntrinAnd2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAnd2B::swap(EIntrinAnd2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAnd2B::~EIntrinAnd2B() { delete(expression_1); delete(expression_2); }

void EIntrinAnd2B::accept(Visitor *v) { v->visitEIntrinAnd2B(this); }
EIntrinAnd2B *EIntrinAnd2B::clone() const {
  return new EIntrinAnd2B(*this);
}

/********************   EIntrinOr2B    ********************/
EIntrinOr2B::EIntrinOr2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinOr2B::EIntrinOr2B(const EIntrinOr2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinOr2B &EIntrinOr2B::operator=(const EIntrinOr2B & other) {
  EIntrinOr2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinOr2B::swap(EIntrinOr2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinOr2B::~EIntrinOr2B() { delete(expression_1); delete(expression_2); }

void EIntrinOr2B::accept(Visitor *v) { v->visitEIntrinOr2B(this); }
EIntrinOr2B *EIntrinOr2B::clone() const {
  return new EIntrinOr2B(*this);
}

/********************   EIntrinXor2B    ********************/
EIntrinXor2B::EIntrinXor2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinXor2B::EIntrinXor2B(const EIntrinXor2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinXor2B &EIntrinXor2B::operator=(const EIntrinXor2B & other) {
  EIntrinXor2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinXor2B::swap(EIntrinXor2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinXor2B::~EIntrinXor2B() { delete(expression_1); delete(expression_2); }

void EIntrinXor2B::accept(Visitor *v) { v->visitEIntrinXor2B(this); }
EIntrinXor2B *EIntrinXor2B::clone() const {
  return new EIntrinXor2B(*this);
}

/********************   EIntrinShl2B    ********************/
EIntrinShl2B::EIntrinShl2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinShl2B::EIntrinShl2B(const EIntrinShl2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShl2B &EIntrinShl2B::operator=(const EIntrinShl2B & other) {
  EIntrinShl2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShl2B::swap(EIntrinShl2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShl2B::~EIntrinShl2B() { delete(expression_1); delete(expression_2); }

void EIntrinShl2B::accept(Visitor *v) { v->visitEIntrinShl2B(this); }
EIntrinShl2B *EIntrinShl2B::clone() const {
  return new EIntrinShl2B(*this);
}

/********************   EIntrinLshr2B    ********************/
EIntrinLshr2B::EIntrinLshr2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinLshr2B::EIntrinLshr2B(const EIntrinLshr2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshr2B &EIntrinLshr2B::operator=(const EIntrinLshr2B & other) {
  EIntrinLshr2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshr2B::swap(EIntrinLshr2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshr2B::~EIntrinLshr2B() { delete(expression_1); delete(expression_2); }

void EIntrinLshr2B::accept(Visitor *v) { v->visitEIntrinLshr2B(this); }
EIntrinLshr2B *EIntrinLshr2B::clone() const {
  return new EIntrinLshr2B(*this);
}

/********************   EIntrinAshr2B    ********************/
EIntrinAshr2B::EIntrinAshr2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAshr2B::EIntrinAshr2B(const EIntrinAshr2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshr2B &EIntrinAshr2B::operator=(const EIntrinAshr2B & other) {
  EIntrinAshr2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshr2B::swap(EIntrinAshr2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshr2B::~EIntrinAshr2B() { delete(expression_1); delete(expression_2); }

void EIntrinAshr2B::accept(Visitor *v) { v->visitEIntrinAshr2B(this); }
EIntrinAshr2B *EIntrinAshr2B::clone() const {
  return new EIntrinAshr2B(*this);
}

/********************   EIntrinNot2B    ********************/
EIntrinNot2B::EIntrinNot2B(Expression *p1) { expression_ = p1; }
EIntrinNot2B::EIntrinNot2B(const EIntrinNot2B & other) {   expression_ = other.expression_->clone();

}
EIntrinNot2B &EIntrinNot2B::operator=(const EIntrinNot2B & other) {
  EIntrinNot2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNot2B::swap(EIntrinNot2B & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNot2B::~EIntrinNot2B() { delete(expression_); }

void EIntrinNot2B::accept(Visitor *v) { v->visitEIntrinNot2B(this); }
EIntrinNot2B *EIntrinNot2B::clone() const {
  return new EIntrinNot2B(*this);
}

/********************   EIntrinNeg2B    ********************/
EIntrinNeg2B::EIntrinNeg2B(Expression *p1) { expression_ = p1; }
EIntrinNeg2B::EIntrinNeg2B(const EIntrinNeg2B & other) {   expression_ = other.expression_->clone();

}
EIntrinNeg2B &EIntrinNeg2B::operator=(const EIntrinNeg2B & other) {
  EIntrinNeg2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNeg2B::swap(EIntrinNeg2B & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNeg2B::~EIntrinNeg2B() { delete(expression_); }

void EIntrinNeg2B::accept(Visitor *v) { v->visitEIntrinNeg2B(this); }
EIntrinNeg2B *EIntrinNeg2B::clone() const {
  return new EIntrinNeg2B(*this);
}

/********************   EIntrinCEq2B    ********************/
EIntrinCEq2B::EIntrinCEq2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCEq2B::EIntrinCEq2B(const EIntrinCEq2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCEq2B &EIntrinCEq2B::operator=(const EIntrinCEq2B & other) {
  EIntrinCEq2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCEq2B::swap(EIntrinCEq2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCEq2B::~EIntrinCEq2B() { delete(expression_1); delete(expression_2); }

void EIntrinCEq2B::accept(Visitor *v) { v->visitEIntrinCEq2B(this); }
EIntrinCEq2B *EIntrinCEq2B::clone() const {
  return new EIntrinCEq2B(*this);
}

/********************   EIntrinCNe2B    ********************/
EIntrinCNe2B::EIntrinCNe2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCNe2B::EIntrinCNe2B(const EIntrinCNe2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCNe2B &EIntrinCNe2B::operator=(const EIntrinCNe2B & other) {
  EIntrinCNe2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCNe2B::swap(EIntrinCNe2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCNe2B::~EIntrinCNe2B() { delete(expression_1); delete(expression_2); }

void EIntrinCNe2B::accept(Visitor *v) { v->visitEIntrinCNe2B(this); }
EIntrinCNe2B *EIntrinCNe2B::clone() const {
  return new EIntrinCNe2B(*this);
}

/********************   EIntrinCLt2B    ********************/
EIntrinCLt2B::EIntrinCLt2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLt2B::EIntrinCLt2B(const EIntrinCLt2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLt2B &EIntrinCLt2B::operator=(const EIntrinCLt2B & other) {
  EIntrinCLt2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLt2B::swap(EIntrinCLt2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLt2B::~EIntrinCLt2B() { delete(expression_1); delete(expression_2); }

void EIntrinCLt2B::accept(Visitor *v) { v->visitEIntrinCLt2B(this); }
EIntrinCLt2B *EIntrinCLt2B::clone() const {
  return new EIntrinCLt2B(*this);
}

/********************   EIntrinCGt2B    ********************/
EIntrinCGt2B::EIntrinCGt2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGt2B::EIntrinCGt2B(const EIntrinCGt2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGt2B &EIntrinCGt2B::operator=(const EIntrinCGt2B & other) {
  EIntrinCGt2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGt2B::swap(EIntrinCGt2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGt2B::~EIntrinCGt2B() { delete(expression_1); delete(expression_2); }

void EIntrinCGt2B::accept(Visitor *v) { v->visitEIntrinCGt2B(this); }
EIntrinCGt2B *EIntrinCGt2B::clone() const {
  return new EIntrinCGt2B(*this);
}

/********************   EIntrinCLe2B    ********************/
EIntrinCLe2B::EIntrinCLe2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLe2B::EIntrinCLe2B(const EIntrinCLe2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLe2B &EIntrinCLe2B::operator=(const EIntrinCLe2B & other) {
  EIntrinCLe2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLe2B::swap(EIntrinCLe2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLe2B::~EIntrinCLe2B() { delete(expression_1); delete(expression_2); }

void EIntrinCLe2B::accept(Visitor *v) { v->visitEIntrinCLe2B(this); }
EIntrinCLe2B *EIntrinCLe2B::clone() const {
  return new EIntrinCLe2B(*this);
}

/********************   EIntrinCGe2B    ********************/
EIntrinCGe2B::EIntrinCGe2B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGe2B::EIntrinCGe2B(const EIntrinCGe2B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGe2B &EIntrinCGe2B::operator=(const EIntrinCGe2B & other) {
  EIntrinCGe2B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGe2B::swap(EIntrinCGe2B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGe2B::~EIntrinCGe2B() { delete(expression_1); delete(expression_2); }

void EIntrinCGe2B::accept(Visitor *v) { v->visitEIntrinCGe2B(this); }
EIntrinCGe2B *EIntrinCGe2B::clone() const {
  return new EIntrinCGe2B(*this);
}

/********************   EIntrinAdd4B    ********************/
EIntrinAdd4B::EIntrinAdd4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd4B::EIntrinAdd4B(const EIntrinAdd4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd4B &EIntrinAdd4B::operator=(const EIntrinAdd4B & other) {
  EIntrinAdd4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd4B::swap(EIntrinAdd4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd4B::~EIntrinAdd4B() { delete(expression_1); delete(expression_2); }

void EIntrinAdd4B::accept(Visitor *v) { v->visitEIntrinAdd4B(this); }
EIntrinAdd4B *EIntrinAdd4B::clone() const {
  return new EIntrinAdd4B(*this);
}

/********************   EIntrinSub4B    ********************/
EIntrinSub4B::EIntrinSub4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub4B::EIntrinSub4B(const EIntrinSub4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub4B &EIntrinSub4B::operator=(const EIntrinSub4B & other) {
  EIntrinSub4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub4B::swap(EIntrinSub4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub4B::~EIntrinSub4B() { delete(expression_1); delete(expression_2); }

void EIntrinSub4B::accept(Visitor *v) { v->visitEIntrinSub4B(this); }
EIntrinSub4B *EIntrinSub4B::clone() const {
  return new EIntrinSub4B(*this);
}

/********************   EIntrinMul4B    ********************/
EIntrinMul4B::EIntrinMul4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul4B::EIntrinMul4B(const EIntrinMul4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul4B &EIntrinMul4B::operator=(const EIntrinMul4B & other) {
  EIntrinMul4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul4B::swap(EIntrinMul4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul4B::~EIntrinMul4B() { delete(expression_1); delete(expression_2); }

void EIntrinMul4B::accept(Visitor *v) { v->visitEIntrinMul4B(this); }
EIntrinMul4B *EIntrinMul4B::clone() const {
  return new EIntrinMul4B(*this);
}

/********************   EIntrinUdiv4B    ********************/
EIntrinUdiv4B::EIntrinUdiv4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv4B::EIntrinUdiv4B(const EIntrinUdiv4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv4B &EIntrinUdiv4B::operator=(const EIntrinUdiv4B & other) {
  EIntrinUdiv4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv4B::swap(EIntrinUdiv4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv4B::~EIntrinUdiv4B() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv4B::accept(Visitor *v) { v->visitEIntrinUdiv4B(this); }
EIntrinUdiv4B *EIntrinUdiv4B::clone() const {
  return new EIntrinUdiv4B(*this);
}

/********************   EIntrinSdiv4B    ********************/
EIntrinSdiv4B::EIntrinSdiv4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSdiv4B::EIntrinSdiv4B(const EIntrinSdiv4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdiv4B &EIntrinSdiv4B::operator=(const EIntrinSdiv4B & other) {
  EIntrinSdiv4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdiv4B::swap(EIntrinSdiv4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdiv4B::~EIntrinSdiv4B() { delete(expression_1); delete(expression_2); }

void EIntrinSdiv4B::accept(Visitor *v) { v->visitEIntrinSdiv4B(this); }
EIntrinSdiv4B *EIntrinSdiv4B::clone() const {
  return new EIntrinSdiv4B(*this);
}

/********************   EIntrinUrem4B    ********************/
EIntrinUrem4B::EIntrinUrem4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem4B::EIntrinUrem4B(const EIntrinUrem4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem4B &EIntrinUrem4B::operator=(const EIntrinUrem4B & other) {
  EIntrinUrem4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem4B::swap(EIntrinUrem4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem4B::~EIntrinUrem4B() { delete(expression_1); delete(expression_2); }

void EIntrinUrem4B::accept(Visitor *v) { v->visitEIntrinUrem4B(this); }
EIntrinUrem4B *EIntrinUrem4B::clone() const {
  return new EIntrinUrem4B(*this);
}

/********************   EIntrinSrem4B    ********************/
EIntrinSrem4B::EIntrinSrem4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSrem4B::EIntrinSrem4B(const EIntrinSrem4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSrem4B &EIntrinSrem4B::operator=(const EIntrinSrem4B & other) {
  EIntrinSrem4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSrem4B::swap(EIntrinSrem4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSrem4B::~EIntrinSrem4B() { delete(expression_1); delete(expression_2); }

void EIntrinSrem4B::accept(Visitor *v) { v->visitEIntrinSrem4B(this); }
EIntrinSrem4B *EIntrinSrem4B::clone() const {
  return new EIntrinSrem4B(*this);
}

/********************   EIntrinAnd4B    ********************/
EIntrinAnd4B::EIntrinAnd4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAnd4B::EIntrinAnd4B(const EIntrinAnd4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAnd4B &EIntrinAnd4B::operator=(const EIntrinAnd4B & other) {
  EIntrinAnd4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAnd4B::swap(EIntrinAnd4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAnd4B::~EIntrinAnd4B() { delete(expression_1); delete(expression_2); }

void EIntrinAnd4B::accept(Visitor *v) { v->visitEIntrinAnd4B(this); }
EIntrinAnd4B *EIntrinAnd4B::clone() const {
  return new EIntrinAnd4B(*this);
}

/********************   EIntrinOr4B    ********************/
EIntrinOr4B::EIntrinOr4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinOr4B::EIntrinOr4B(const EIntrinOr4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinOr4B &EIntrinOr4B::operator=(const EIntrinOr4B & other) {
  EIntrinOr4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinOr4B::swap(EIntrinOr4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinOr4B::~EIntrinOr4B() { delete(expression_1); delete(expression_2); }

void EIntrinOr4B::accept(Visitor *v) { v->visitEIntrinOr4B(this); }
EIntrinOr4B *EIntrinOr4B::clone() const {
  return new EIntrinOr4B(*this);
}

/********************   EIntrinXor4B    ********************/
EIntrinXor4B::EIntrinXor4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinXor4B::EIntrinXor4B(const EIntrinXor4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinXor4B &EIntrinXor4B::operator=(const EIntrinXor4B & other) {
  EIntrinXor4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinXor4B::swap(EIntrinXor4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinXor4B::~EIntrinXor4B() { delete(expression_1); delete(expression_2); }

void EIntrinXor4B::accept(Visitor *v) { v->visitEIntrinXor4B(this); }
EIntrinXor4B *EIntrinXor4B::clone() const {
  return new EIntrinXor4B(*this);
}

/********************   EIntrinShl4B    ********************/
EIntrinShl4B::EIntrinShl4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinShl4B::EIntrinShl4B(const EIntrinShl4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShl4B &EIntrinShl4B::operator=(const EIntrinShl4B & other) {
  EIntrinShl4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShl4B::swap(EIntrinShl4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShl4B::~EIntrinShl4B() { delete(expression_1); delete(expression_2); }

void EIntrinShl4B::accept(Visitor *v) { v->visitEIntrinShl4B(this); }
EIntrinShl4B *EIntrinShl4B::clone() const {
  return new EIntrinShl4B(*this);
}

/********************   EIntrinLshr4B    ********************/
EIntrinLshr4B::EIntrinLshr4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinLshr4B::EIntrinLshr4B(const EIntrinLshr4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshr4B &EIntrinLshr4B::operator=(const EIntrinLshr4B & other) {
  EIntrinLshr4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshr4B::swap(EIntrinLshr4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshr4B::~EIntrinLshr4B() { delete(expression_1); delete(expression_2); }

void EIntrinLshr4B::accept(Visitor *v) { v->visitEIntrinLshr4B(this); }
EIntrinLshr4B *EIntrinLshr4B::clone() const {
  return new EIntrinLshr4B(*this);
}

/********************   EIntrinAshr4B    ********************/
EIntrinAshr4B::EIntrinAshr4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAshr4B::EIntrinAshr4B(const EIntrinAshr4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshr4B &EIntrinAshr4B::operator=(const EIntrinAshr4B & other) {
  EIntrinAshr4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshr4B::swap(EIntrinAshr4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshr4B::~EIntrinAshr4B() { delete(expression_1); delete(expression_2); }

void EIntrinAshr4B::accept(Visitor *v) { v->visitEIntrinAshr4B(this); }
EIntrinAshr4B *EIntrinAshr4B::clone() const {
  return new EIntrinAshr4B(*this);
}

/********************   EIntrinNot4B    ********************/
EIntrinNot4B::EIntrinNot4B(Expression *p1) { expression_ = p1; }
EIntrinNot4B::EIntrinNot4B(const EIntrinNot4B & other) {   expression_ = other.expression_->clone();

}
EIntrinNot4B &EIntrinNot4B::operator=(const EIntrinNot4B & other) {
  EIntrinNot4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNot4B::swap(EIntrinNot4B & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNot4B::~EIntrinNot4B() { delete(expression_); }

void EIntrinNot4B::accept(Visitor *v) { v->visitEIntrinNot4B(this); }
EIntrinNot4B *EIntrinNot4B::clone() const {
  return new EIntrinNot4B(*this);
}

/********************   EIntrinNeg4B    ********************/
EIntrinNeg4B::EIntrinNeg4B(Expression *p1) { expression_ = p1; }
EIntrinNeg4B::EIntrinNeg4B(const EIntrinNeg4B & other) {   expression_ = other.expression_->clone();

}
EIntrinNeg4B &EIntrinNeg4B::operator=(const EIntrinNeg4B & other) {
  EIntrinNeg4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNeg4B::swap(EIntrinNeg4B & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNeg4B::~EIntrinNeg4B() { delete(expression_); }

void EIntrinNeg4B::accept(Visitor *v) { v->visitEIntrinNeg4B(this); }
EIntrinNeg4B *EIntrinNeg4B::clone() const {
  return new EIntrinNeg4B(*this);
}

/********************   EIntrinCEq4B    ********************/
EIntrinCEq4B::EIntrinCEq4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCEq4B::EIntrinCEq4B(const EIntrinCEq4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCEq4B &EIntrinCEq4B::operator=(const EIntrinCEq4B & other) {
  EIntrinCEq4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCEq4B::swap(EIntrinCEq4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCEq4B::~EIntrinCEq4B() { delete(expression_1); delete(expression_2); }

void EIntrinCEq4B::accept(Visitor *v) { v->visitEIntrinCEq4B(this); }
EIntrinCEq4B *EIntrinCEq4B::clone() const {
  return new EIntrinCEq4B(*this);
}

/********************   EIntrinCNe4B    ********************/
EIntrinCNe4B::EIntrinCNe4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCNe4B::EIntrinCNe4B(const EIntrinCNe4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCNe4B &EIntrinCNe4B::operator=(const EIntrinCNe4B & other) {
  EIntrinCNe4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCNe4B::swap(EIntrinCNe4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCNe4B::~EIntrinCNe4B() { delete(expression_1); delete(expression_2); }

void EIntrinCNe4B::accept(Visitor *v) { v->visitEIntrinCNe4B(this); }
EIntrinCNe4B *EIntrinCNe4B::clone() const {
  return new EIntrinCNe4B(*this);
}

/********************   EIntrinCLt4B    ********************/
EIntrinCLt4B::EIntrinCLt4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLt4B::EIntrinCLt4B(const EIntrinCLt4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLt4B &EIntrinCLt4B::operator=(const EIntrinCLt4B & other) {
  EIntrinCLt4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLt4B::swap(EIntrinCLt4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLt4B::~EIntrinCLt4B() { delete(expression_1); delete(expression_2); }

void EIntrinCLt4B::accept(Visitor *v) { v->visitEIntrinCLt4B(this); }
EIntrinCLt4B *EIntrinCLt4B::clone() const {
  return new EIntrinCLt4B(*this);
}

/********************   EIntrinCGt4B    ********************/
EIntrinCGt4B::EIntrinCGt4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGt4B::EIntrinCGt4B(const EIntrinCGt4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGt4B &EIntrinCGt4B::operator=(const EIntrinCGt4B & other) {
  EIntrinCGt4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGt4B::swap(EIntrinCGt4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGt4B::~EIntrinCGt4B() { delete(expression_1); delete(expression_2); }

void EIntrinCGt4B::accept(Visitor *v) { v->visitEIntrinCGt4B(this); }
EIntrinCGt4B *EIntrinCGt4B::clone() const {
  return new EIntrinCGt4B(*this);
}

/********************   EIntrinCLe4B    ********************/
EIntrinCLe4B::EIntrinCLe4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLe4B::EIntrinCLe4B(const EIntrinCLe4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLe4B &EIntrinCLe4B::operator=(const EIntrinCLe4B & other) {
  EIntrinCLe4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLe4B::swap(EIntrinCLe4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLe4B::~EIntrinCLe4B() { delete(expression_1); delete(expression_2); }

void EIntrinCLe4B::accept(Visitor *v) { v->visitEIntrinCLe4B(this); }
EIntrinCLe4B *EIntrinCLe4B::clone() const {
  return new EIntrinCLe4B(*this);
}

/********************   EIntrinCGe4B    ********************/
EIntrinCGe4B::EIntrinCGe4B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGe4B::EIntrinCGe4B(const EIntrinCGe4B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGe4B &EIntrinCGe4B::operator=(const EIntrinCGe4B & other) {
  EIntrinCGe4B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGe4B::swap(EIntrinCGe4B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGe4B::~EIntrinCGe4B() { delete(expression_1); delete(expression_2); }

void EIntrinCGe4B::accept(Visitor *v) { v->visitEIntrinCGe4B(this); }
EIntrinCGe4B *EIntrinCGe4B::clone() const {
  return new EIntrinCGe4B(*this);
}

/********************   EIntrinAdd8B    ********************/
EIntrinAdd8B::EIntrinAdd8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd8B::EIntrinAdd8B(const EIntrinAdd8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd8B &EIntrinAdd8B::operator=(const EIntrinAdd8B & other) {
  EIntrinAdd8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd8B::swap(EIntrinAdd8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd8B::~EIntrinAdd8B() { delete(expression_1); delete(expression_2); }

void EIntrinAdd8B::accept(Visitor *v) { v->visitEIntrinAdd8B(this); }
EIntrinAdd8B *EIntrinAdd8B::clone() const {
  return new EIntrinAdd8B(*this);
}

/********************   EIntrinSub8B    ********************/
EIntrinSub8B::EIntrinSub8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub8B::EIntrinSub8B(const EIntrinSub8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub8B &EIntrinSub8B::operator=(const EIntrinSub8B & other) {
  EIntrinSub8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub8B::swap(EIntrinSub8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub8B::~EIntrinSub8B() { delete(expression_1); delete(expression_2); }

void EIntrinSub8B::accept(Visitor *v) { v->visitEIntrinSub8B(this); }
EIntrinSub8B *EIntrinSub8B::clone() const {
  return new EIntrinSub8B(*this);
}

/********************   EIntrinMul8B    ********************/
EIntrinMul8B::EIntrinMul8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul8B::EIntrinMul8B(const EIntrinMul8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul8B &EIntrinMul8B::operator=(const EIntrinMul8B & other) {
  EIntrinMul8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul8B::swap(EIntrinMul8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul8B::~EIntrinMul8B() { delete(expression_1); delete(expression_2); }

void EIntrinMul8B::accept(Visitor *v) { v->visitEIntrinMul8B(this); }
EIntrinMul8B *EIntrinMul8B::clone() const {
  return new EIntrinMul8B(*this);
}

/********************   EIntrinUdiv8B    ********************/
EIntrinUdiv8B::EIntrinUdiv8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv8B::EIntrinUdiv8B(const EIntrinUdiv8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv8B &EIntrinUdiv8B::operator=(const EIntrinUdiv8B & other) {
  EIntrinUdiv8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv8B::swap(EIntrinUdiv8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv8B::~EIntrinUdiv8B() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv8B::accept(Visitor *v) { v->visitEIntrinUdiv8B(this); }
EIntrinUdiv8B *EIntrinUdiv8B::clone() const {
  return new EIntrinUdiv8B(*this);
}

/********************   EIntrinSdiv8B    ********************/
EIntrinSdiv8B::EIntrinSdiv8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSdiv8B::EIntrinSdiv8B(const EIntrinSdiv8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdiv8B &EIntrinSdiv8B::operator=(const EIntrinSdiv8B & other) {
  EIntrinSdiv8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdiv8B::swap(EIntrinSdiv8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdiv8B::~EIntrinSdiv8B() { delete(expression_1); delete(expression_2); }

void EIntrinSdiv8B::accept(Visitor *v) { v->visitEIntrinSdiv8B(this); }
EIntrinSdiv8B *EIntrinSdiv8B::clone() const {
  return new EIntrinSdiv8B(*this);
}

/********************   EIntrinUrem8B    ********************/
EIntrinUrem8B::EIntrinUrem8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem8B::EIntrinUrem8B(const EIntrinUrem8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem8B &EIntrinUrem8B::operator=(const EIntrinUrem8B & other) {
  EIntrinUrem8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem8B::swap(EIntrinUrem8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem8B::~EIntrinUrem8B() { delete(expression_1); delete(expression_2); }

void EIntrinUrem8B::accept(Visitor *v) { v->visitEIntrinUrem8B(this); }
EIntrinUrem8B *EIntrinUrem8B::clone() const {
  return new EIntrinUrem8B(*this);
}

/********************   EIntrinSrem8B    ********************/
EIntrinSrem8B::EIntrinSrem8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSrem8B::EIntrinSrem8B(const EIntrinSrem8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSrem8B &EIntrinSrem8B::operator=(const EIntrinSrem8B & other) {
  EIntrinSrem8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSrem8B::swap(EIntrinSrem8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSrem8B::~EIntrinSrem8B() { delete(expression_1); delete(expression_2); }

void EIntrinSrem8B::accept(Visitor *v) { v->visitEIntrinSrem8B(this); }
EIntrinSrem8B *EIntrinSrem8B::clone() const {
  return new EIntrinSrem8B(*this);
}

/********************   EIntrinAnd8B    ********************/
EIntrinAnd8B::EIntrinAnd8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAnd8B::EIntrinAnd8B(const EIntrinAnd8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAnd8B &EIntrinAnd8B::operator=(const EIntrinAnd8B & other) {
  EIntrinAnd8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAnd8B::swap(EIntrinAnd8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAnd8B::~EIntrinAnd8B() { delete(expression_1); delete(expression_2); }

void EIntrinAnd8B::accept(Visitor *v) { v->visitEIntrinAnd8B(this); }
EIntrinAnd8B *EIntrinAnd8B::clone() const {
  return new EIntrinAnd8B(*this);
}

/********************   EIntrinOr8B    ********************/
EIntrinOr8B::EIntrinOr8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinOr8B::EIntrinOr8B(const EIntrinOr8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinOr8B &EIntrinOr8B::operator=(const EIntrinOr8B & other) {
  EIntrinOr8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinOr8B::swap(EIntrinOr8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinOr8B::~EIntrinOr8B() { delete(expression_1); delete(expression_2); }

void EIntrinOr8B::accept(Visitor *v) { v->visitEIntrinOr8B(this); }
EIntrinOr8B *EIntrinOr8B::clone() const {
  return new EIntrinOr8B(*this);
}

/********************   EIntrinXor8B    ********************/
EIntrinXor8B::EIntrinXor8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinXor8B::EIntrinXor8B(const EIntrinXor8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinXor8B &EIntrinXor8B::operator=(const EIntrinXor8B & other) {
  EIntrinXor8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinXor8B::swap(EIntrinXor8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinXor8B::~EIntrinXor8B() { delete(expression_1); delete(expression_2); }

void EIntrinXor8B::accept(Visitor *v) { v->visitEIntrinXor8B(this); }
EIntrinXor8B *EIntrinXor8B::clone() const {
  return new EIntrinXor8B(*this);
}

/********************   EIntrinShl8B    ********************/
EIntrinShl8B::EIntrinShl8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinShl8B::EIntrinShl8B(const EIntrinShl8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShl8B &EIntrinShl8B::operator=(const EIntrinShl8B & other) {
  EIntrinShl8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShl8B::swap(EIntrinShl8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShl8B::~EIntrinShl8B() { delete(expression_1); delete(expression_2); }

void EIntrinShl8B::accept(Visitor *v) { v->visitEIntrinShl8B(this); }
EIntrinShl8B *EIntrinShl8B::clone() const {
  return new EIntrinShl8B(*this);
}

/********************   EIntrinLshr8B    ********************/
EIntrinLshr8B::EIntrinLshr8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinLshr8B::EIntrinLshr8B(const EIntrinLshr8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshr8B &EIntrinLshr8B::operator=(const EIntrinLshr8B & other) {
  EIntrinLshr8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshr8B::swap(EIntrinLshr8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshr8B::~EIntrinLshr8B() { delete(expression_1); delete(expression_2); }

void EIntrinLshr8B::accept(Visitor *v) { v->visitEIntrinLshr8B(this); }
EIntrinLshr8B *EIntrinLshr8B::clone() const {
  return new EIntrinLshr8B(*this);
}

/********************   EIntrinAshr8B    ********************/
EIntrinAshr8B::EIntrinAshr8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAshr8B::EIntrinAshr8B(const EIntrinAshr8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshr8B &EIntrinAshr8B::operator=(const EIntrinAshr8B & other) {
  EIntrinAshr8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshr8B::swap(EIntrinAshr8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshr8B::~EIntrinAshr8B() { delete(expression_1); delete(expression_2); }

void EIntrinAshr8B::accept(Visitor *v) { v->visitEIntrinAshr8B(this); }
EIntrinAshr8B *EIntrinAshr8B::clone() const {
  return new EIntrinAshr8B(*this);
}

/********************   EIntrinNot8B    ********************/
EIntrinNot8B::EIntrinNot8B(Expression *p1) { expression_ = p1; }
EIntrinNot8B::EIntrinNot8B(const EIntrinNot8B & other) {   expression_ = other.expression_->clone();

}
EIntrinNot8B &EIntrinNot8B::operator=(const EIntrinNot8B & other) {
  EIntrinNot8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNot8B::swap(EIntrinNot8B & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNot8B::~EIntrinNot8B() { delete(expression_); }

void EIntrinNot8B::accept(Visitor *v) { v->visitEIntrinNot8B(this); }
EIntrinNot8B *EIntrinNot8B::clone() const {
  return new EIntrinNot8B(*this);
}

/********************   EIntrinNeg8B    ********************/
EIntrinNeg8B::EIntrinNeg8B(Expression *p1) { expression_ = p1; }
EIntrinNeg8B::EIntrinNeg8B(const EIntrinNeg8B & other) {   expression_ = other.expression_->clone();

}
EIntrinNeg8B &EIntrinNeg8B::operator=(const EIntrinNeg8B & other) {
  EIntrinNeg8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNeg8B::swap(EIntrinNeg8B & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNeg8B::~EIntrinNeg8B() { delete(expression_); }

void EIntrinNeg8B::accept(Visitor *v) { v->visitEIntrinNeg8B(this); }
EIntrinNeg8B *EIntrinNeg8B::clone() const {
  return new EIntrinNeg8B(*this);
}

/********************   EIntrinCEq8B    ********************/
EIntrinCEq8B::EIntrinCEq8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCEq8B::EIntrinCEq8B(const EIntrinCEq8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCEq8B &EIntrinCEq8B::operator=(const EIntrinCEq8B & other) {
  EIntrinCEq8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCEq8B::swap(EIntrinCEq8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCEq8B::~EIntrinCEq8B() { delete(expression_1); delete(expression_2); }

void EIntrinCEq8B::accept(Visitor *v) { v->visitEIntrinCEq8B(this); }
EIntrinCEq8B *EIntrinCEq8B::clone() const {
  return new EIntrinCEq8B(*this);
}

/********************   EIntrinCNe8B    ********************/
EIntrinCNe8B::EIntrinCNe8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCNe8B::EIntrinCNe8B(const EIntrinCNe8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCNe8B &EIntrinCNe8B::operator=(const EIntrinCNe8B & other) {
  EIntrinCNe8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCNe8B::swap(EIntrinCNe8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCNe8B::~EIntrinCNe8B() { delete(expression_1); delete(expression_2); }

void EIntrinCNe8B::accept(Visitor *v) { v->visitEIntrinCNe8B(this); }
EIntrinCNe8B *EIntrinCNe8B::clone() const {
  return new EIntrinCNe8B(*this);
}

/********************   EIntrinCLt8B    ********************/
EIntrinCLt8B::EIntrinCLt8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLt8B::EIntrinCLt8B(const EIntrinCLt8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLt8B &EIntrinCLt8B::operator=(const EIntrinCLt8B & other) {
  EIntrinCLt8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLt8B::swap(EIntrinCLt8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLt8B::~EIntrinCLt8B() { delete(expression_1); delete(expression_2); }

void EIntrinCLt8B::accept(Visitor *v) { v->visitEIntrinCLt8B(this); }
EIntrinCLt8B *EIntrinCLt8B::clone() const {
  return new EIntrinCLt8B(*this);
}

/********************   EIntrinCGt8B    ********************/
EIntrinCGt8B::EIntrinCGt8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGt8B::EIntrinCGt8B(const EIntrinCGt8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGt8B &EIntrinCGt8B::operator=(const EIntrinCGt8B & other) {
  EIntrinCGt8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGt8B::swap(EIntrinCGt8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGt8B::~EIntrinCGt8B() { delete(expression_1); delete(expression_2); }

void EIntrinCGt8B::accept(Visitor *v) { v->visitEIntrinCGt8B(this); }
EIntrinCGt8B *EIntrinCGt8B::clone() const {
  return new EIntrinCGt8B(*this);
}

/********************   EIntrinCLe8B    ********************/
EIntrinCLe8B::EIntrinCLe8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCLe8B::EIntrinCLe8B(const EIntrinCLe8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLe8B &EIntrinCLe8B::operator=(const EIntrinCLe8B & other) {
  EIntrinCLe8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLe8B::swap(EIntrinCLe8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLe8B::~EIntrinCLe8B() { delete(expression_1); delete(expression_2); }

void EIntrinCLe8B::accept(Visitor *v) { v->visitEIntrinCLe8B(this); }
EIntrinCLe8B *EIntrinCLe8B::clone() const {
  return new EIntrinCLe8B(*this);
}

/********************   EIntrinCGe8B    ********************/
EIntrinCGe8B::EIntrinCGe8B(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinCGe8B::EIntrinCGe8B(const EIntrinCGe8B & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGe8B &EIntrinCGe8B::operator=(const EIntrinCGe8B & other) {
  EIntrinCGe8B tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGe8B::swap(EIntrinCGe8B & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGe8B::~EIntrinCGe8B() { delete(expression_1); delete(expression_2); }

void EIntrinCGe8B::accept(Visitor *v) { v->visitEIntrinCGe8B(this); }
EIntrinCGe8B *EIntrinCGe8B::clone() const {
  return new EIntrinCGe8B(*this);
}

/********************   EIntrinAddB4V    ********************/
EIntrinAddB4V::EIntrinAddB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAddB4V::EIntrinAddB4V(const EIntrinAddB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAddB4V &EIntrinAddB4V::operator=(const EIntrinAddB4V & other) {
  EIntrinAddB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAddB4V::swap(EIntrinAddB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAddB4V::~EIntrinAddB4V() { delete(expression_1); delete(expression_2); }

void EIntrinAddB4V::accept(Visitor *v) { v->visitEIntrinAddB4V(this); }
EIntrinAddB4V *EIntrinAddB4V::clone() const {
  return new EIntrinAddB4V(*this);
}

/********************   EIntrinSubB4V    ********************/
EIntrinSubB4V::EIntrinSubB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSubB4V::EIntrinSubB4V(const EIntrinSubB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSubB4V &EIntrinSubB4V::operator=(const EIntrinSubB4V & other) {
  EIntrinSubB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSubB4V::swap(EIntrinSubB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSubB4V::~EIntrinSubB4V() { delete(expression_1); delete(expression_2); }

void EIntrinSubB4V::accept(Visitor *v) { v->visitEIntrinSubB4V(this); }
EIntrinSubB4V *EIntrinSubB4V::clone() const {
  return new EIntrinSubB4V(*this);
}

/********************   EIntrinMulB4V    ********************/
EIntrinMulB4V::EIntrinMulB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMulB4V::EIntrinMulB4V(const EIntrinMulB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMulB4V &EIntrinMulB4V::operator=(const EIntrinMulB4V & other) {
  EIntrinMulB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMulB4V::swap(EIntrinMulB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMulB4V::~EIntrinMulB4V() { delete(expression_1); delete(expression_2); }

void EIntrinMulB4V::accept(Visitor *v) { v->visitEIntrinMulB4V(this); }
EIntrinMulB4V *EIntrinMulB4V::clone() const {
  return new EIntrinMulB4V(*this);
}

/********************   EIntrinUdivB4V    ********************/
EIntrinUdivB4V::EIntrinUdivB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdivB4V::EIntrinUdivB4V(const EIntrinUdivB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdivB4V &EIntrinUdivB4V::operator=(const EIntrinUdivB4V & other) {
  EIntrinUdivB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdivB4V::swap(EIntrinUdivB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdivB4V::~EIntrinUdivB4V() { delete(expression_1); delete(expression_2); }

void EIntrinUdivB4V::accept(Visitor *v) { v->visitEIntrinUdivB4V(this); }
EIntrinUdivB4V *EIntrinUdivB4V::clone() const {
  return new EIntrinUdivB4V(*this);
}

/********************   EIntrinSdivB4V    ********************/
EIntrinSdivB4V::EIntrinSdivB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSdivB4V::EIntrinSdivB4V(const EIntrinSdivB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdivB4V &EIntrinSdivB4V::operator=(const EIntrinSdivB4V & other) {
  EIntrinSdivB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdivB4V::swap(EIntrinSdivB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdivB4V::~EIntrinSdivB4V() { delete(expression_1); delete(expression_2); }

void EIntrinSdivB4V::accept(Visitor *v) { v->visitEIntrinSdivB4V(this); }
EIntrinSdivB4V *EIntrinSdivB4V::clone() const {
  return new EIntrinSdivB4V(*this);
}

/********************   EIntrinUremB4V    ********************/
EIntrinUremB4V::EIntrinUremB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUremB4V::EIntrinUremB4V(const EIntrinUremB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUremB4V &EIntrinUremB4V::operator=(const EIntrinUremB4V & other) {
  EIntrinUremB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUremB4V::swap(EIntrinUremB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUremB4V::~EIntrinUremB4V() { delete(expression_1); delete(expression_2); }

void EIntrinUremB4V::accept(Visitor *v) { v->visitEIntrinUremB4V(this); }
EIntrinUremB4V *EIntrinUremB4V::clone() const {
  return new EIntrinUremB4V(*this);
}

/********************   EIntrinSremB4V    ********************/
EIntrinSremB4V::EIntrinSremB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSremB4V::EIntrinSremB4V(const EIntrinSremB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSremB4V &EIntrinSremB4V::operator=(const EIntrinSremB4V & other) {
  EIntrinSremB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSremB4V::swap(EIntrinSremB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSremB4V::~EIntrinSremB4V() { delete(expression_1); delete(expression_2); }

void EIntrinSremB4V::accept(Visitor *v) { v->visitEIntrinSremB4V(this); }
EIntrinSremB4V *EIntrinSremB4V::clone() const {
  return new EIntrinSremB4V(*this);
}

/********************   EIntrinShlB4V    ********************/
EIntrinShlB4V::EIntrinShlB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinShlB4V::EIntrinShlB4V(const EIntrinShlB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShlB4V &EIntrinShlB4V::operator=(const EIntrinShlB4V & other) {
  EIntrinShlB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShlB4V::swap(EIntrinShlB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShlB4V::~EIntrinShlB4V() { delete(expression_1); delete(expression_2); }

void EIntrinShlB4V::accept(Visitor *v) { v->visitEIntrinShlB4V(this); }
EIntrinShlB4V *EIntrinShlB4V::clone() const {
  return new EIntrinShlB4V(*this);
}

/********************   EIntrinLshrB4V    ********************/
EIntrinLshrB4V::EIntrinLshrB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinLshrB4V::EIntrinLshrB4V(const EIntrinLshrB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshrB4V &EIntrinLshrB4V::operator=(const EIntrinLshrB4V & other) {
  EIntrinLshrB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshrB4V::swap(EIntrinLshrB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshrB4V::~EIntrinLshrB4V() { delete(expression_1); delete(expression_2); }

void EIntrinLshrB4V::accept(Visitor *v) { v->visitEIntrinLshrB4V(this); }
EIntrinLshrB4V *EIntrinLshrB4V::clone() const {
  return new EIntrinLshrB4V(*this);
}

/********************   EIntrinAshrB4V    ********************/
EIntrinAshrB4V::EIntrinAshrB4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAshrB4V::EIntrinAshrB4V(const EIntrinAshrB4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshrB4V &EIntrinAshrB4V::operator=(const EIntrinAshrB4V & other) {
  EIntrinAshrB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshrB4V::swap(EIntrinAshrB4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshrB4V::~EIntrinAshrB4V() { delete(expression_1); delete(expression_2); }

void EIntrinAshrB4V::accept(Visitor *v) { v->visitEIntrinAshrB4V(this); }
EIntrinAshrB4V *EIntrinAshrB4V::clone() const {
  return new EIntrinAshrB4V(*this);
}

/********************   EIntrinNegB4V    ********************/
EIntrinNegB4V::EIntrinNegB4V(Expression *p1) { expression_ = p1; }
EIntrinNegB4V::EIntrinNegB4V(const EIntrinNegB4V & other) {   expression_ = other.expression_->clone();

}
EIntrinNegB4V &EIntrinNegB4V::operator=(const EIntrinNegB4V & other) {
  EIntrinNegB4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNegB4V::swap(EIntrinNegB4V & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNegB4V::~EIntrinNegB4V() { delete(expression_); }

void EIntrinNegB4V::accept(Visitor *v) { v->visitEIntrinNegB4V(this); }
EIntrinNegB4V *EIntrinNegB4V::clone() const {
  return new EIntrinNegB4V(*this);
}

/********************   EIntrinAddB8V    ********************/
EIntrinAddB8V::EIntrinAddB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAddB8V::EIntrinAddB8V(const EIntrinAddB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAddB8V &EIntrinAddB8V::operator=(const EIntrinAddB8V & other) {
  EIntrinAddB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAddB8V::swap(EIntrinAddB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAddB8V::~EIntrinAddB8V() { delete(expression_1); delete(expression_2); }

void EIntrinAddB8V::accept(Visitor *v) { v->visitEIntrinAddB8V(this); }
EIntrinAddB8V *EIntrinAddB8V::clone() const {
  return new EIntrinAddB8V(*this);
}

/********************   EIntrinSubB8V    ********************/
EIntrinSubB8V::EIntrinSubB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSubB8V::EIntrinSubB8V(const EIntrinSubB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSubB8V &EIntrinSubB8V::operator=(const EIntrinSubB8V & other) {
  EIntrinSubB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSubB8V::swap(EIntrinSubB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSubB8V::~EIntrinSubB8V() { delete(expression_1); delete(expression_2); }

void EIntrinSubB8V::accept(Visitor *v) { v->visitEIntrinSubB8V(this); }
EIntrinSubB8V *EIntrinSubB8V::clone() const {
  return new EIntrinSubB8V(*this);
}

/********************   EIntrinMulB8V    ********************/
EIntrinMulB8V::EIntrinMulB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMulB8V::EIntrinMulB8V(const EIntrinMulB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMulB8V &EIntrinMulB8V::operator=(const EIntrinMulB8V & other) {
  EIntrinMulB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMulB8V::swap(EIntrinMulB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMulB8V::~EIntrinMulB8V() { delete(expression_1); delete(expression_2); }

void EIntrinMulB8V::accept(Visitor *v) { v->visitEIntrinMulB8V(this); }
EIntrinMulB8V *EIntrinMulB8V::clone() const {
  return new EIntrinMulB8V(*this);
}

/********************   EIntrinUdivB8V    ********************/
EIntrinUdivB8V::EIntrinUdivB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdivB8V::EIntrinUdivB8V(const EIntrinUdivB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdivB8V &EIntrinUdivB8V::operator=(const EIntrinUdivB8V & other) {
  EIntrinUdivB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdivB8V::swap(EIntrinUdivB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdivB8V::~EIntrinUdivB8V() { delete(expression_1); delete(expression_2); }

void EIntrinUdivB8V::accept(Visitor *v) { v->visitEIntrinUdivB8V(this); }
EIntrinUdivB8V *EIntrinUdivB8V::clone() const {
  return new EIntrinUdivB8V(*this);
}

/********************   EIntrinSdivB8V    ********************/
EIntrinSdivB8V::EIntrinSdivB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSdivB8V::EIntrinSdivB8V(const EIntrinSdivB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdivB8V &EIntrinSdivB8V::operator=(const EIntrinSdivB8V & other) {
  EIntrinSdivB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdivB8V::swap(EIntrinSdivB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdivB8V::~EIntrinSdivB8V() { delete(expression_1); delete(expression_2); }

void EIntrinSdivB8V::accept(Visitor *v) { v->visitEIntrinSdivB8V(this); }
EIntrinSdivB8V *EIntrinSdivB8V::clone() const {
  return new EIntrinSdivB8V(*this);
}

/********************   EIntrinUremB8V    ********************/
EIntrinUremB8V::EIntrinUremB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUremB8V::EIntrinUremB8V(const EIntrinUremB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUremB8V &EIntrinUremB8V::operator=(const EIntrinUremB8V & other) {
  EIntrinUremB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUremB8V::swap(EIntrinUremB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUremB8V::~EIntrinUremB8V() { delete(expression_1); delete(expression_2); }

void EIntrinUremB8V::accept(Visitor *v) { v->visitEIntrinUremB8V(this); }
EIntrinUremB8V *EIntrinUremB8V::clone() const {
  return new EIntrinUremB8V(*this);
}

/********************   EIntrinSremB8V    ********************/
EIntrinSremB8V::EIntrinSremB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSremB8V::EIntrinSremB8V(const EIntrinSremB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSremB8V &EIntrinSremB8V::operator=(const EIntrinSremB8V & other) {
  EIntrinSremB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSremB8V::swap(EIntrinSremB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSremB8V::~EIntrinSremB8V() { delete(expression_1); delete(expression_2); }

void EIntrinSremB8V::accept(Visitor *v) { v->visitEIntrinSremB8V(this); }
EIntrinSremB8V *EIntrinSremB8V::clone() const {
  return new EIntrinSremB8V(*this);
}

/********************   EIntrinShlB8V    ********************/
EIntrinShlB8V::EIntrinShlB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinShlB8V::EIntrinShlB8V(const EIntrinShlB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShlB8V &EIntrinShlB8V::operator=(const EIntrinShlB8V & other) {
  EIntrinShlB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShlB8V::swap(EIntrinShlB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShlB8V::~EIntrinShlB8V() { delete(expression_1); delete(expression_2); }

void EIntrinShlB8V::accept(Visitor *v) { v->visitEIntrinShlB8V(this); }
EIntrinShlB8V *EIntrinShlB8V::clone() const {
  return new EIntrinShlB8V(*this);
}

/********************   EIntrinLshrB8V    ********************/
EIntrinLshrB8V::EIntrinLshrB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinLshrB8V::EIntrinLshrB8V(const EIntrinLshrB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshrB8V &EIntrinLshrB8V::operator=(const EIntrinLshrB8V & other) {
  EIntrinLshrB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshrB8V::swap(EIntrinLshrB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshrB8V::~EIntrinLshrB8V() { delete(expression_1); delete(expression_2); }

void EIntrinLshrB8V::accept(Visitor *v) { v->visitEIntrinLshrB8V(this); }
EIntrinLshrB8V *EIntrinLshrB8V::clone() const {
  return new EIntrinLshrB8V(*this);
}

/********************   EIntrinAshrB8V    ********************/
EIntrinAshrB8V::EIntrinAshrB8V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAshrB8V::EIntrinAshrB8V(const EIntrinAshrB8V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshrB8V &EIntrinAshrB8V::operator=(const EIntrinAshrB8V & other) {
  EIntrinAshrB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshrB8V::swap(EIntrinAshrB8V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshrB8V::~EIntrinAshrB8V() { delete(expression_1); delete(expression_2); }

void EIntrinAshrB8V::accept(Visitor *v) { v->visitEIntrinAshrB8V(this); }
EIntrinAshrB8V *EIntrinAshrB8V::clone() const {
  return new EIntrinAshrB8V(*this);
}

/********************   EIntrinNegB8V    ********************/
EIntrinNegB8V::EIntrinNegB8V(Expression *p1) { expression_ = p1; }
EIntrinNegB8V::EIntrinNegB8V(const EIntrinNegB8V & other) {   expression_ = other.expression_->clone();

}
EIntrinNegB8V &EIntrinNegB8V::operator=(const EIntrinNegB8V & other) {
  EIntrinNegB8V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNegB8V::swap(EIntrinNegB8V & other) {
  std::swap(expression_, other.expression_);

}

EIntrinNegB8V::~EIntrinNegB8V() { delete(expression_); }

void EIntrinNegB8V::accept(Visitor *v) { v->visitEIntrinNegB8V(this); }
EIntrinNegB8V *EIntrinNegB8V::clone() const {
  return new EIntrinNegB8V(*this);
}

/********************   EIntrinAdd2F    ********************/
EIntrinAdd2F::EIntrinAdd2F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd2F::EIntrinAdd2F(const EIntrinAdd2F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd2F &EIntrinAdd2F::operator=(const EIntrinAdd2F & other) {
  EIntrinAdd2F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd2F::swap(EIntrinAdd2F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd2F::~EIntrinAdd2F() { delete(expression_1); delete(expression_2); }

void EIntrinAdd2F::accept(Visitor *v) { v->visitEIntrinAdd2F(this); }
EIntrinAdd2F *EIntrinAdd2F::clone() const {
  return new EIntrinAdd2F(*this);
}

/********************   EIntrinSub2F    ********************/
EIntrinSub2F::EIntrinSub2F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub2F::EIntrinSub2F(const EIntrinSub2F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub2F &EIntrinSub2F::operator=(const EIntrinSub2F & other) {
  EIntrinSub2F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub2F::swap(EIntrinSub2F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub2F::~EIntrinSub2F() { delete(expression_1); delete(expression_2); }

void EIntrinSub2F::accept(Visitor *v) { v->visitEIntrinSub2F(this); }
EIntrinSub2F *EIntrinSub2F::clone() const {
  return new EIntrinSub2F(*this);
}

/********************   EIntrinMul2F    ********************/
EIntrinMul2F::EIntrinMul2F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul2F::EIntrinMul2F(const EIntrinMul2F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul2F &EIntrinMul2F::operator=(const EIntrinMul2F & other) {
  EIntrinMul2F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul2F::swap(EIntrinMul2F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul2F::~EIntrinMul2F() { delete(expression_1); delete(expression_2); }

void EIntrinMul2F::accept(Visitor *v) { v->visitEIntrinMul2F(this); }
EIntrinMul2F *EIntrinMul2F::clone() const {
  return new EIntrinMul2F(*this);
}

/********************   EIntrinUdiv2F    ********************/
EIntrinUdiv2F::EIntrinUdiv2F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv2F::EIntrinUdiv2F(const EIntrinUdiv2F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv2F &EIntrinUdiv2F::operator=(const EIntrinUdiv2F & other) {
  EIntrinUdiv2F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv2F::swap(EIntrinUdiv2F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv2F::~EIntrinUdiv2F() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv2F::accept(Visitor *v) { v->visitEIntrinUdiv2F(this); }
EIntrinUdiv2F *EIntrinUdiv2F::clone() const {
  return new EIntrinUdiv2F(*this);
}

/********************   EIntrinUrem2F    ********************/
EIntrinUrem2F::EIntrinUrem2F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem2F::EIntrinUrem2F(const EIntrinUrem2F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem2F &EIntrinUrem2F::operator=(const EIntrinUrem2F & other) {
  EIntrinUrem2F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem2F::swap(EIntrinUrem2F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem2F::~EIntrinUrem2F() { delete(expression_1); delete(expression_2); }

void EIntrinUrem2F::accept(Visitor *v) { v->visitEIntrinUrem2F(this); }
EIntrinUrem2F *EIntrinUrem2F::clone() const {
  return new EIntrinUrem2F(*this);
}

/********************   EIntrinAdd4F    ********************/
EIntrinAdd4F::EIntrinAdd4F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd4F::EIntrinAdd4F(const EIntrinAdd4F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd4F &EIntrinAdd4F::operator=(const EIntrinAdd4F & other) {
  EIntrinAdd4F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd4F::swap(EIntrinAdd4F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd4F::~EIntrinAdd4F() { delete(expression_1); delete(expression_2); }

void EIntrinAdd4F::accept(Visitor *v) { v->visitEIntrinAdd4F(this); }
EIntrinAdd4F *EIntrinAdd4F::clone() const {
  return new EIntrinAdd4F(*this);
}

/********************   EIntrinSub4F    ********************/
EIntrinSub4F::EIntrinSub4F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub4F::EIntrinSub4F(const EIntrinSub4F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub4F &EIntrinSub4F::operator=(const EIntrinSub4F & other) {
  EIntrinSub4F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub4F::swap(EIntrinSub4F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub4F::~EIntrinSub4F() { delete(expression_1); delete(expression_2); }

void EIntrinSub4F::accept(Visitor *v) { v->visitEIntrinSub4F(this); }
EIntrinSub4F *EIntrinSub4F::clone() const {
  return new EIntrinSub4F(*this);
}

/********************   EIntrinMul4F    ********************/
EIntrinMul4F::EIntrinMul4F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul4F::EIntrinMul4F(const EIntrinMul4F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul4F &EIntrinMul4F::operator=(const EIntrinMul4F & other) {
  EIntrinMul4F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul4F::swap(EIntrinMul4F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul4F::~EIntrinMul4F() { delete(expression_1); delete(expression_2); }

void EIntrinMul4F::accept(Visitor *v) { v->visitEIntrinMul4F(this); }
EIntrinMul4F *EIntrinMul4F::clone() const {
  return new EIntrinMul4F(*this);
}

/********************   EIntrinUdiv4F    ********************/
EIntrinUdiv4F::EIntrinUdiv4F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv4F::EIntrinUdiv4F(const EIntrinUdiv4F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv4F &EIntrinUdiv4F::operator=(const EIntrinUdiv4F & other) {
  EIntrinUdiv4F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv4F::swap(EIntrinUdiv4F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv4F::~EIntrinUdiv4F() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv4F::accept(Visitor *v) { v->visitEIntrinUdiv4F(this); }
EIntrinUdiv4F *EIntrinUdiv4F::clone() const {
  return new EIntrinUdiv4F(*this);
}

/********************   EIntrinUrem4F    ********************/
EIntrinUrem4F::EIntrinUrem4F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem4F::EIntrinUrem4F(const EIntrinUrem4F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem4F &EIntrinUrem4F::operator=(const EIntrinUrem4F & other) {
  EIntrinUrem4F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem4F::swap(EIntrinUrem4F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem4F::~EIntrinUrem4F() { delete(expression_1); delete(expression_2); }

void EIntrinUrem4F::accept(Visitor *v) { v->visitEIntrinUrem4F(this); }
EIntrinUrem4F *EIntrinUrem4F::clone() const {
  return new EIntrinUrem4F(*this);
}

/********************   EIntrinAdd8F    ********************/
EIntrinAdd8F::EIntrinAdd8F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd8F::EIntrinAdd8F(const EIntrinAdd8F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd8F &EIntrinAdd8F::operator=(const EIntrinAdd8F & other) {
  EIntrinAdd8F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd8F::swap(EIntrinAdd8F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd8F::~EIntrinAdd8F() { delete(expression_1); delete(expression_2); }

void EIntrinAdd8F::accept(Visitor *v) { v->visitEIntrinAdd8F(this); }
EIntrinAdd8F *EIntrinAdd8F::clone() const {
  return new EIntrinAdd8F(*this);
}

/********************   EIntrinSub8F    ********************/
EIntrinSub8F::EIntrinSub8F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub8F::EIntrinSub8F(const EIntrinSub8F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub8F &EIntrinSub8F::operator=(const EIntrinSub8F & other) {
  EIntrinSub8F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub8F::swap(EIntrinSub8F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub8F::~EIntrinSub8F() { delete(expression_1); delete(expression_2); }

void EIntrinSub8F::accept(Visitor *v) { v->visitEIntrinSub8F(this); }
EIntrinSub8F *EIntrinSub8F::clone() const {
  return new EIntrinSub8F(*this);
}

/********************   EIntrinMul8F    ********************/
EIntrinMul8F::EIntrinMul8F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul8F::EIntrinMul8F(const EIntrinMul8F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul8F &EIntrinMul8F::operator=(const EIntrinMul8F & other) {
  EIntrinMul8F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul8F::swap(EIntrinMul8F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul8F::~EIntrinMul8F() { delete(expression_1); delete(expression_2); }

void EIntrinMul8F::accept(Visitor *v) { v->visitEIntrinMul8F(this); }
EIntrinMul8F *EIntrinMul8F::clone() const {
  return new EIntrinMul8F(*this);
}

/********************   EIntrinUdiv8F    ********************/
EIntrinUdiv8F::EIntrinUdiv8F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv8F::EIntrinUdiv8F(const EIntrinUdiv8F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv8F &EIntrinUdiv8F::operator=(const EIntrinUdiv8F & other) {
  EIntrinUdiv8F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv8F::swap(EIntrinUdiv8F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv8F::~EIntrinUdiv8F() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv8F::accept(Visitor *v) { v->visitEIntrinUdiv8F(this); }
EIntrinUdiv8F *EIntrinUdiv8F::clone() const {
  return new EIntrinUdiv8F(*this);
}

/********************   EIntrinUrem8F    ********************/
EIntrinUrem8F::EIntrinUrem8F(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem8F::EIntrinUrem8F(const EIntrinUrem8F & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem8F &EIntrinUrem8F::operator=(const EIntrinUrem8F & other) {
  EIntrinUrem8F tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem8F::swap(EIntrinUrem8F & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem8F::~EIntrinUrem8F() { delete(expression_1); delete(expression_2); }

void EIntrinUrem8F::accept(Visitor *v) { v->visitEIntrinUrem8F(this); }
EIntrinUrem8F *EIntrinUrem8F::clone() const {
  return new EIntrinUrem8F(*this);
}

/********************   EIntrinAdd4F4V    ********************/
EIntrinAdd4F4V::EIntrinAdd4F4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinAdd4F4V::EIntrinAdd4F4V(const EIntrinAdd4F4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAdd4F4V &EIntrinAdd4F4V::operator=(const EIntrinAdd4F4V & other) {
  EIntrinAdd4F4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAdd4F4V::swap(EIntrinAdd4F4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAdd4F4V::~EIntrinAdd4F4V() { delete(expression_1); delete(expression_2); }

void EIntrinAdd4F4V::accept(Visitor *v) { v->visitEIntrinAdd4F4V(this); }
EIntrinAdd4F4V *EIntrinAdd4F4V::clone() const {
  return new EIntrinAdd4F4V(*this);
}

/********************   EIntrinSub4F4V    ********************/
EIntrinSub4F4V::EIntrinSub4F4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinSub4F4V::EIntrinSub4F4V(const EIntrinSub4F4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSub4F4V &EIntrinSub4F4V::operator=(const EIntrinSub4F4V & other) {
  EIntrinSub4F4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSub4F4V::swap(EIntrinSub4F4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSub4F4V::~EIntrinSub4F4V() { delete(expression_1); delete(expression_2); }

void EIntrinSub4F4V::accept(Visitor *v) { v->visitEIntrinSub4F4V(this); }
EIntrinSub4F4V *EIntrinSub4F4V::clone() const {
  return new EIntrinSub4F4V(*this);
}

/********************   EIntrinMul4F4V    ********************/
EIntrinMul4F4V::EIntrinMul4F4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinMul4F4V::EIntrinMul4F4V(const EIntrinMul4F4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMul4F4V &EIntrinMul4F4V::operator=(const EIntrinMul4F4V & other) {
  EIntrinMul4F4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMul4F4V::swap(EIntrinMul4F4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMul4F4V::~EIntrinMul4F4V() { delete(expression_1); delete(expression_2); }

void EIntrinMul4F4V::accept(Visitor *v) { v->visitEIntrinMul4F4V(this); }
EIntrinMul4F4V *EIntrinMul4F4V::clone() const {
  return new EIntrinMul4F4V(*this);
}

/********************   EIntrinUdiv4F4V    ********************/
EIntrinUdiv4F4V::EIntrinUdiv4F4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUdiv4F4V::EIntrinUdiv4F4V(const EIntrinUdiv4F4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdiv4F4V &EIntrinUdiv4F4V::operator=(const EIntrinUdiv4F4V & other) {
  EIntrinUdiv4F4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdiv4F4V::swap(EIntrinUdiv4F4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdiv4F4V::~EIntrinUdiv4F4V() { delete(expression_1); delete(expression_2); }

void EIntrinUdiv4F4V::accept(Visitor *v) { v->visitEIntrinUdiv4F4V(this); }
EIntrinUdiv4F4V *EIntrinUdiv4F4V::clone() const {
  return new EIntrinUdiv4F4V(*this);
}

/********************   EIntrinUrem4F4V    ********************/
EIntrinUrem4F4V::EIntrinUrem4F4V(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIntrinUrem4F4V::EIntrinUrem4F4V(const EIntrinUrem4F4V & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUrem4F4V &EIntrinUrem4F4V::operator=(const EIntrinUrem4F4V & other) {
  EIntrinUrem4F4V tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUrem4F4V::swap(EIntrinUrem4F4V & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUrem4F4V::~EIntrinUrem4F4V() { delete(expression_1); delete(expression_2); }

void EIntrinUrem4F4V::accept(Visitor *v) { v->visitEIntrinUrem4F4V(this); }
EIntrinUrem4F4V *EIntrinUrem4F4V::clone() const {
  return new EIntrinUrem4F4V(*this);
}

/********************   ELnot    ********************/
ELnot::ELnot(Expression *p1) { expression_ = p1; }
ELnot::ELnot(const ELnot & other) {   expression_ = other.expression_->clone();

}
ELnot &ELnot::operator=(const ELnot & other) {
  ELnot tmp(other);
  swap(tmp);
  return *this;
}
void ELnot::swap(ELnot & other) {
  std::swap(expression_, other.expression_);

}

ELnot::~ELnot() { delete(expression_); }

void ELnot::accept(Visitor *v) { v->visitELnot(this); }
ELnot *ELnot::clone() const {
  return new ELnot(*this);
}

/********************   EPreInc    ********************/
EPreInc::EPreInc(RValue *p1) { rvalue_ = p1; }
EPreInc::EPreInc(const EPreInc & other) {   rvalue_ = other.rvalue_->clone();

}
EPreInc &EPreInc::operator=(const EPreInc & other) {
  EPreInc tmp(other);
  swap(tmp);
  return *this;
}
void EPreInc::swap(EPreInc & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPreInc::~EPreInc() { delete(rvalue_); }

void EPreInc::accept(Visitor *v) { v->visitEPreInc(this); }
EPreInc *EPreInc::clone() const {
  return new EPreInc(*this);
}

/********************   EPreDec    ********************/
EPreDec::EPreDec(RValue *p1) { rvalue_ = p1; }
EPreDec::EPreDec(const EPreDec & other) {   rvalue_ = other.rvalue_->clone();

}
EPreDec &EPreDec::operator=(const EPreDec & other) {
  EPreDec tmp(other);
  swap(tmp);
  return *this;
}
void EPreDec::swap(EPreDec & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPreDec::~EPreDec() { delete(rvalue_); }

void EPreDec::accept(Visitor *v) { v->visitEPreDec(this); }
EPreDec *EPreDec::clone() const {
  return new EPreDec(*this);
}

/********************   ENeg    ********************/
ENeg::ENeg(Expression *p1) { expression_ = p1; }
ENeg::ENeg(const ENeg & other) {   expression_ = other.expression_->clone();

}
ENeg &ENeg::operator=(const ENeg & other) {
  ENeg tmp(other);
  swap(tmp);
  return *this;
}
void ENeg::swap(ENeg & other) {
  std::swap(expression_, other.expression_);

}

ENeg::~ENeg() { delete(expression_); }

void ENeg::accept(Visitor *v) { v->visitENeg(this); }
ENeg *ENeg::clone() const {
  return new ENeg(*this);
}

/********************   EBnot    ********************/
EBnot::EBnot(Expression *p1) { expression_ = p1; }
EBnot::EBnot(const EBnot & other) {   expression_ = other.expression_->clone();

}
EBnot &EBnot::operator=(const EBnot & other) {
  EBnot tmp(other);
  swap(tmp);
  return *this;
}
void EBnot::swap(EBnot & other) {
  std::swap(expression_, other.expression_);

}

EBnot::~EBnot() { delete(expression_); }

void EBnot::accept(Visitor *v) { v->visitEBnot(this); }
EBnot *EBnot::clone() const {
  return new EBnot(*this);
}

/********************   EPos    ********************/
EPos::EPos(Expression *p1) { expression_ = p1; }
EPos::EPos(const EPos & other) {   expression_ = other.expression_->clone();

}
EPos &EPos::operator=(const EPos & other) {
  EPos tmp(other);
  swap(tmp);
  return *this;
}
void EPos::swap(EPos & other) {
  std::swap(expression_, other.expression_);

}

EPos::~EPos() { delete(expression_); }

void EPos::accept(Visitor *v) { v->visitEPos(this); }
EPos *EPos::clone() const {
  return new EPos(*this);
}

/********************   EUnaryOperator    ********************/
EUnaryOperator::EUnaryOperator(Operator p1, Expression *p2) { operator_ = p1; expression_ = p2; }
EUnaryOperator::EUnaryOperator(const EUnaryOperator & other) {   operator_ = other.operator_;
  expression_ = other.expression_->clone();

}
EUnaryOperator &EUnaryOperator::operator=(const EUnaryOperator & other) {
  EUnaryOperator tmp(other);
  swap(tmp);
  return *this;
}
void EUnaryOperator::swap(EUnaryOperator & other) {
  std::swap(operator_, other.operator_);
  std::swap(expression_, other.expression_);

}

EUnaryOperator::~EUnaryOperator() { delete(expression_); }

void EUnaryOperator::accept(Visitor *v) { v->visitEUnaryOperator(this); }
EUnaryOperator *EUnaryOperator::clone() const {
  return new EUnaryOperator(*this);
}

/********************   EMul    ********************/
EMul::EMul(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EMul::EMul(const EMul & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EMul &EMul::operator=(const EMul & other) {
  EMul tmp(other);
  swap(tmp);
  return *this;
}
void EMul::swap(EMul & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMul::~EMul() { delete(expression_1); delete(expression_2); }

void EMul::accept(Visitor *v) { v->visitEMul(this); }
EMul *EMul::clone() const {
  return new EMul(*this);
}

/********************   EDiv    ********************/
EDiv::EDiv(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EDiv::EDiv(const EDiv & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EDiv &EDiv::operator=(const EDiv & other) {
  EDiv tmp(other);
  swap(tmp);
  return *this;
}
void EDiv::swap(EDiv & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EDiv::~EDiv() { delete(expression_1); delete(expression_2); }

void EDiv::accept(Visitor *v) { v->visitEDiv(this); }
EDiv *EDiv::clone() const {
  return new EDiv(*this);
}

/********************   EMod    ********************/
EMod::EMod(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EMod::EMod(const EMod & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EMod &EMod::operator=(const EMod & other) {
  EMod tmp(other);
  swap(tmp);
  return *this;
}
void EMod::swap(EMod & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMod::~EMod() { delete(expression_1); delete(expression_2); }

void EMod::accept(Visitor *v) { v->visitEMod(this); }
EMod *EMod::clone() const {
  return new EMod(*this);
}

/********************   EAdd    ********************/
EAdd::EAdd(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EAdd::EAdd(const EAdd & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EAdd &EAdd::operator=(const EAdd & other) {
  EAdd tmp(other);
  swap(tmp);
  return *this;
}
void EAdd::swap(EAdd & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAdd::~EAdd() { delete(expression_1); delete(expression_2); }

void EAdd::accept(Visitor *v) { v->visitEAdd(this); }
EAdd *EAdd::clone() const {
  return new EAdd(*this);
}

/********************   ESub    ********************/
ESub::ESub(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ESub::ESub(const ESub & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ESub &ESub::operator=(const ESub & other) {
  ESub tmp(other);
  swap(tmp);
  return *this;
}
void ESub::swap(ESub & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ESub::~ESub() { delete(expression_1); delete(expression_2); }

void ESub::accept(Visitor *v) { v->visitESub(this); }
ESub *ESub::clone() const {
  return new ESub(*this);
}

/********************   ELSh    ********************/
ELSh::ELSh(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELSh::ELSh(const ELSh & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELSh &ELSh::operator=(const ELSh & other) {
  ELSh tmp(other);
  swap(tmp);
  return *this;
}
void ELSh::swap(ELSh & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELSh::~ELSh() { delete(expression_1); delete(expression_2); }

void ELSh::accept(Visitor *v) { v->visitELSh(this); }
ELSh *ELSh::clone() const {
  return new ELSh(*this);
}

/********************   ERSh    ********************/
ERSh::ERSh(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ERSh::ERSh(const ERSh & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ERSh &ERSh::operator=(const ERSh & other) {
  ERSh tmp(other);
  swap(tmp);
  return *this;
}
void ERSh::swap(ERSh & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ERSh::~ERSh() { delete(expression_1); delete(expression_2); }

void ERSh::accept(Visitor *v) { v->visitERSh(this); }
ERSh *ERSh::clone() const {
  return new ERSh(*this);
}

/********************   EBinaryOperator    ********************/
EBinaryOperator::EBinaryOperator(Expression *p1, Operator p2, Expression *p3) { expression_1 = p1; operator_ = p2; expression_2 = p3; }
EBinaryOperator::EBinaryOperator(const EBinaryOperator & other) {   expression_1 = other.expression_1->clone();
  operator_ = other.operator_;
  expression_2 = other.expression_2->clone();

}
EBinaryOperator &EBinaryOperator::operator=(const EBinaryOperator & other) {
  EBinaryOperator tmp(other);
  swap(tmp);
  return *this;
}
void EBinaryOperator::swap(EBinaryOperator & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(operator_, other.operator_);
  std::swap(expression_2, other.expression_2);

}

EBinaryOperator::~EBinaryOperator() { delete(expression_1); delete(expression_2); }

void EBinaryOperator::accept(Visitor *v) { v->visitEBinaryOperator(this); }
EBinaryOperator *EBinaryOperator::clone() const {
  return new EBinaryOperator(*this);
}

/********************   ELT    ********************/
ELT::ELT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELT::ELT(const ELT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELT &ELT::operator=(const ELT & other) {
  ELT tmp(other);
  swap(tmp);
  return *this;
}
void ELT::swap(ELT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELT::~ELT() { delete(expression_1); delete(expression_2); }

void ELT::accept(Visitor *v) { v->visitELT(this); }
ELT *ELT::clone() const {
  return new ELT(*this);
}

/********************   EGT    ********************/
EGT::EGT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EGT::EGT(const EGT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EGT &EGT::operator=(const EGT & other) {
  EGT tmp(other);
  swap(tmp);
  return *this;
}
void EGT::swap(EGT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGT::~EGT() { delete(expression_1); delete(expression_2); }

void EGT::accept(Visitor *v) { v->visitEGT(this); }
EGT *EGT::clone() const {
  return new EGT(*this);
}

/********************   ELE    ********************/
ELE::ELE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELE::ELE(const ELE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELE &ELE::operator=(const ELE & other) {
  ELE tmp(other);
  swap(tmp);
  return *this;
}
void ELE::swap(ELE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELE::~ELE() { delete(expression_1); delete(expression_2); }

void ELE::accept(Visitor *v) { v->visitELE(this); }
ELE *ELE::clone() const {
  return new ELE(*this);
}

/********************   EGE    ********************/
EGE::EGE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EGE::EGE(const EGE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EGE &EGE::operator=(const EGE & other) {
  EGE tmp(other);
  swap(tmp);
  return *this;
}
void EGE::swap(EGE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGE::~EGE() { delete(expression_1); delete(expression_2); }

void EGE::accept(Visitor *v) { v->visitEGE(this); }
EGE *EGE::clone() const {
  return new EGE(*this);
}

/********************   EE    ********************/
EE::EE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EE::EE(const EE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EE &EE::operator=(const EE & other) {
  EE tmp(other);
  swap(tmp);
  return *this;
}
void EE::swap(EE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EE::~EE() { delete(expression_1); delete(expression_2); }

void EE::accept(Visitor *v) { v->visitEE(this); }
EE *EE::clone() const {
  return new EE(*this);
}

/********************   ENE    ********************/
ENE::ENE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ENE::ENE(const ENE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ENE &ENE::operator=(const ENE & other) {
  ENE tmp(other);
  swap(tmp);
  return *this;
}
void ENE::swap(ENE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ENE::~ENE() { delete(expression_1); delete(expression_2); }

void ENE::accept(Visitor *v) { v->visitENE(this); }
ENE *ENE::clone() const {
  return new ENE(*this);
}

/********************   EBand    ********************/
EBand::EBand(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBand::EBand(const EBand & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBand &EBand::operator=(const EBand & other) {
  EBand tmp(other);
  swap(tmp);
  return *this;
}
void EBand::swap(EBand & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBand::~EBand() { delete(expression_1); delete(expression_2); }

void EBand::accept(Visitor *v) { v->visitEBand(this); }
EBand *EBand::clone() const {
  return new EBand(*this);
}

/********************   EBor    ********************/
EBor::EBor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBor::EBor(const EBor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBor &EBor::operator=(const EBor & other) {
  EBor tmp(other);
  swap(tmp);
  return *this;
}
void EBor::swap(EBor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBor::~EBor() { delete(expression_1); delete(expression_2); }

void EBor::accept(Visitor *v) { v->visitEBor(this); }
EBor *EBor::clone() const {
  return new EBor(*this);
}

/********************   EBxor    ********************/
EBxor::EBxor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBxor::EBxor(const EBxor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBxor &EBxor::operator=(const EBxor & other) {
  EBxor tmp(other);
  swap(tmp);
  return *this;
}
void EBxor::swap(EBxor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBxor::~EBxor() { delete(expression_1); delete(expression_2); }

void EBxor::accept(Visitor *v) { v->visitEBxor(this); }
EBxor *EBxor::clone() const {
  return new EBxor(*this);
}

/********************   ELand    ********************/
ELand::ELand(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELand::ELand(const ELand & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELand &ELand::operator=(const ELand & other) {
  ELand tmp(other);
  swap(tmp);
  return *this;
}
void ELand::swap(ELand & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELand::~ELand() { delete(expression_1); delete(expression_2); }

void ELand::accept(Visitor *v) { v->visitELand(this); }
ELand *ELand::clone() const {
  return new ELand(*this);
}

/********************   ELor    ********************/
ELor::ELor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELor::ELor(const ELor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELor &ELor::operator=(const ELor & other) {
  ELor tmp(other);
  swap(tmp);
  return *this;
}
void ELor::swap(ELor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELor::~ELor() { delete(expression_1); delete(expression_2); }

void ELor::accept(Visitor *v) { v->visitELor(this); }
ELor *ELor::clone() const {
  return new ELor(*this);
}

/********************   ELxor    ********************/
ELxor::ELxor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELxor::ELxor(const ELxor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELxor &ELxor::operator=(const ELxor & other) {
  ELxor tmp(other);
  swap(tmp);
  return *this;
}
void ELxor::swap(ELxor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELxor::~ELxor() { delete(expression_1); delete(expression_2); }

void ELxor::accept(Visitor *v) { v->visitELxor(this); }
ELxor *ELxor::clone() const {
  return new ELxor(*this);
}

/********************   EConditional    ********************/
EConditional::EConditional(Expression *p1, Expression *p2, Expression *p3) { expression_1 = p1; expression_2 = p2; expression_3 = p3; }
EConditional::EConditional(const EConditional & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  expression_3 = other.expression_3->clone();

}
EConditional &EConditional::operator=(const EConditional & other) {
  EConditional tmp(other);
  swap(tmp);
  return *this;
}
void EConditional::swap(EConditional & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(expression_3, other.expression_3);

}

EConditional::~EConditional() { delete(expression_1); delete(expression_2); delete(expression_3); }

void EConditional::accept(Visitor *v) { v->visitEConditional(this); }
EConditional *EConditional::clone() const {
  return new EConditional(*this);
}

/********************   ETernaryOperator    ********************/
ETernaryOperator::ETernaryOperator(Expression *p1, OperatorName *p2, Expression *p3, OperatorName *p4, Expression *p5) { expression_1 = p1; operatorname_1 = p2; expression_2 = p3; operatorname_2 = p4; expression_3 = p5; }
ETernaryOperator::ETernaryOperator(const ETernaryOperator & other) {   expression_1 = other.expression_1->clone();
  operatorname_1 = other.operatorname_1->clone();
  expression_2 = other.expression_2->clone();
  operatorname_2 = other.operatorname_2->clone();
  expression_3 = other.expression_3->clone();

}
ETernaryOperator &ETernaryOperator::operator=(const ETernaryOperator & other) {
  ETernaryOperator tmp(other);
  swap(tmp);
  return *this;
}
void ETernaryOperator::swap(ETernaryOperator & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(operatorname_1, other.operatorname_1);
  std::swap(expression_2, other.expression_2);
  std::swap(operatorname_2, other.operatorname_2);
  std::swap(expression_3, other.expression_3);

}

ETernaryOperator::~ETernaryOperator() { delete(expression_1); delete(operatorname_1); delete(expression_2); delete(operatorname_2); delete(expression_3); }

void ETernaryOperator::accept(Visitor *v) { v->visitETernaryOperator(this); }
ETernaryOperator *ETernaryOperator::clone() const {
  return new ETernaryOperator(*this);
}

/********************   EAssign    ********************/
EAssign::EAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EAssign::EAssign(const EAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EAssign &EAssign::operator=(const EAssign & other) {
  EAssign tmp(other);
  swap(tmp);
  return *this;
}
void EAssign::swap(EAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EAssign::~EAssign() { delete(rvalue_); delete(expression_); }

void EAssign::accept(Visitor *v) { v->visitEAssign(this); }
EAssign *EAssign::clone() const {
  return new EAssign(*this);
}

/********************   EAddAssign    ********************/
EAddAssign::EAddAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EAddAssign::EAddAssign(const EAddAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EAddAssign &EAddAssign::operator=(const EAddAssign & other) {
  EAddAssign tmp(other);
  swap(tmp);
  return *this;
}
void EAddAssign::swap(EAddAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EAddAssign::~EAddAssign() { delete(rvalue_); delete(expression_); }

void EAddAssign::accept(Visitor *v) { v->visitEAddAssign(this); }
EAddAssign *EAddAssign::clone() const {
  return new EAddAssign(*this);
}

/********************   ESubAssign    ********************/
ESubAssign::ESubAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
ESubAssign::ESubAssign(const ESubAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
ESubAssign &ESubAssign::operator=(const ESubAssign & other) {
  ESubAssign tmp(other);
  swap(tmp);
  return *this;
}
void ESubAssign::swap(ESubAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

ESubAssign::~ESubAssign() { delete(rvalue_); delete(expression_); }

void ESubAssign::accept(Visitor *v) { v->visitESubAssign(this); }
ESubAssign *ESubAssign::clone() const {
  return new ESubAssign(*this);
}

/********************   EMulAssign    ********************/
EMulAssign::EMulAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EMulAssign::EMulAssign(const EMulAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EMulAssign &EMulAssign::operator=(const EMulAssign & other) {
  EMulAssign tmp(other);
  swap(tmp);
  return *this;
}
void EMulAssign::swap(EMulAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EMulAssign::~EMulAssign() { delete(rvalue_); delete(expression_); }

void EMulAssign::accept(Visitor *v) { v->visitEMulAssign(this); }
EMulAssign *EMulAssign::clone() const {
  return new EMulAssign(*this);
}

/********************   EDivAssign    ********************/
EDivAssign::EDivAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EDivAssign::EDivAssign(const EDivAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EDivAssign &EDivAssign::operator=(const EDivAssign & other) {
  EDivAssign tmp(other);
  swap(tmp);
  return *this;
}
void EDivAssign::swap(EDivAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EDivAssign::~EDivAssign() { delete(rvalue_); delete(expression_); }

void EDivAssign::accept(Visitor *v) { v->visitEDivAssign(this); }
EDivAssign *EDivAssign::clone() const {
  return new EDivAssign(*this);
}

/********************   EModAssign    ********************/
EModAssign::EModAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EModAssign::EModAssign(const EModAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EModAssign &EModAssign::operator=(const EModAssign & other) {
  EModAssign tmp(other);
  swap(tmp);
  return *this;
}
void EModAssign::swap(EModAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EModAssign::~EModAssign() { delete(rvalue_); delete(expression_); }

void EModAssign::accept(Visitor *v) { v->visitEModAssign(this); }
EModAssign *EModAssign::clone() const {
  return new EModAssign(*this);
}

/********************   EAndAssign    ********************/
EAndAssign::EAndAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EAndAssign::EAndAssign(const EAndAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EAndAssign &EAndAssign::operator=(const EAndAssign & other) {
  EAndAssign tmp(other);
  swap(tmp);
  return *this;
}
void EAndAssign::swap(EAndAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EAndAssign::~EAndAssign() { delete(rvalue_); delete(expression_); }

void EAndAssign::accept(Visitor *v) { v->visitEAndAssign(this); }
EAndAssign *EAndAssign::clone() const {
  return new EAndAssign(*this);
}

/********************   EOrAssign    ********************/
EOrAssign::EOrAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EOrAssign::EOrAssign(const EOrAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EOrAssign &EOrAssign::operator=(const EOrAssign & other) {
  EOrAssign tmp(other);
  swap(tmp);
  return *this;
}
void EOrAssign::swap(EOrAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EOrAssign::~EOrAssign() { delete(rvalue_); delete(expression_); }

void EOrAssign::accept(Visitor *v) { v->visitEOrAssign(this); }
EOrAssign *EOrAssign::clone() const {
  return new EOrAssign(*this);
}

/********************   EXorAssign    ********************/
EXorAssign::EXorAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EXorAssign::EXorAssign(const EXorAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EXorAssign &EXorAssign::operator=(const EXorAssign & other) {
  EXorAssign tmp(other);
  swap(tmp);
  return *this;
}
void EXorAssign::swap(EXorAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EXorAssign::~EXorAssign() { delete(rvalue_); delete(expression_); }

void EXorAssign::accept(Visitor *v) { v->visitEXorAssign(this); }
EXorAssign *EXorAssign::clone() const {
  return new EXorAssign(*this);
}

/********************   ELShAssign    ********************/
ELShAssign::ELShAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
ELShAssign::ELShAssign(const ELShAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
ELShAssign &ELShAssign::operator=(const ELShAssign & other) {
  ELShAssign tmp(other);
  swap(tmp);
  return *this;
}
void ELShAssign::swap(ELShAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

ELShAssign::~ELShAssign() { delete(rvalue_); delete(expression_); }

void ELShAssign::accept(Visitor *v) { v->visitELShAssign(this); }
ELShAssign *ELShAssign::clone() const {
  return new ELShAssign(*this);
}

/********************   ERShAssign    ********************/
ERShAssign::ERShAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
ERShAssign::ERShAssign(const ERShAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
ERShAssign &ERShAssign::operator=(const ERShAssign & other) {
  ERShAssign tmp(other);
  swap(tmp);
  return *this;
}
void ERShAssign::swap(ERShAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

ERShAssign::~ERShAssign() { delete(rvalue_); delete(expression_); }

void ERShAssign::accept(Visitor *v) { v->visitERShAssign(this); }
ERShAssign *ERShAssign::clone() const {
  return new ERShAssign(*this);
}

/********************   ListTLDeclaration    ********************/
ListTLDeclaration::ListTLDeclaration(TLDeclaration *p1, ListTLDeclaration *p2) { tldeclaration_ = p1; listtldeclaration_ = p2; }
ListTLDeclaration::ListTLDeclaration(const ListTLDeclaration & other) {   tldeclaration_ = other.tldeclaration_->clone();
  listtldeclaration_ = other.listtldeclaration_->clone();

}
ListTLDeclaration &ListTLDeclaration::operator=(const ListTLDeclaration & other) {
  ListTLDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListTLDeclaration::swap(ListTLDeclaration & other) {
  std::swap(tldeclaration_, other.tldeclaration_);
  std::swap(listtldeclaration_, other.listtldeclaration_);

}

ListTLDeclaration::~ListTLDeclaration() { delete(tldeclaration_); delete(listtldeclaration_); }
ListTLDeclaration::ListTLDeclaration(TLDeclaration *p)
{
  tldeclaration_ = p;
  listtldeclaration_= 0;
}
ListTLDeclaration* ListTLDeclaration::reverse()
{
  if (listtldeclaration_ == 0) return this;
  else
  {
    ListTLDeclaration *tmp = listtldeclaration_->reverse(this);
    listtldeclaration_ = 0;
    return tmp;
  }
}

ListTLDeclaration* ListTLDeclaration::reverse(ListTLDeclaration* prev)
{
  if (listtldeclaration_ == 0)
  {
    listtldeclaration_ = prev;
    return this;
  }
  else
  {
    ListTLDeclaration *tmp = listtldeclaration_->reverse(this);
    listtldeclaration_ = prev;
    return tmp;
  }
}


void ListTLDeclaration::accept(Visitor *v) { v->visitListTLDeclaration(this); }
ListTLDeclaration *ListTLDeclaration::clone() const {
  return new ListTLDeclaration(*this);
}

/********************   ListDeclaration    ********************/
ListDeclaration::ListDeclaration(Declaration *p1, ListDeclaration *p2) { declaration_ = p1; listdeclaration_ = p2; }
ListDeclaration::ListDeclaration(const ListDeclaration & other) {   declaration_ = other.declaration_->clone();
  listdeclaration_ = other.listdeclaration_->clone();

}
ListDeclaration &ListDeclaration::operator=(const ListDeclaration & other) {
  ListDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListDeclaration::swap(ListDeclaration & other) {
  std::swap(declaration_, other.declaration_);
  std::swap(listdeclaration_, other.listdeclaration_);

}

ListDeclaration::~ListDeclaration() { delete(declaration_); delete(listdeclaration_); }
ListDeclaration::ListDeclaration(Declaration *p)
{
  declaration_ = p;
  listdeclaration_= 0;
}
ListDeclaration* ListDeclaration::reverse()
{
  if (listdeclaration_ == 0) return this;
  else
  {
    ListDeclaration *tmp = listdeclaration_->reverse(this);
    listdeclaration_ = 0;
    return tmp;
  }
}

ListDeclaration* ListDeclaration::reverse(ListDeclaration* prev)
{
  if (listdeclaration_ == 0)
  {
    listdeclaration_ = prev;
    return this;
  }
  else
  {
    ListDeclaration *tmp = listdeclaration_->reverse(this);
    listdeclaration_ = prev;
    return tmp;
  }
}


void ListDeclaration::accept(Visitor *v) { v->visitListDeclaration(this); }
ListDeclaration *ListDeclaration::clone() const {
  return new ListDeclaration(*this);
}

/********************   ListStatement    ********************/
ListStatement::ListStatement(Statement *p1, ListStatement *p2) { statement_ = p1; liststatement_ = p2; }
ListStatement::ListStatement(const ListStatement & other) {   statement_ = other.statement_->clone();
  liststatement_ = other.liststatement_->clone();

}
ListStatement &ListStatement::operator=(const ListStatement & other) {
  ListStatement tmp(other);
  swap(tmp);
  return *this;
}
void ListStatement::swap(ListStatement & other) {
  std::swap(statement_, other.statement_);
  std::swap(liststatement_, other.liststatement_);

}

ListStatement::~ListStatement() { delete(statement_); delete(liststatement_); }
ListStatement::ListStatement(Statement *p)
{
  statement_ = p;
  liststatement_= 0;
}
ListStatement* ListStatement::reverse()
{
  if (liststatement_ == 0) return this;
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = 0;
    return tmp;
  }
}

ListStatement* ListStatement::reverse(ListStatement* prev)
{
  if (liststatement_ == 0)
  {
    liststatement_ = prev;
    return this;
  }
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = prev;
    return tmp;
  }
}


void ListStatement::accept(Visitor *v) { v->visitListStatement(this); }
ListStatement *ListStatement::clone() const {
  return new ListStatement(*this);
}

/********************   ListTypeSpecifier    ********************/
ListTypeSpecifier::ListTypeSpecifier(TypeSpecifier *p1, ListTypeSpecifier *p2) { typespecifier_ = p1; listtypespecifier_ = p2; }
ListTypeSpecifier::ListTypeSpecifier(const ListTypeSpecifier & other) {   typespecifier_ = other.typespecifier_->clone();
  listtypespecifier_ = other.listtypespecifier_->clone();

}
ListTypeSpecifier &ListTypeSpecifier::operator=(const ListTypeSpecifier & other) {
  ListTypeSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListTypeSpecifier::swap(ListTypeSpecifier & other) {
  std::swap(typespecifier_, other.typespecifier_);
  std::swap(listtypespecifier_, other.listtypespecifier_);

}

ListTypeSpecifier::~ListTypeSpecifier() { delete(typespecifier_); delete(listtypespecifier_); }
ListTypeSpecifier::ListTypeSpecifier(TypeSpecifier *p)
{
  typespecifier_ = p;
  listtypespecifier_= 0;
}
ListTypeSpecifier* ListTypeSpecifier::reverse()
{
  if (listtypespecifier_ == 0) return this;
  else
  {
    ListTypeSpecifier *tmp = listtypespecifier_->reverse(this);
    listtypespecifier_ = 0;
    return tmp;
  }
}

ListTypeSpecifier* ListTypeSpecifier::reverse(ListTypeSpecifier* prev)
{
  if (listtypespecifier_ == 0)
  {
    listtypespecifier_ = prev;
    return this;
  }
  else
  {
    ListTypeSpecifier *tmp = listtypespecifier_->reverse(this);
    listtypespecifier_ = prev;
    return tmp;
  }
}


void ListTypeSpecifier::accept(Visitor *v) { v->visitListTypeSpecifier(this); }
ListTypeSpecifier *ListTypeSpecifier::clone() const {
  return new ListTypeSpecifier(*this);
}

/********************   ListFunctionSpecifier    ********************/
ListFunctionSpecifier::ListFunctionSpecifier(FunctionSpecifier *p1, ListFunctionSpecifier *p2) { functionspecifier_ = p1; listfunctionspecifier_ = p2; }
ListFunctionSpecifier::ListFunctionSpecifier(const ListFunctionSpecifier & other) {   functionspecifier_ = other.functionspecifier_->clone();
  listfunctionspecifier_ = other.listfunctionspecifier_->clone();

}
ListFunctionSpecifier &ListFunctionSpecifier::operator=(const ListFunctionSpecifier & other) {
  ListFunctionSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListFunctionSpecifier::swap(ListFunctionSpecifier & other) {
  std::swap(functionspecifier_, other.functionspecifier_);
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);

}

ListFunctionSpecifier::~ListFunctionSpecifier() { delete(functionspecifier_); delete(listfunctionspecifier_); }
ListFunctionSpecifier::ListFunctionSpecifier(FunctionSpecifier *p)
{
  functionspecifier_ = p;
  listfunctionspecifier_= 0;
}
ListFunctionSpecifier* ListFunctionSpecifier::reverse()
{
  if (listfunctionspecifier_ == 0) return this;
  else
  {
    ListFunctionSpecifier *tmp = listfunctionspecifier_->reverse(this);
    listfunctionspecifier_ = 0;
    return tmp;
  }
}

ListFunctionSpecifier* ListFunctionSpecifier::reverse(ListFunctionSpecifier* prev)
{
  if (listfunctionspecifier_ == 0)
  {
    listfunctionspecifier_ = prev;
    return this;
  }
  else
  {
    ListFunctionSpecifier *tmp = listfunctionspecifier_->reverse(this);
    listfunctionspecifier_ = prev;
    return tmp;
  }
}


void ListFunctionSpecifier::accept(Visitor *v) { v->visitListFunctionSpecifier(this); }
ListFunctionSpecifier *ListFunctionSpecifier::clone() const {
  return new ListFunctionSpecifier(*this);
}

/********************   ListVariableSpecifier    ********************/
ListVariableSpecifier::ListVariableSpecifier(VariableSpecifier *p1, ListVariableSpecifier *p2) { variablespecifier_ = p1; listvariablespecifier_ = p2; }
ListVariableSpecifier::ListVariableSpecifier(const ListVariableSpecifier & other) {   variablespecifier_ = other.variablespecifier_->clone();
  listvariablespecifier_ = other.listvariablespecifier_->clone();

}
ListVariableSpecifier &ListVariableSpecifier::operator=(const ListVariableSpecifier & other) {
  ListVariableSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListVariableSpecifier::swap(ListVariableSpecifier & other) {
  std::swap(variablespecifier_, other.variablespecifier_);
  std::swap(listvariablespecifier_, other.listvariablespecifier_);

}

ListVariableSpecifier::~ListVariableSpecifier() { delete(variablespecifier_); delete(listvariablespecifier_); }
ListVariableSpecifier::ListVariableSpecifier(VariableSpecifier *p)
{
  variablespecifier_ = p;
  listvariablespecifier_= 0;
}
ListVariableSpecifier* ListVariableSpecifier::reverse()
{
  if (listvariablespecifier_ == 0) return this;
  else
  {
    ListVariableSpecifier *tmp = listvariablespecifier_->reverse(this);
    listvariablespecifier_ = 0;
    return tmp;
  }
}

ListVariableSpecifier* ListVariableSpecifier::reverse(ListVariableSpecifier* prev)
{
  if (listvariablespecifier_ == 0)
  {
    listvariablespecifier_ = prev;
    return this;
  }
  else
  {
    ListVariableSpecifier *tmp = listvariablespecifier_->reverse(this);
    listvariablespecifier_ = prev;
    return tmp;
  }
}


void ListVariableSpecifier::accept(Visitor *v) { v->visitListVariableSpecifier(this); }
ListVariableSpecifier *ListVariableSpecifier::clone() const {
  return new ListVariableSpecifier(*this);
}

/********************   ListStructMemberDeclaration    ********************/
ListStructMemberDeclaration::ListStructMemberDeclaration(StructMemberDeclaration *p1, ListStructMemberDeclaration *p2) { structmemberdeclaration_ = p1; liststructmemberdeclaration_ = p2; }
ListStructMemberDeclaration::ListStructMemberDeclaration(const ListStructMemberDeclaration & other) {   structmemberdeclaration_ = other.structmemberdeclaration_->clone();
  liststructmemberdeclaration_ = other.liststructmemberdeclaration_->clone();

}
ListStructMemberDeclaration &ListStructMemberDeclaration::operator=(const ListStructMemberDeclaration & other) {
  ListStructMemberDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListStructMemberDeclaration::swap(ListStructMemberDeclaration & other) {
  std::swap(structmemberdeclaration_, other.structmemberdeclaration_);
  std::swap(liststructmemberdeclaration_, other.liststructmemberdeclaration_);

}

ListStructMemberDeclaration::~ListStructMemberDeclaration() { delete(structmemberdeclaration_); delete(liststructmemberdeclaration_); }
ListStructMemberDeclaration::ListStructMemberDeclaration(StructMemberDeclaration *p)
{
  structmemberdeclaration_ = p;
  liststructmemberdeclaration_= 0;
}
ListStructMemberDeclaration* ListStructMemberDeclaration::reverse()
{
  if (liststructmemberdeclaration_ == 0) return this;
  else
  {
    ListStructMemberDeclaration *tmp = liststructmemberdeclaration_->reverse(this);
    liststructmemberdeclaration_ = 0;
    return tmp;
  }
}

ListStructMemberDeclaration* ListStructMemberDeclaration::reverse(ListStructMemberDeclaration* prev)
{
  if (liststructmemberdeclaration_ == 0)
  {
    liststructmemberdeclaration_ = prev;
    return this;
  }
  else
  {
    ListStructMemberDeclaration *tmp = liststructmemberdeclaration_->reverse(this);
    liststructmemberdeclaration_ = prev;
    return tmp;
  }
}


void ListStructMemberDeclaration::accept(Visitor *v) { v->visitListStructMemberDeclaration(this); }
ListStructMemberDeclaration *ListStructMemberDeclaration::clone() const {
  return new ListStructMemberDeclaration(*this);
}

/********************   ListGenericParam    ********************/
ListGenericParam::ListGenericParam(GenericParam *p1, ListGenericParam *p2) { genericparam_ = p1; listgenericparam_ = p2; }
ListGenericParam::ListGenericParam(const ListGenericParam & other) {   genericparam_ = other.genericparam_->clone();
  listgenericparam_ = other.listgenericparam_->clone();

}
ListGenericParam &ListGenericParam::operator=(const ListGenericParam & other) {
  ListGenericParam tmp(other);
  swap(tmp);
  return *this;
}
void ListGenericParam::swap(ListGenericParam & other) {
  std::swap(genericparam_, other.genericparam_);
  std::swap(listgenericparam_, other.listgenericparam_);

}

ListGenericParam::~ListGenericParam() { delete(genericparam_); delete(listgenericparam_); }
ListGenericParam::ListGenericParam(GenericParam *p)
{
  genericparam_ = p;
  listgenericparam_= 0;
}
ListGenericParam* ListGenericParam::reverse()
{
  if (listgenericparam_ == 0) return this;
  else
  {
    ListGenericParam *tmp = listgenericparam_->reverse(this);
    listgenericparam_ = 0;
    return tmp;
  }
}

ListGenericParam* ListGenericParam::reverse(ListGenericParam* prev)
{
  if (listgenericparam_ == 0)
  {
    listgenericparam_ = prev;
    return this;
  }
  else
  {
    ListGenericParam *tmp = listgenericparam_->reverse(this);
    listgenericparam_ = prev;
    return tmp;
  }
}


void ListGenericParam::accept(Visitor *v) { v->visitListGenericParam(this); }
ListGenericParam *ListGenericParam::clone() const {
  return new ListGenericParam(*this);
}

/********************   ListParameterDeclaration    ********************/
ListParameterDeclaration::ListParameterDeclaration(ParameterDeclaration *p1, ListParameterDeclaration *p2) { parameterdeclaration_ = p1; listparameterdeclaration_ = p2; }
ListParameterDeclaration::ListParameterDeclaration(const ListParameterDeclaration & other) {   parameterdeclaration_ = other.parameterdeclaration_->clone();
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();

}
ListParameterDeclaration &ListParameterDeclaration::operator=(const ListParameterDeclaration & other) {
  ListParameterDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListParameterDeclaration::swap(ListParameterDeclaration & other) {
  std::swap(parameterdeclaration_, other.parameterdeclaration_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);

}

ListParameterDeclaration::~ListParameterDeclaration() { delete(parameterdeclaration_); delete(listparameterdeclaration_); }
ListParameterDeclaration::ListParameterDeclaration(ParameterDeclaration *p)
{
  parameterdeclaration_ = p;
  listparameterdeclaration_= 0;
}
ListParameterDeclaration* ListParameterDeclaration::reverse()
{
  if (listparameterdeclaration_ == 0) return this;
  else
  {
    ListParameterDeclaration *tmp = listparameterdeclaration_->reverse(this);
    listparameterdeclaration_ = 0;
    return tmp;
  }
}

ListParameterDeclaration* ListParameterDeclaration::reverse(ListParameterDeclaration* prev)
{
  if (listparameterdeclaration_ == 0)
  {
    listparameterdeclaration_ = prev;
    return this;
  }
  else
  {
    ListParameterDeclaration *tmp = listparameterdeclaration_->reverse(this);
    listparameterdeclaration_ = prev;
    return tmp;
  }
}


void ListParameterDeclaration::accept(Visitor *v) { v->visitListParameterDeclaration(this); }
ListParameterDeclaration *ListParameterDeclaration::clone() const {
  return new ListParameterDeclaration(*this);
}

/********************   ListExpression    ********************/
ListExpression::ListExpression(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
ListExpression::ListExpression(const ListExpression & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
ListExpression &ListExpression::operator=(const ListExpression & other) {
  ListExpression tmp(other);
  swap(tmp);
  return *this;
}
void ListExpression::swap(ListExpression & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

ListExpression::~ListExpression() { delete(expression_); delete(listexpression_); }
ListExpression::ListExpression(Expression *p)
{
  expression_ = p;
  listexpression_= 0;
}
ListExpression* ListExpression::reverse()
{
  if (listexpression_ == 0) return this;
  else
  {
    ListExpression *tmp = listexpression_->reverse(this);
    listexpression_ = 0;
    return tmp;
  }
}

ListExpression* ListExpression::reverse(ListExpression* prev)
{
  if (listexpression_ == 0)
  {
    listexpression_ = prev;
    return this;
  }
  else
  {
    ListExpression *tmp = listexpression_->reverse(this);
    listexpression_ = prev;
    return tmp;
  }
}


void ListExpression::accept(Visitor *v) { v->visitListExpression(this); }
ListExpression *ListExpression::clone() const {
  return new ListExpression(*this);
}


