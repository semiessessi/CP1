//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include "Absyn.H"

/********************   Main    ********************/
Main::Main(ListTLDeclaration *p1, ListDeclaration *p2) { listtldeclaration_ = p1; listdeclaration_ = p2; }
Main::Main(const Main & other) {   listtldeclaration_ = other.listtldeclaration_->clone();
  listdeclaration_ = other.listdeclaration_->clone();

}
Main &Main::operator=(const Main & other) {
  Main tmp(other);
  swap(tmp);
  return *this;
}
void Main::swap(Main & other) {
  std::swap(listtldeclaration_, other.listtldeclaration_);
  std::swap(listdeclaration_, other.listdeclaration_);

}

Main::~Main() { delete(listtldeclaration_); delete(listdeclaration_); }

void Main::accept(Visitor *v) { v->visitMain(this); }
Main *Main::clone() const {
  return new Main(*this);
}

/********************   DImport    ********************/
DImport::DImport(Ident p1) { ident_ = p1; }
DImport::DImport(const DImport & other) {   ident_ = other.ident_;

}
DImport &DImport::operator=(const DImport & other) {
  DImport tmp(other);
  swap(tmp);
  return *this;
}
void DImport::swap(DImport & other) {
  std::swap(ident_, other.ident_);

}

DImport::~DImport() { }

void DImport::accept(Visitor *v) { v->visitDImport(this); }
DImport *DImport::clone() const {
  return new DImport(*this);
}

/********************   DExpose    ********************/
DExpose::DExpose(Ident p1) { ident_ = p1; }
DExpose::DExpose(const DExpose & other) {   ident_ = other.ident_;

}
DExpose &DExpose::operator=(const DExpose & other) {
  DExpose tmp(other);
  swap(tmp);
  return *this;
}
void DExpose::swap(DExpose & other) {
  std::swap(ident_, other.ident_);

}

DExpose::~DExpose() { }

void DExpose::accept(Visitor *v) { v->visitDExpose(this); }
DExpose *DExpose::clone() const {
  return new DExpose(*this);
}

/********************   DNamespace    ********************/
DNamespace::DNamespace(Ident p1, ListDeclaration *p2) { ident_ = p1; listdeclaration_ = p2; }
DNamespace::DNamespace(const DNamespace & other) {   ident_ = other.ident_;
  listdeclaration_ = other.listdeclaration_->clone();

}
DNamespace &DNamespace::operator=(const DNamespace & other) {
  DNamespace tmp(other);
  swap(tmp);
  return *this;
}
void DNamespace::swap(DNamespace & other) {
  std::swap(ident_, other.ident_);
  std::swap(listdeclaration_, other.listdeclaration_);

}

DNamespace::~DNamespace() { delete(listdeclaration_); }

void DNamespace::accept(Visitor *v) { v->visitDNamespace(this); }
DNamespace *DNamespace::clone() const {
  return new DNamespace(*this);
}

/********************   DDefaultFunction    ********************/
DDefaultFunction::DDefaultFunction(ListFunctionSpecifier *p1, Ident p2, ListParameterDeclaration *p3, ListStatement *p4) { listfunctionspecifier_ = p1; ident_ = p2; listparameterdeclaration_ = p3; liststatement_ = p4; }
DDefaultFunction::DDefaultFunction(const DDefaultFunction & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  ident_ = other.ident_;
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();
  liststatement_ = other.liststatement_->clone();

}
DDefaultFunction &DDefaultFunction::operator=(const DDefaultFunction & other) {
  DDefaultFunction tmp(other);
  swap(tmp);
  return *this;
}
void DDefaultFunction::swap(DDefaultFunction & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(ident_, other.ident_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);
  std::swap(liststatement_, other.liststatement_);

}

DDefaultFunction::~DDefaultFunction() { delete(listfunctionspecifier_); delete(listparameterdeclaration_); delete(liststatement_); }

void DDefaultFunction::accept(Visitor *v) { v->visitDDefaultFunction(this); }
DDefaultFunction *DDefaultFunction::clone() const {
  return new DDefaultFunction(*this);
}

/********************   DFunction    ********************/
DFunction::DFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4, ListStatement *p5) { listfunctionspecifier_ = p1; type_ = p2; ident_ = p3; listparameterdeclaration_ = p4; liststatement_ = p5; }
DFunction::DFunction(const DFunction & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();
  liststatement_ = other.liststatement_->clone();

}
DFunction &DFunction::operator=(const DFunction & other) {
  DFunction tmp(other);
  swap(tmp);
  return *this;
}
void DFunction::swap(DFunction & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);
  std::swap(liststatement_, other.liststatement_);

}

DFunction::~DFunction() { delete(listfunctionspecifier_); delete(type_); delete(listparameterdeclaration_); delete(liststatement_); }

void DFunction::accept(Visitor *v) { v->visitDFunction(this); }
DFunction *DFunction::clone() const {
  return new DFunction(*this);
}

/********************   DOperator    ********************/
DOperator::DOperator(ListFunctionSpecifier *p1, Type *p2, OperatorName *p3, ListParameterDeclaration *p4, ListStatement *p5) { listfunctionspecifier_ = p1; type_ = p2; operatorname_ = p3; listparameterdeclaration_ = p4; liststatement_ = p5; }
DOperator::DOperator(const DOperator & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  type_ = other.type_->clone();
  operatorname_ = other.operatorname_->clone();
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();
  liststatement_ = other.liststatement_->clone();

}
DOperator &DOperator::operator=(const DOperator & other) {
  DOperator tmp(other);
  swap(tmp);
  return *this;
}
void DOperator::swap(DOperator & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(type_, other.type_);
  std::swap(operatorname_, other.operatorname_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);
  std::swap(liststatement_, other.liststatement_);

}

DOperator::~DOperator() { delete(listfunctionspecifier_); delete(type_); delete(operatorname_); delete(listparameterdeclaration_); delete(liststatement_); }

void DOperator::accept(Visitor *v) { v->visitDOperator(this); }
DOperator *DOperator::clone() const {
  return new DOperator(*this);
}

/********************   DOperatorInfo    ********************/
DOperatorInfo::DOperatorInfo(OperatorTrait *p1) { operatortrait_ = p1; }
DOperatorInfo::DOperatorInfo(const DOperatorInfo & other) {   operatortrait_ = other.operatortrait_->clone();

}
DOperatorInfo &DOperatorInfo::operator=(const DOperatorInfo & other) {
  DOperatorInfo tmp(other);
  swap(tmp);
  return *this;
}
void DOperatorInfo::swap(DOperatorInfo & other) {
  std::swap(operatortrait_, other.operatortrait_);

}

DOperatorInfo::~DOperatorInfo() { delete(operatortrait_); }

void DOperatorInfo::accept(Visitor *v) { v->visitDOperatorInfo(this); }
DOperatorInfo *DOperatorInfo::clone() const {
  return new DOperatorInfo(*this);
}

/********************   DTypeDecl    ********************/
DTypeDecl::DTypeDecl(ListTypeSpecifier *p1, Type *p2, Ident p3) { listtypespecifier_ = p1; type_ = p2; ident_ = p3; }
DTypeDecl::DTypeDecl(const DTypeDecl & other) {   listtypespecifier_ = other.listtypespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
DTypeDecl &DTypeDecl::operator=(const DTypeDecl & other) {
  DTypeDecl tmp(other);
  swap(tmp);
  return *this;
}
void DTypeDecl::swap(DTypeDecl & other) {
  std::swap(listtypespecifier_, other.listtypespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

DTypeDecl::~DTypeDecl() { delete(listtypespecifier_); delete(type_); }

void DTypeDecl::accept(Visitor *v) { v->visitDTypeDecl(this); }
DTypeDecl *DTypeDecl::clone() const {
  return new DTypeDecl(*this);
}

/********************   DTypeConv    ********************/
DTypeConv::DTypeConv(Type *p1, ListConversionSpecifier *p2, Type *p3, Ident p4, ListStatement *p5) { type_1 = p1; listconversionspecifier_ = p2; type_2 = p3; ident_ = p4; liststatement_ = p5; }
DTypeConv::DTypeConv(const DTypeConv & other) {   type_1 = other.type_1->clone();
  listconversionspecifier_ = other.listconversionspecifier_->clone();
  type_2 = other.type_2->clone();
  ident_ = other.ident_;
  liststatement_ = other.liststatement_->clone();

}
DTypeConv &DTypeConv::operator=(const DTypeConv & other) {
  DTypeConv tmp(other);
  swap(tmp);
  return *this;
}
void DTypeConv::swap(DTypeConv & other) {
  std::swap(type_1, other.type_1);
  std::swap(listconversionspecifier_, other.listconversionspecifier_);
  std::swap(type_2, other.type_2);
  std::swap(ident_, other.ident_);
  std::swap(liststatement_, other.liststatement_);

}

DTypeConv::~DTypeConv() { delete(type_1); delete(listconversionspecifier_); delete(type_2); delete(liststatement_); }

void DTypeConv::accept(Visitor *v) { v->visitDTypeConv(this); }
DTypeConv *DTypeConv::clone() const {
  return new DTypeConv(*this);
}

/********************   DExtern    ********************/
DExtern::DExtern(Prototype *p1) { prototype_ = p1; }
DExtern::DExtern(const DExtern & other) {   prototype_ = other.prototype_->clone();

}
DExtern &DExtern::operator=(const DExtern & other) {
  DExtern tmp(other);
  swap(tmp);
  return *this;
}
void DExtern::swap(DExtern & other) {
  std::swap(prototype_, other.prototype_);

}

DExtern::~DExtern() { delete(prototype_); }

void DExtern::accept(Visitor *v) { v->visitDExtern(this); }
DExtern *DExtern::clone() const {
  return new DExtern(*this);
}

/********************   DIVariable    ********************/
DIVariable::DIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; expression_ = p4; }
DIVariable::DIVariable(const DIVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
DIVariable &DIVariable::operator=(const DIVariable & other) {
  DIVariable tmp(other);
  swap(tmp);
  return *this;
}
void DIVariable::swap(DIVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

DIVariable::~DIVariable() { delete(listvariablespecifier_); delete(type_); delete(expression_); }

void DIVariable::accept(Visitor *v) { v->visitDIVariable(this); }
DIVariable *DIVariable::clone() const {
  return new DIVariable(*this);
}

/********************   DVariable    ********************/
DVariable::DVariable(ListVariableSpecifier *p1, Type *p2, Ident p3) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; }
DVariable::DVariable(const DVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
DVariable &DVariable::operator=(const DVariable & other) {
  DVariable tmp(other);
  swap(tmp);
  return *this;
}
void DVariable::swap(DVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

DVariable::~DVariable() { delete(listvariablespecifier_); delete(type_); }

void DVariable::accept(Visitor *v) { v->visitDVariable(this); }
DVariable *DVariable::clone() const {
  return new DVariable(*this);
}

/********************   PFunction    ********************/
PFunction::PFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4) { listfunctionspecifier_ = p1; type_ = p2; ident_ = p3; listparameterdeclaration_ = p4; }
PFunction::PFunction(const PFunction & other) {   listfunctionspecifier_ = other.listfunctionspecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();

}
PFunction &PFunction::operator=(const PFunction & other) {
  PFunction tmp(other);
  swap(tmp);
  return *this;
}
void PFunction::swap(PFunction & other) {
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);

}

PFunction::~PFunction() { delete(listfunctionspecifier_); delete(type_); delete(listparameterdeclaration_); }

void PFunction::accept(Visitor *v) { v->visitPFunction(this); }
PFunction *PFunction::clone() const {
  return new PFunction(*this);
}

/********************   ONLnot    ********************/
ONLnot::ONLnot() { }
ONLnot::ONLnot(const ONLnot & other) { 
}
ONLnot &ONLnot::operator=(const ONLnot & other) {
  ONLnot tmp(other);
  swap(tmp);
  return *this;
}
void ONLnot::swap(ONLnot & other) {

}

ONLnot::~ONLnot() { }

void ONLnot::accept(Visitor *v) { v->visitONLnot(this); }
ONLnot *ONLnot::clone() const {
  return new ONLnot(*this);
}

/********************   ONPreInc    ********************/
ONPreInc::ONPreInc() { }
ONPreInc::ONPreInc(const ONPreInc & other) { 
}
ONPreInc &ONPreInc::operator=(const ONPreInc & other) {
  ONPreInc tmp(other);
  swap(tmp);
  return *this;
}
void ONPreInc::swap(ONPreInc & other) {

}

ONPreInc::~ONPreInc() { }

void ONPreInc::accept(Visitor *v) { v->visitONPreInc(this); }
ONPreInc *ONPreInc::clone() const {
  return new ONPreInc(*this);
}

/********************   ONPreDec    ********************/
ONPreDec::ONPreDec() { }
ONPreDec::ONPreDec(const ONPreDec & other) { 
}
ONPreDec &ONPreDec::operator=(const ONPreDec & other) {
  ONPreDec tmp(other);
  swap(tmp);
  return *this;
}
void ONPreDec::swap(ONPreDec & other) {

}

ONPreDec::~ONPreDec() { }

void ONPreDec::accept(Visitor *v) { v->visitONPreDec(this); }
ONPreDec *ONPreDec::clone() const {
  return new ONPreDec(*this);
}

/********************   ONBnot    ********************/
ONBnot::ONBnot() { }
ONBnot::ONBnot(const ONBnot & other) { 
}
ONBnot &ONBnot::operator=(const ONBnot & other) {
  ONBnot tmp(other);
  swap(tmp);
  return *this;
}
void ONBnot::swap(ONBnot & other) {

}

ONBnot::~ONBnot() { }

void ONBnot::accept(Visitor *v) { v->visitONBnot(this); }
ONBnot *ONBnot::clone() const {
  return new ONBnot(*this);
}

/********************   ONMul    ********************/
ONMul::ONMul() { }
ONMul::ONMul(const ONMul & other) { 
}
ONMul &ONMul::operator=(const ONMul & other) {
  ONMul tmp(other);
  swap(tmp);
  return *this;
}
void ONMul::swap(ONMul & other) {

}

ONMul::~ONMul() { }

void ONMul::accept(Visitor *v) { v->visitONMul(this); }
ONMul *ONMul::clone() const {
  return new ONMul(*this);
}

/********************   ONExp    ********************/
ONExp::ONExp() { }
ONExp::ONExp(const ONExp & other) { 
}
ONExp &ONExp::operator=(const ONExp & other) {
  ONExp tmp(other);
  swap(tmp);
  return *this;
}
void ONExp::swap(ONExp & other) {

}

ONExp::~ONExp() { }

void ONExp::accept(Visitor *v) { v->visitONExp(this); }
ONExp *ONExp::clone() const {
  return new ONExp(*this);
}

/********************   ONDiv    ********************/
ONDiv::ONDiv() { }
ONDiv::ONDiv(const ONDiv & other) { 
}
ONDiv &ONDiv::operator=(const ONDiv & other) {
  ONDiv tmp(other);
  swap(tmp);
  return *this;
}
void ONDiv::swap(ONDiv & other) {

}

ONDiv::~ONDiv() { }

void ONDiv::accept(Visitor *v) { v->visitONDiv(this); }
ONDiv *ONDiv::clone() const {
  return new ONDiv(*this);
}

/********************   ONRDiv    ********************/
ONRDiv::ONRDiv() { }
ONRDiv::ONRDiv(const ONRDiv & other) { 
}
ONRDiv &ONRDiv::operator=(const ONRDiv & other) {
  ONRDiv tmp(other);
  swap(tmp);
  return *this;
}
void ONRDiv::swap(ONRDiv & other) {

}

ONRDiv::~ONRDiv() { }

void ONRDiv::accept(Visitor *v) { v->visitONRDiv(this); }
ONRDiv *ONRDiv::clone() const {
  return new ONRDiv(*this);
}

/********************   ONMod    ********************/
ONMod::ONMod() { }
ONMod::ONMod(const ONMod & other) { 
}
ONMod &ONMod::operator=(const ONMod & other) {
  ONMod tmp(other);
  swap(tmp);
  return *this;
}
void ONMod::swap(ONMod & other) {

}

ONMod::~ONMod() { }

void ONMod::accept(Visitor *v) { v->visitONMod(this); }
ONMod *ONMod::clone() const {
  return new ONMod(*this);
}

/********************   ONAdd    ********************/
ONAdd::ONAdd() { }
ONAdd::ONAdd(const ONAdd & other) { 
}
ONAdd &ONAdd::operator=(const ONAdd & other) {
  ONAdd tmp(other);
  swap(tmp);
  return *this;
}
void ONAdd::swap(ONAdd & other) {

}

ONAdd::~ONAdd() { }

void ONAdd::accept(Visitor *v) { v->visitONAdd(this); }
ONAdd *ONAdd::clone() const {
  return new ONAdd(*this);
}

/********************   ONSub    ********************/
ONSub::ONSub() { }
ONSub::ONSub(const ONSub & other) { 
}
ONSub &ONSub::operator=(const ONSub & other) {
  ONSub tmp(other);
  swap(tmp);
  return *this;
}
void ONSub::swap(ONSub & other) {

}

ONSub::~ONSub() { }

void ONSub::accept(Visitor *v) { v->visitONSub(this); }
ONSub *ONSub::clone() const {
  return new ONSub(*this);
}

/********************   ONLSh    ********************/
ONLSh::ONLSh() { }
ONLSh::ONLSh(const ONLSh & other) { 
}
ONLSh &ONLSh::operator=(const ONLSh & other) {
  ONLSh tmp(other);
  swap(tmp);
  return *this;
}
void ONLSh::swap(ONLSh & other) {

}

ONLSh::~ONLSh() { }

void ONLSh::accept(Visitor *v) { v->visitONLSh(this); }
ONLSh *ONLSh::clone() const {
  return new ONLSh(*this);
}

/********************   ONRSh    ********************/
ONRSh::ONRSh() { }
ONRSh::ONRSh(const ONRSh & other) { 
}
ONRSh &ONRSh::operator=(const ONRSh & other) {
  ONRSh tmp(other);
  swap(tmp);
  return *this;
}
void ONRSh::swap(ONRSh & other) {

}

ONRSh::~ONRSh() { }

void ONRSh::accept(Visitor *v) { v->visitONRSh(this); }
ONRSh *ONRSh::clone() const {
  return new ONRSh(*this);
}

/********************   ONLT    ********************/
ONLT::ONLT() { }
ONLT::ONLT(const ONLT & other) { 
}
ONLT &ONLT::operator=(const ONLT & other) {
  ONLT tmp(other);
  swap(tmp);
  return *this;
}
void ONLT::swap(ONLT & other) {

}

ONLT::~ONLT() { }

void ONLT::accept(Visitor *v) { v->visitONLT(this); }
ONLT *ONLT::clone() const {
  return new ONLT(*this);
}

/********************   ONGT    ********************/
ONGT::ONGT() { }
ONGT::ONGT(const ONGT & other) { 
}
ONGT &ONGT::operator=(const ONGT & other) {
  ONGT tmp(other);
  swap(tmp);
  return *this;
}
void ONGT::swap(ONGT & other) {

}

ONGT::~ONGT() { }

void ONGT::accept(Visitor *v) { v->visitONGT(this); }
ONGT *ONGT::clone() const {
  return new ONGT(*this);
}

/********************   ONLE    ********************/
ONLE::ONLE() { }
ONLE::ONLE(const ONLE & other) { 
}
ONLE &ONLE::operator=(const ONLE & other) {
  ONLE tmp(other);
  swap(tmp);
  return *this;
}
void ONLE::swap(ONLE & other) {

}

ONLE::~ONLE() { }

void ONLE::accept(Visitor *v) { v->visitONLE(this); }
ONLE *ONLE::clone() const {
  return new ONLE(*this);
}

/********************   ONGE    ********************/
ONGE::ONGE() { }
ONGE::ONGE(const ONGE & other) { 
}
ONGE &ONGE::operator=(const ONGE & other) {
  ONGE tmp(other);
  swap(tmp);
  return *this;
}
void ONGE::swap(ONGE & other) {

}

ONGE::~ONGE() { }

void ONGE::accept(Visitor *v) { v->visitONGE(this); }
ONGE *ONGE::clone() const {
  return new ONGE(*this);
}

/********************   ONE    ********************/
ONE::ONE() { }
ONE::ONE(const ONE & other) { 
}
ONE &ONE::operator=(const ONE & other) {
  ONE tmp(other);
  swap(tmp);
  return *this;
}
void ONE::swap(ONE & other) {

}

ONE::~ONE() { }

void ONE::accept(Visitor *v) { v->visitONE(this); }
ONE *ONE::clone() const {
  return new ONE(*this);
}

/********************   ONNE    ********************/
ONNE::ONNE() { }
ONNE::ONNE(const ONNE & other) { 
}
ONNE &ONNE::operator=(const ONNE & other) {
  ONNE tmp(other);
  swap(tmp);
  return *this;
}
void ONNE::swap(ONNE & other) {

}

ONNE::~ONNE() { }

void ONNE::accept(Visitor *v) { v->visitONNE(this); }
ONNE *ONNE::clone() const {
  return new ONNE(*this);
}

/********************   ONBand    ********************/
ONBand::ONBand() { }
ONBand::ONBand(const ONBand & other) { 
}
ONBand &ONBand::operator=(const ONBand & other) {
  ONBand tmp(other);
  swap(tmp);
  return *this;
}
void ONBand::swap(ONBand & other) {

}

ONBand::~ONBand() { }

void ONBand::accept(Visitor *v) { v->visitONBand(this); }
ONBand *ONBand::clone() const {
  return new ONBand(*this);
}

/********************   ONBor    ********************/
ONBor::ONBor() { }
ONBor::ONBor(const ONBor & other) { 
}
ONBor &ONBor::operator=(const ONBor & other) {
  ONBor tmp(other);
  swap(tmp);
  return *this;
}
void ONBor::swap(ONBor & other) {

}

ONBor::~ONBor() { }

void ONBor::accept(Visitor *v) { v->visitONBor(this); }
ONBor *ONBor::clone() const {
  return new ONBor(*this);
}

/********************   ONBxor    ********************/
ONBxor::ONBxor() { }
ONBxor::ONBxor(const ONBxor & other) { 
}
ONBxor &ONBxor::operator=(const ONBxor & other) {
  ONBxor tmp(other);
  swap(tmp);
  return *this;
}
void ONBxor::swap(ONBxor & other) {

}

ONBxor::~ONBxor() { }

void ONBxor::accept(Visitor *v) { v->visitONBxor(this); }
ONBxor *ONBxor::clone() const {
  return new ONBxor(*this);
}

/********************   ONLand    ********************/
ONLand::ONLand() { }
ONLand::ONLand(const ONLand & other) { 
}
ONLand &ONLand::operator=(const ONLand & other) {
  ONLand tmp(other);
  swap(tmp);
  return *this;
}
void ONLand::swap(ONLand & other) {

}

ONLand::~ONLand() { }

void ONLand::accept(Visitor *v) { v->visitONLand(this); }
ONLand *ONLand::clone() const {
  return new ONLand(*this);
}

/********************   ONLor    ********************/
ONLor::ONLor() { }
ONLor::ONLor(const ONLor & other) { 
}
ONLor &ONLor::operator=(const ONLor & other) {
  ONLor tmp(other);
  swap(tmp);
  return *this;
}
void ONLor::swap(ONLor & other) {

}

ONLor::~ONLor() { }

void ONLor::accept(Visitor *v) { v->visitONLor(this); }
ONLor *ONLor::clone() const {
  return new ONLor(*this);
}

/********************   ONLxor    ********************/
ONLxor::ONLxor() { }
ONLxor::ONLxor(const ONLxor & other) { 
}
ONLxor &ONLxor::operator=(const ONLxor & other) {
  ONLxor tmp(other);
  swap(tmp);
  return *this;
}
void ONLxor::swap(ONLxor & other) {

}

ONLxor::~ONLxor() { }

void ONLxor::accept(Visitor *v) { v->visitONLxor(this); }
ONLxor *ONLxor::clone() const {
  return new ONLxor(*this);
}

/********************   ONRight    ********************/
ONRight::ONRight() { }
ONRight::ONRight(const ONRight & other) { 
}
ONRight &ONRight::operator=(const ONRight & other) {
  ONRight tmp(other);
  swap(tmp);
  return *this;
}
void ONRight::swap(ONRight & other) {

}

ONRight::~ONRight() { }

void ONRight::accept(Visitor *v) { v->visitONRight(this); }
ONRight *ONRight::clone() const {
  return new ONRight(*this);
}

/********************   ONLeft    ********************/
ONLeft::ONLeft() { }
ONLeft::ONLeft(const ONLeft & other) { 
}
ONLeft &ONLeft::operator=(const ONLeft & other) {
  ONLeft tmp(other);
  swap(tmp);
  return *this;
}
void ONLeft::swap(ONLeft & other) {

}

ONLeft::~ONLeft() { }

void ONLeft::accept(Visitor *v) { v->visitONLeft(this); }
ONLeft *ONLeft::clone() const {
  return new ONLeft(*this);
}

/********************   OTIdentity    ********************/
OTIdentity::OTIdentity(Type *p1, OperatorName *p2, Expression *p3) { type_ = p1; operatorname_ = p2; expression_ = p3; }
OTIdentity::OTIdentity(const OTIdentity & other) {   type_ = other.type_->clone();
  operatorname_ = other.operatorname_->clone();
  expression_ = other.expression_->clone();

}
OTIdentity &OTIdentity::operator=(const OTIdentity & other) {
  OTIdentity tmp(other);
  swap(tmp);
  return *this;
}
void OTIdentity::swap(OTIdentity & other) {
  std::swap(type_, other.type_);
  std::swap(operatorname_, other.operatorname_);
  std::swap(expression_, other.expression_);

}

OTIdentity::~OTIdentity() { delete(type_); delete(operatorname_); delete(expression_); }

void OTIdentity::accept(Visitor *v) { v->visitOTIdentity(this); }
OTIdentity *OTIdentity::clone() const {
  return new OTIdentity(*this);
}

/********************   FSEntryPoint    ********************/
FSEntryPoint::FSEntryPoint() { }
FSEntryPoint::FSEntryPoint(const FSEntryPoint & other) { 
}
FSEntryPoint &FSEntryPoint::operator=(const FSEntryPoint & other) {
  FSEntryPoint tmp(other);
  swap(tmp);
  return *this;
}
void FSEntryPoint::swap(FSEntryPoint & other) {

}

FSEntryPoint::~FSEntryPoint() { }

void FSEntryPoint::accept(Visitor *v) { v->visitFSEntryPoint(this); }
FSEntryPoint *FSEntryPoint::clone() const {
  return new FSEntryPoint(*this);
}

/********************   FSPure    ********************/
FSPure::FSPure() { }
FSPure::FSPure(const FSPure & other) { 
}
FSPure &FSPure::operator=(const FSPure & other) {
  FSPure tmp(other);
  swap(tmp);
  return *this;
}
void FSPure::swap(FSPure & other) {

}

FSPure::~FSPure() { }

void FSPure::accept(Visitor *v) { v->visitFSPure(this); }
FSPure *FSPure::clone() const {
  return new FSPure(*this);
}

/********************   FSInline    ********************/
FSInline::FSInline() { }
FSInline::FSInline(const FSInline & other) { 
}
FSInline &FSInline::operator=(const FSInline & other) {
  FSInline tmp(other);
  swap(tmp);
  return *this;
}
void FSInline::swap(FSInline & other) {

}

FSInline::~FSInline() { }

void FSInline::accept(Visitor *v) { v->visitFSInline(this); }
FSInline *FSInline::clone() const {
  return new FSInline(*this);
}

/********************   FSAssociative    ********************/
FSAssociative::FSAssociative() { }
FSAssociative::FSAssociative(const FSAssociative & other) { 
}
FSAssociative &FSAssociative::operator=(const FSAssociative & other) {
  FSAssociative tmp(other);
  swap(tmp);
  return *this;
}
void FSAssociative::swap(FSAssociative & other) {

}

FSAssociative::~FSAssociative() { }

void FSAssociative::accept(Visitor *v) { v->visitFSAssociative(this); }
FSAssociative *FSAssociative::clone() const {
  return new FSAssociative(*this);
}

/********************   FSCommutative    ********************/
FSCommutative::FSCommutative() { }
FSCommutative::FSCommutative(const FSCommutative & other) { 
}
FSCommutative &FSCommutative::operator=(const FSCommutative & other) {
  FSCommutative tmp(other);
  swap(tmp);
  return *this;
}
void FSCommutative::swap(FSCommutative & other) {

}

FSCommutative::~FSCommutative() { }

void FSCommutative::accept(Visitor *v) { v->visitFSCommutative(this); }
FSCommutative *FSCommutative::clone() const {
  return new FSCommutative(*this);
}

/********************   FSAntiCommutative    ********************/
FSAntiCommutative::FSAntiCommutative() { }
FSAntiCommutative::FSAntiCommutative(const FSAntiCommutative & other) { 
}
FSAntiCommutative &FSAntiCommutative::operator=(const FSAntiCommutative & other) {
  FSAntiCommutative tmp(other);
  swap(tmp);
  return *this;
}
void FSAntiCommutative::swap(FSAntiCommutative & other) {

}

FSAntiCommutative::~FSAntiCommutative() { }

void FSAntiCommutative::accept(Visitor *v) { v->visitFSAntiCommutative(this); }
FSAntiCommutative *FSAntiCommutative::clone() const {
  return new FSAntiCommutative(*this);
}

/********************   FSInverse    ********************/
FSInverse::FSInverse(OperatorName *p1) { operatorname_ = p1; }
FSInverse::FSInverse(const FSInverse & other) {   operatorname_ = other.operatorname_->clone();

}
FSInverse &FSInverse::operator=(const FSInverse & other) {
  FSInverse tmp(other);
  swap(tmp);
  return *this;
}
void FSInverse::swap(FSInverse & other) {
  std::swap(operatorname_, other.operatorname_);

}

FSInverse::~FSInverse() { delete(operatorname_); }

void FSInverse::accept(Visitor *v) { v->visitFSInverse(this); }
FSInverse *FSInverse::clone() const {
  return new FSInverse(*this);
}

/********************   FSSelfInverse    ********************/
FSSelfInverse::FSSelfInverse() { }
FSSelfInverse::FSSelfInverse(const FSSelfInverse & other) { 
}
FSSelfInverse &FSSelfInverse::operator=(const FSSelfInverse & other) {
  FSSelfInverse tmp(other);
  swap(tmp);
  return *this;
}
void FSSelfInverse::swap(FSSelfInverse & other) {

}

FSSelfInverse::~FSSelfInverse() { }

void FSSelfInverse::accept(Visitor *v) { v->visitFSSelfInverse(this); }
FSSelfInverse *FSSelfInverse::clone() const {
  return new FSSelfInverse(*this);
}

/********************   CSUp    ********************/
CSUp::CSUp() { }
CSUp::CSUp(const CSUp & other) { 
}
CSUp &CSUp::operator=(const CSUp & other) {
  CSUp tmp(other);
  swap(tmp);
  return *this;
}
void CSUp::swap(CSUp & other) {

}

CSUp::~CSUp() { }

void CSUp::accept(Visitor *v) { v->visitCSUp(this); }
CSUp *CSUp::clone() const {
  return new CSUp(*this);
}

/********************   CSDown    ********************/
CSDown::CSDown() { }
CSDown::CSDown(const CSDown & other) { 
}
CSDown &CSDown::operator=(const CSDown & other) {
  CSDown tmp(other);
  swap(tmp);
  return *this;
}
void CSDown::swap(CSDown & other) {

}

CSDown::~CSDown() { }

void CSDown::accept(Visitor *v) { v->visitCSDown(this); }
CSDown *CSDown::clone() const {
  return new CSDown(*this);
}

/********************   CSImplicit    ********************/
CSImplicit::CSImplicit() { }
CSImplicit::CSImplicit(const CSImplicit & other) { 
}
CSImplicit &CSImplicit::operator=(const CSImplicit & other) {
  CSImplicit tmp(other);
  swap(tmp);
  return *this;
}
void CSImplicit::swap(CSImplicit & other) {

}

CSImplicit::~CSImplicit() { }

void CSImplicit::accept(Visitor *v) { v->visitCSImplicit(this); }
CSImplicit *CSImplicit::clone() const {
  return new CSImplicit(*this);
}

/********************   VSConst    ********************/
VSConst::VSConst() { }
VSConst::VSConst(const VSConst & other) { 
}
VSConst &VSConst::operator=(const VSConst & other) {
  VSConst tmp(other);
  swap(tmp);
  return *this;
}
void VSConst::swap(VSConst & other) {

}

VSConst::~VSConst() { }

void VSConst::accept(Visitor *v) { v->visitVSConst(this); }
VSConst *VSConst::clone() const {
  return new VSConst(*this);
}

/********************   TSAlign    ********************/
TSAlign::TSAlign(Integer p1) { integer_ = p1; }
TSAlign::TSAlign(const TSAlign & other) {   integer_ = other.integer_;

}
TSAlign &TSAlign::operator=(const TSAlign & other) {
  TSAlign tmp(other);
  swap(tmp);
  return *this;
}
void TSAlign::swap(TSAlign & other) {
  std::swap(integer_, other.integer_);

}

TSAlign::~TSAlign() { }

void TSAlign::accept(Visitor *v) { v->visitTSAlign(this); }
TSAlign *TSAlign::clone() const {
  return new TSAlign(*this);
}

/********************   TSGeneric    ********************/
TSGeneric::TSGeneric(ListGenericParam *p1) { listgenericparam_ = p1; }
TSGeneric::TSGeneric(const TSGeneric & other) {   listgenericparam_ = other.listgenericparam_->clone();

}
TSGeneric &TSGeneric::operator=(const TSGeneric & other) {
  TSGeneric tmp(other);
  swap(tmp);
  return *this;
}
void TSGeneric::swap(TSGeneric & other) {
  std::swap(listgenericparam_, other.listgenericparam_);

}

TSGeneric::~TSGeneric() { delete(listgenericparam_); }

void TSGeneric::accept(Visitor *v) { v->visitTSGeneric(this); }
TSGeneric *TSGeneric::clone() const {
  return new TSGeneric(*this);
}

/********************   TSInteger    ********************/
TSInteger::TSInteger() { }
TSInteger::TSInteger(const TSInteger & other) { 
}
TSInteger &TSInteger::operator=(const TSInteger & other) {
  TSInteger tmp(other);
  swap(tmp);
  return *this;
}
void TSInteger::swap(TSInteger & other) {

}

TSInteger::~TSInteger() { }

void TSInteger::accept(Visitor *v) { v->visitTSInteger(this); }
TSInteger *TSInteger::clone() const {
  return new TSInteger(*this);
}

/********************   TSReal    ********************/
TSReal::TSReal() { }
TSReal::TSReal(const TSReal & other) { 
}
TSReal &TSReal::operator=(const TSReal & other) {
  TSReal tmp(other);
  swap(tmp);
  return *this;
}
void TSReal::swap(TSReal & other) {

}

TSReal::~TSReal() { }

void TSReal::accept(Visitor *v) { v->visitTSReal(this); }
TSReal *TSReal::clone() const {
  return new TSReal(*this);
}

/********************   TSGParam    ********************/
TSGParam::TSGParam(Type *p1, Ident p2) { type_ = p1; ident_ = p2; }
TSGParam::TSGParam(const TSGParam & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;

}
TSGParam &TSGParam::operator=(const TSGParam & other) {
  TSGParam tmp(other);
  swap(tmp);
  return *this;
}
void TSGParam::swap(TSGParam & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

TSGParam::~TSGParam() { delete(type_); }

void TSGParam::accept(Visitor *v) { v->visitTSGParam(this); }
TSGParam *TSGParam::clone() const {
  return new TSGParam(*this);
}

/********************   TAddress    ********************/
TAddress::TAddress() { }
TAddress::TAddress(const TAddress & other) { 
}
TAddress &TAddress::operator=(const TAddress & other) {
  TAddress tmp(other);
  swap(tmp);
  return *this;
}
void TAddress::swap(TAddress & other) {

}

TAddress::~TAddress() { }

void TAddress::accept(Visitor *v) { v->visitTAddress(this); }
TAddress *TAddress::clone() const {
  return new TAddress(*this);
}

/********************   TByte    ********************/
TByte::TByte() { }
TByte::TByte(const TByte & other) { 
}
TByte &TByte::operator=(const TByte & other) {
  TByte tmp(other);
  swap(tmp);
  return *this;
}
void TByte::swap(TByte & other) {

}

TByte::~TByte() { }

void TByte::accept(Visitor *v) { v->visitTByte(this); }
TByte *TByte::clone() const {
  return new TByte(*this);
}

/********************   TCustom    ********************/
TCustom::TCustom(Ident p1) { ident_ = p1; }
TCustom::TCustom(const TCustom & other) {   ident_ = other.ident_;

}
TCustom &TCustom::operator=(const TCustom & other) {
  TCustom tmp(other);
  swap(tmp);
  return *this;
}
void TCustom::swap(TCustom & other) {
  std::swap(ident_, other.ident_);

}

TCustom::~TCustom() { }

void TCustom::accept(Visitor *v) { v->visitTCustom(this); }
TCustom *TCustom::clone() const {
  return new TCustom(*this);
}

/********************   TFixedArray    ********************/
TFixedArray::TFixedArray(Type *p1, Integer p2) { type_ = p1; integer_ = p2; }
TFixedArray::TFixedArray(const TFixedArray & other) {   type_ = other.type_->clone();
  integer_ = other.integer_;

}
TFixedArray &TFixedArray::operator=(const TFixedArray & other) {
  TFixedArray tmp(other);
  swap(tmp);
  return *this;
}
void TFixedArray::swap(TFixedArray & other) {
  std::swap(type_, other.type_);
  std::swap(integer_, other.integer_);

}

TFixedArray::~TFixedArray() { delete(type_); }

void TFixedArray::accept(Visitor *v) { v->visitTFixedArray(this); }
TFixedArray *TFixedArray::clone() const {
  return new TFixedArray(*this);
}

/********************   TGenericArray    ********************/
TGenericArray::TGenericArray(Type *p1) { type_ = p1; }
TGenericArray::TGenericArray(const TGenericArray & other) {   type_ = other.type_->clone();

}
TGenericArray &TGenericArray::operator=(const TGenericArray & other) {
  TGenericArray tmp(other);
  swap(tmp);
  return *this;
}
void TGenericArray::swap(TGenericArray & other) {
  std::swap(type_, other.type_);

}

TGenericArray::~TGenericArray() { delete(type_); }

void TGenericArray::accept(Visitor *v) { v->visitTGenericArray(this); }
TGenericArray *TGenericArray::clone() const {
  return new TGenericArray(*this);
}

/********************   TStruct    ********************/
TStruct::TStruct(ListStructMemberDeclaration *p1) { liststructmemberdeclaration_ = p1; }
TStruct::TStruct(const TStruct & other) {   liststructmemberdeclaration_ = other.liststructmemberdeclaration_->clone();

}
TStruct &TStruct::operator=(const TStruct & other) {
  TStruct tmp(other);
  swap(tmp);
  return *this;
}
void TStruct::swap(TStruct & other) {
  std::swap(liststructmemberdeclaration_, other.liststructmemberdeclaration_);

}

TStruct::~TStruct() { delete(liststructmemberdeclaration_); }

void TStruct::accept(Visitor *v) { v->visitTStruct(this); }
TStruct *TStruct::clone() const {
  return new TStruct(*this);
}

/********************   TType    ********************/
TType::TType() { }
TType::TType(const TType & other) { 
}
TType &TType::operator=(const TType & other) {
  TType tmp(other);
  swap(tmp);
  return *this;
}
void TType::swap(TType & other) {

}

TType::~TType() { }

void TType::accept(Visitor *v) { v->visitTType(this); }
TType *TType::clone() const {
  return new TType(*this);
}

/********************   SMDMemberDeclaration    ********************/
SMDMemberDeclaration::SMDMemberDeclaration(Type *p1, Ident p2) { type_ = p1; ident_ = p2; }
SMDMemberDeclaration::SMDMemberDeclaration(const SMDMemberDeclaration & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;

}
SMDMemberDeclaration &SMDMemberDeclaration::operator=(const SMDMemberDeclaration & other) {
  SMDMemberDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void SMDMemberDeclaration::swap(SMDMemberDeclaration & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

SMDMemberDeclaration::~SMDMemberDeclaration() { delete(type_); }

void SMDMemberDeclaration::accept(Visitor *v) { v->visitSMDMemberDeclaration(this); }
SMDMemberDeclaration *SMDMemberDeclaration::clone() const {
  return new SMDMemberDeclaration(*this);
}

/********************   PDAutoParameter    ********************/
PDAutoParameter::PDAutoParameter(ListVariableSpecifier *p1, Ident p2) { listvariablespecifier_ = p1; ident_ = p2; }
PDAutoParameter::PDAutoParameter(const PDAutoParameter & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  ident_ = other.ident_;

}
PDAutoParameter &PDAutoParameter::operator=(const PDAutoParameter & other) {
  PDAutoParameter tmp(other);
  swap(tmp);
  return *this;
}
void PDAutoParameter::swap(PDAutoParameter & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(ident_, other.ident_);

}

PDAutoParameter::~PDAutoParameter() { delete(listvariablespecifier_); }

void PDAutoParameter::accept(Visitor *v) { v->visitPDAutoParameter(this); }
PDAutoParameter *PDAutoParameter::clone() const {
  return new PDAutoParameter(*this);
}

/********************   PDTypedParameter    ********************/
PDTypedParameter::PDTypedParameter(ListVariableSpecifier *p1, Type *p2, Ident p3) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; }
PDTypedParameter::PDTypedParameter(const PDTypedParameter & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
PDTypedParameter &PDTypedParameter::operator=(const PDTypedParameter & other) {
  PDTypedParameter tmp(other);
  swap(tmp);
  return *this;
}
void PDTypedParameter::swap(PDTypedParameter & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

PDTypedParameter::~PDTypedParameter() { delete(listvariablespecifier_); delete(type_); }

void PDTypedParameter::accept(Visitor *v) { v->visitPDTypedParameter(this); }
PDTypedParameter *PDTypedParameter::clone() const {
  return new PDTypedParameter(*this);
}

/********************   SReturn    ********************/
SReturn::SReturn(Expression *p1) { expression_ = p1; }
SReturn::SReturn(const SReturn & other) {   expression_ = other.expression_->clone();

}
SReturn &SReturn::operator=(const SReturn & other) {
  SReturn tmp(other);
  swap(tmp);
  return *this;
}
void SReturn::swap(SReturn & other) {
  std::swap(expression_, other.expression_);

}

SReturn::~SReturn() { delete(expression_); }

void SReturn::accept(Visitor *v) { v->visitSReturn(this); }
SReturn *SReturn::clone() const {
  return new SReturn(*this);
}

/********************   SExpression    ********************/
SExpression::SExpression(Expression *p1) { expression_ = p1; }
SExpression::SExpression(const SExpression & other) {   expression_ = other.expression_->clone();

}
SExpression &SExpression::operator=(const SExpression & other) {
  SExpression tmp(other);
  swap(tmp);
  return *this;
}
void SExpression::swap(SExpression & other) {
  std::swap(expression_, other.expression_);

}

SExpression::~SExpression() { delete(expression_); }

void SExpression::accept(Visitor *v) { v->visitSExpression(this); }
SExpression *SExpression::clone() const {
  return new SExpression(*this);
}

/********************   SScope    ********************/
SScope::SScope(ListStatement *p1) { liststatement_ = p1; }
SScope::SScope(const SScope & other) {   liststatement_ = other.liststatement_->clone();

}
SScope &SScope::operator=(const SScope & other) {
  SScope tmp(other);
  swap(tmp);
  return *this;
}
void SScope::swap(SScope & other) {
  std::swap(liststatement_, other.liststatement_);

}

SScope::~SScope() { delete(liststatement_); }

void SScope::accept(Visitor *v) { v->visitSScope(this); }
SScope *SScope::clone() const {
  return new SScope(*this);
}

/********************   SIf    ********************/
SIf::SIf(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SIf::SIf(const SIf & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SIf &SIf::operator=(const SIf & other) {
  SIf tmp(other);
  swap(tmp);
  return *this;
}
void SIf::swap(SIf & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SIf::~SIf() { delete(expression_); delete(liststatement_); }

void SIf::accept(Visitor *v) { v->visitSIf(this); }
SIf *SIf::clone() const {
  return new SIf(*this);
}

/********************   SIfElse    ********************/
SIfElse::SIfElse(Expression *p1, ListStatement *p2, ListStatement *p3) { expression_ = p1; liststatement_1 = p2; liststatement_2 = p3; }
SIfElse::SIfElse(const SIfElse & other) {   expression_ = other.expression_->clone();
  liststatement_1 = other.liststatement_1->clone();
  liststatement_2 = other.liststatement_2->clone();

}
SIfElse &SIfElse::operator=(const SIfElse & other) {
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}
void SIfElse::swap(SIfElse & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_1, other.liststatement_1);
  std::swap(liststatement_2, other.liststatement_2);

}

SIfElse::~SIfElse() { delete(expression_); delete(liststatement_1); delete(liststatement_2); }

void SIfElse::accept(Visitor *v) { v->visitSIfElse(this); }
SIfElse *SIfElse::clone() const {
  return new SIfElse(*this);
}

/********************   SLoop    ********************/
SLoop::SLoop(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SLoop::SLoop(const SLoop & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SLoop &SLoop::operator=(const SLoop & other) {
  SLoop tmp(other);
  swap(tmp);
  return *this;
}
void SLoop::swap(SLoop & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SLoop::~SLoop() { delete(expression_); delete(liststatement_); }

void SLoop::accept(Visitor *v) { v->visitSLoop(this); }
SLoop *SLoop::clone() const {
  return new SLoop(*this);
}

/********************   SWhile    ********************/
SWhile::SWhile(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SWhile::SWhile(const SWhile & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SWhile &SWhile::operator=(const SWhile & other) {
  SWhile tmp(other);
  swap(tmp);
  return *this;
}
void SWhile::swap(SWhile & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SWhile::~SWhile() { delete(expression_); delete(liststatement_); }

void SWhile::accept(Visitor *v) { v->visitSWhile(this); }
SWhile *SWhile::clone() const {
  return new SWhile(*this);
}

/********************   SUntil    ********************/
SUntil::SUntil(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SUntil::SUntil(const SUntil & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SUntil &SUntil::operator=(const SUntil & other) {
  SUntil tmp(other);
  swap(tmp);
  return *this;
}
void SUntil::swap(SUntil & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SUntil::~SUntil() { delete(expression_); delete(liststatement_); }

void SUntil::accept(Visitor *v) { v->visitSUntil(this); }
SUntil *SUntil::clone() const {
  return new SUntil(*this);
}

/********************   SFor    ********************/
SFor::SFor(ListExpression *p1, Expression *p2, ListExpression *p3, ListStatement *p4) { listexpression_1 = p1; expression_ = p2; listexpression_2 = p3; liststatement_ = p4; }
SFor::SFor(const SFor & other) {   listexpression_1 = other.listexpression_1->clone();
  expression_ = other.expression_->clone();
  listexpression_2 = other.listexpression_2->clone();
  liststatement_ = other.liststatement_->clone();

}
SFor &SFor::operator=(const SFor & other) {
  SFor tmp(other);
  swap(tmp);
  return *this;
}
void SFor::swap(SFor & other) {
  std::swap(listexpression_1, other.listexpression_1);
  std::swap(expression_, other.expression_);
  std::swap(listexpression_2, other.listexpression_2);
  std::swap(liststatement_, other.liststatement_);

}

SFor::~SFor() { delete(listexpression_1); delete(expression_); delete(listexpression_2); delete(liststatement_); }

void SFor::accept(Visitor *v) { v->visitSFor(this); }
SFor *SFor::clone() const {
  return new SFor(*this);
}

/********************   SForEach    ********************/
SForEach::SForEach(Ident p1, Expression *p2, ListStatement *p3) { ident_ = p1; expression_ = p2; liststatement_ = p3; }
SForEach::SForEach(const SForEach & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SForEach &SForEach::operator=(const SForEach & other) {
  SForEach tmp(other);
  swap(tmp);
  return *this;
}
void SForEach::swap(SForEach & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SForEach::~SForEach() { delete(expression_); delete(liststatement_); }

void SForEach::accept(Visitor *v) { v->visitSForEach(this); }
SForEach *SForEach::clone() const {
  return new SForEach(*this);
}

/********************   SForAll    ********************/
SForAll::SForAll(Ident p1, Expression *p2, ListStatement *p3) { ident_ = p1; expression_ = p2; liststatement_ = p3; }
SForAll::SForAll(const SForAll & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SForAll &SForAll::operator=(const SForAll & other) {
  SForAll tmp(other);
  swap(tmp);
  return *this;
}
void SForAll::swap(SForAll & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SForAll::~SForAll() { delete(expression_); delete(liststatement_); }

void SForAll::accept(Visitor *v) { v->visitSForAll(this); }
SForAll *SForAll::clone() const {
  return new SForAll(*this);
}

/********************   SBreak    ********************/
SBreak::SBreak() { }
SBreak::SBreak(const SBreak & other) { 
}
SBreak &SBreak::operator=(const SBreak & other) {
  SBreak tmp(other);
  swap(tmp);
  return *this;
}
void SBreak::swap(SBreak & other) {

}

SBreak::~SBreak() { }

void SBreak::accept(Visitor *v) { v->visitSBreak(this); }
SBreak *SBreak::clone() const {
  return new SBreak(*this);
}

/********************   SContinue    ********************/
SContinue::SContinue() { }
SContinue::SContinue(const SContinue & other) { 
}
SContinue &SContinue::operator=(const SContinue & other) {
  SContinue tmp(other);
  swap(tmp);
  return *this;
}
void SContinue::swap(SContinue & other) {

}

SContinue::~SContinue() { }

void SContinue::accept(Visitor *v) { v->visitSContinue(this); }
SContinue *SContinue::clone() const {
  return new SContinue(*this);
}

/********************   SBreakpoint    ********************/
SBreakpoint::SBreakpoint() { }
SBreakpoint::SBreakpoint(const SBreakpoint & other) { 
}
SBreakpoint &SBreakpoint::operator=(const SBreakpoint & other) {
  SBreakpoint tmp(other);
  swap(tmp);
  return *this;
}
void SBreakpoint::swap(SBreakpoint & other) {

}

SBreakpoint::~SBreakpoint() { }

void SBreakpoint::accept(Visitor *v) { v->visitSBreakpoint(this); }
SBreakpoint *SBreakpoint::clone() const {
  return new SBreakpoint(*this);
}

/********************   SIVariable    ********************/
SIVariable::SIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; expression_ = p4; }
SIVariable::SIVariable(const SIVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
SIVariable &SIVariable::operator=(const SIVariable & other) {
  SIVariable tmp(other);
  swap(tmp);
  return *this;
}
void SIVariable::swap(SIVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

SIVariable::~SIVariable() { delete(listvariablespecifier_); delete(type_); delete(expression_); }

void SIVariable::accept(Visitor *v) { v->visitSIVariable(this); }
SIVariable *SIVariable::clone() const {
  return new SIVariable(*this);
}

/********************   SVariable    ********************/
SVariable::SVariable(ListVariableSpecifier *p1, Type *p2, Ident p3) { listvariablespecifier_ = p1; type_ = p2; ident_ = p3; }
SVariable::SVariable(const SVariable & other) {   listvariablespecifier_ = other.listvariablespecifier_->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;

}
SVariable &SVariable::operator=(const SVariable & other) {
  SVariable tmp(other);
  swap(tmp);
  return *this;
}
void SVariable::swap(SVariable & other) {
  std::swap(listvariablespecifier_, other.listvariablespecifier_);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

SVariable::~SVariable() { delete(listvariablespecifier_); delete(type_); }

void SVariable::accept(Visitor *v) { v->visitSVariable(this); }
SVariable *SVariable::clone() const {
  return new SVariable(*this);
}

/********************   RVIdent    ********************/
RVIdent::RVIdent(Ident p1) { ident_ = p1; }
RVIdent::RVIdent(const RVIdent & other) {   ident_ = other.ident_;

}
RVIdent &RVIdent::operator=(const RVIdent & other) {
  RVIdent tmp(other);
  swap(tmp);
  return *this;
}
void RVIdent::swap(RVIdent & other) {
  std::swap(ident_, other.ident_);

}

RVIdent::~RVIdent() { }

void RVIdent::accept(Visitor *v) { v->visitRVIdent(this); }
RVIdent *RVIdent::clone() const {
  return new RVIdent(*this);
}

/********************   RVQualified    ********************/
RVQualified::RVQualified(Ident p1, RValue *p2) { ident_ = p1; rvalue_ = p2; }
RVQualified::RVQualified(const RVQualified & other) {   ident_ = other.ident_;
  rvalue_ = other.rvalue_->clone();

}
RVQualified &RVQualified::operator=(const RVQualified & other) {
  RVQualified tmp(other);
  swap(tmp);
  return *this;
}
void RVQualified::swap(RVQualified & other) {
  std::swap(ident_, other.ident_);
  std::swap(rvalue_, other.rvalue_);

}

RVQualified::~RVQualified() { delete(rvalue_); }

void RVQualified::accept(Visitor *v) { v->visitRVQualified(this); }
RVQualified *RVQualified::clone() const {
  return new RVQualified(*this);
}

/********************   EDouble    ********************/
EDouble::EDouble(Double p1) { double_ = p1; }
EDouble::EDouble(const EDouble & other) {   double_ = other.double_;

}
EDouble &EDouble::operator=(const EDouble & other) {
  EDouble tmp(other);
  swap(tmp);
  return *this;
}
void EDouble::swap(EDouble & other) {
  std::swap(double_, other.double_);

}

EDouble::~EDouble() { }

void EDouble::accept(Visitor *v) { v->visitEDouble(this); }
EDouble *EDouble::clone() const {
  return new EDouble(*this);
}

/********************   EInteger    ********************/
EInteger::EInteger(Integer p1) { integer_ = p1; }
EInteger::EInteger(const EInteger & other) {   integer_ = other.integer_;

}
EInteger &EInteger::operator=(const EInteger & other) {
  EInteger tmp(other);
  swap(tmp);
  return *this;
}
void EInteger::swap(EInteger & other) {
  std::swap(integer_, other.integer_);

}

EInteger::~EInteger() { }

void EInteger::accept(Visitor *v) { v->visitEInteger(this); }
EInteger *EInteger::clone() const {
  return new EInteger(*this);
}

/********************   EString    ********************/
EString::EString(CString p1) { cstring_ = p1; }
EString::EString(const EString & other) {   cstring_ = other.cstring_;

}
EString &EString::operator=(const EString & other) {
  EString tmp(other);
  swap(tmp);
  return *this;
}
void EString::swap(EString & other) {
  std::swap(cstring_, other.cstring_);

}

EString::~EString() { }

void EString::accept(Visitor *v) { v->visitEString(this); }
EString *EString::clone() const {
  return new EString(*this);
}

/********************   EChar    ********************/
EChar::EChar(CChar p1) { cchar_ = p1; }
EChar::EChar(const EChar & other) {   cchar_ = other.cchar_;

}
EChar &EChar::operator=(const EChar & other) {
  EChar tmp(other);
  swap(tmp);
  return *this;
}
void EChar::swap(EChar & other) {
  std::swap(cchar_, other.cchar_);

}

EChar::~EChar() { }

void EChar::accept(Visitor *v) { v->visitEChar(this); }
EChar *EChar::clone() const {
  return new EChar(*this);
}

/********************   EPi    ********************/
EPi::EPi() { }
EPi::EPi(const EPi & other) { 
}
EPi &EPi::operator=(const EPi & other) {
  EPi tmp(other);
  swap(tmp);
  return *this;
}
void EPi::swap(EPi & other) {

}

EPi::~EPi() { }

void EPi::accept(Visitor *v) { v->visitEPi(this); }
EPi *EPi::clone() const {
  return new EPi(*this);
}

/********************   ERValue    ********************/
ERValue::ERValue(RValue *p1) { rvalue_ = p1; }
ERValue::ERValue(const ERValue & other) {   rvalue_ = other.rvalue_->clone();

}
ERValue &ERValue::operator=(const ERValue & other) {
  ERValue tmp(other);
  swap(tmp);
  return *this;
}
void ERValue::swap(ERValue & other) {
  std::swap(rvalue_, other.rvalue_);

}

ERValue::~ERValue() { delete(rvalue_); }

void ERValue::accept(Visitor *v) { v->visitERValue(this); }
ERValue *ERValue::clone() const {
  return new ERValue(*this);
}

/********************   EArray    ********************/
EArray::EArray(ListExpression *p1) { listexpression_ = p1; }
EArray::EArray(const EArray & other) {   listexpression_ = other.listexpression_->clone();

}
EArray &EArray::operator=(const EArray & other) {
  EArray tmp(other);
  swap(tmp);
  return *this;
}
void EArray::swap(EArray & other) {
  std::swap(listexpression_, other.listexpression_);

}

EArray::~EArray() { delete(listexpression_); }

void EArray::accept(Visitor *v) { v->visitEArray(this); }
EArray *EArray::clone() const {
  return new EArray(*this);
}

/********************   EList    ********************/
EList::EList(ListExpression *p1) { listexpression_ = p1; }
EList::EList(const EList & other) {   listexpression_ = other.listexpression_->clone();

}
EList &EList::operator=(const EList & other) {
  EList tmp(other);
  swap(tmp);
  return *this;
}
void EList::swap(EList & other) {
  std::swap(listexpression_, other.listexpression_);

}

EList::~EList() { delete(listexpression_); }

void EList::accept(Visitor *v) { v->visitEList(this); }
EList *EList::clone() const {
  return new EList(*this);
}

/********************   EAComp    ********************/
EAComp::EAComp(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
EAComp::EAComp(const EAComp & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
EAComp &EAComp::operator=(const EAComp & other) {
  EAComp tmp(other);
  swap(tmp);
  return *this;
}
void EAComp::swap(EAComp & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

EAComp::~EAComp() { delete(expression_); delete(listexpression_); }

void EAComp::accept(Visitor *v) { v->visitEAComp(this); }
EAComp *EAComp::clone() const {
  return new EAComp(*this);
}

/********************   ELComp    ********************/
ELComp::ELComp(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
ELComp::ELComp(const ELComp & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
ELComp &ELComp::operator=(const ELComp & other) {
  ELComp tmp(other);
  swap(tmp);
  return *this;
}
void ELComp::swap(ELComp & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

ELComp::~ELComp() { delete(expression_); delete(listexpression_); }

void ELComp::accept(Visitor *v) { v->visitELComp(this); }
ELComp *ELComp::clone() const {
  return new ELComp(*this);
}

/********************   EIndex    ********************/
EIndex::EIndex(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EIndex::EIndex(const EIndex & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIndex &EIndex::operator=(const EIndex & other) {
  EIndex tmp(other);
  swap(tmp);
  return *this;
}
void EIndex::swap(EIndex & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIndex::~EIndex() { delete(expression_1); delete(expression_2); }

void EIndex::accept(Visitor *v) { v->visitEIndex(this); }
EIndex *EIndex::clone() const {
  return new EIndex(*this);
}

/********************   ESimpleCall    ********************/
ESimpleCall::ESimpleCall(RValue *p1) { rvalue_ = p1; }
ESimpleCall::ESimpleCall(const ESimpleCall & other) {   rvalue_ = other.rvalue_->clone();

}
ESimpleCall &ESimpleCall::operator=(const ESimpleCall & other) {
  ESimpleCall tmp(other);
  swap(tmp);
  return *this;
}
void ESimpleCall::swap(ESimpleCall & other) {
  std::swap(rvalue_, other.rvalue_);

}

ESimpleCall::~ESimpleCall() { delete(rvalue_); }

void ESimpleCall::accept(Visitor *v) { v->visitESimpleCall(this); }
ESimpleCall *ESimpleCall::clone() const {
  return new ESimpleCall(*this);
}

/********************   ECall    ********************/
ECall::ECall(RValue *p1, ListExpression *p2) { rvalue_ = p1; listexpression_ = p2; }
ECall::ECall(const ECall & other) {   rvalue_ = other.rvalue_->clone();
  listexpression_ = other.listexpression_->clone();

}
ECall &ECall::operator=(const ECall & other) {
  ECall tmp(other);
  swap(tmp);
  return *this;
}
void ECall::swap(ECall & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(listexpression_, other.listexpression_);

}

ECall::~ECall() { delete(rvalue_); delete(listexpression_); }

void ECall::accept(Visitor *v) { v->visitECall(this); }
ECall *ECall::clone() const {
  return new ECall(*this);
}

/********************   EPostInc    ********************/
EPostInc::EPostInc(RValue *p1) { rvalue_ = p1; }
EPostInc::EPostInc(const EPostInc & other) {   rvalue_ = other.rvalue_->clone();

}
EPostInc &EPostInc::operator=(const EPostInc & other) {
  EPostInc tmp(other);
  swap(tmp);
  return *this;
}
void EPostInc::swap(EPostInc & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPostInc::~EPostInc() { delete(rvalue_); }

void EPostInc::accept(Visitor *v) { v->visitEPostInc(this); }
EPostInc *EPostInc::clone() const {
  return new EPostInc(*this);
}

/********************   EPostDec    ********************/
EPostDec::EPostDec(RValue *p1) { rvalue_ = p1; }
EPostDec::EPostDec(const EPostDec & other) {   rvalue_ = other.rvalue_->clone();

}
EPostDec &EPostDec::operator=(const EPostDec & other) {
  EPostDec tmp(other);
  swap(tmp);
  return *this;
}
void EPostDec::swap(EPostDec & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPostDec::~EPostDec() { delete(rvalue_); }

void EPostDec::accept(Visitor *v) { v->visitEPostDec(this); }
EPostDec *EPostDec::clone() const {
  return new EPostDec(*this);
}

/********************   EAddress    ********************/
EAddress::EAddress(Expression *p1) { expression_ = p1; }
EAddress::EAddress(const EAddress & other) {   expression_ = other.expression_->clone();

}
EAddress &EAddress::operator=(const EAddress & other) {
  EAddress tmp(other);
  swap(tmp);
  return *this;
}
void EAddress::swap(EAddress & other) {
  std::swap(expression_, other.expression_);

}

EAddress::~EAddress() { delete(expression_); }

void EAddress::accept(Visitor *v) { v->visitEAddress(this); }
EAddress *EAddress::clone() const {
  return new EAddress(*this);
}

/********************   EIntrinSExt    ********************/
EIntrinSExt::EIntrinSExt(Type *p1, Expression *p2) { type_ = p1; expression_ = p2; }
EIntrinSExt::EIntrinSExt(const EIntrinSExt & other) {   type_ = other.type_->clone();
  expression_ = other.expression_->clone();

}
EIntrinSExt &EIntrinSExt::operator=(const EIntrinSExt & other) {
  EIntrinSExt tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSExt::swap(EIntrinSExt & other) {
  std::swap(type_, other.type_);
  std::swap(expression_, other.expression_);

}

EIntrinSExt::~EIntrinSExt() { delete(type_); delete(expression_); }

void EIntrinSExt::accept(Visitor *v) { v->visitEIntrinSExt(this); }
EIntrinSExt *EIntrinSExt::clone() const {
  return new EIntrinSExt(*this);
}

/********************   EIntrinZExt    ********************/
EIntrinZExt::EIntrinZExt(Type *p1, Expression *p2) { type_ = p1; expression_ = p2; }
EIntrinZExt::EIntrinZExt(const EIntrinZExt & other) {   type_ = other.type_->clone();
  expression_ = other.expression_->clone();

}
EIntrinZExt &EIntrinZExt::operator=(const EIntrinZExt & other) {
  EIntrinZExt tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinZExt::swap(EIntrinZExt & other) {
  std::swap(type_, other.type_);
  std::swap(expression_, other.expression_);

}

EIntrinZExt::~EIntrinZExt() { delete(type_); delete(expression_); }

void EIntrinZExt::accept(Visitor *v) { v->visitEIntrinZExt(this); }
EIntrinZExt *EIntrinZExt::clone() const {
  return new EIntrinZExt(*this);
}

/********************   EIntrinAddI    ********************/
EIntrinAddI::EIntrinAddI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinAddI::EIntrinAddI(const EIntrinAddI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAddI &EIntrinAddI::operator=(const EIntrinAddI & other) {
  EIntrinAddI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAddI::swap(EIntrinAddI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAddI::~EIntrinAddI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinAddI::accept(Visitor *v) { v->visitEIntrinAddI(this); }
EIntrinAddI *EIntrinAddI::clone() const {
  return new EIntrinAddI(*this);
}

/********************   EIntrinSubI    ********************/
EIntrinSubI::EIntrinSubI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinSubI::EIntrinSubI(const EIntrinSubI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSubI &EIntrinSubI::operator=(const EIntrinSubI & other) {
  EIntrinSubI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSubI::swap(EIntrinSubI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSubI::~EIntrinSubI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinSubI::accept(Visitor *v) { v->visitEIntrinSubI(this); }
EIntrinSubI *EIntrinSubI::clone() const {
  return new EIntrinSubI(*this);
}

/********************   EIntrinMulI    ********************/
EIntrinMulI::EIntrinMulI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinMulI::EIntrinMulI(const EIntrinMulI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinMulI &EIntrinMulI::operator=(const EIntrinMulI & other) {
  EIntrinMulI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinMulI::swap(EIntrinMulI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinMulI::~EIntrinMulI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinMulI::accept(Visitor *v) { v->visitEIntrinMulI(this); }
EIntrinMulI *EIntrinMulI::clone() const {
  return new EIntrinMulI(*this);
}

/********************   EIntrinUdivI    ********************/
EIntrinUdivI::EIntrinUdivI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinUdivI::EIntrinUdivI(const EIntrinUdivI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUdivI &EIntrinUdivI::operator=(const EIntrinUdivI & other) {
  EIntrinUdivI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUdivI::swap(EIntrinUdivI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUdivI::~EIntrinUdivI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinUdivI::accept(Visitor *v) { v->visitEIntrinUdivI(this); }
EIntrinUdivI *EIntrinUdivI::clone() const {
  return new EIntrinUdivI(*this);
}

/********************   EIntrinSdivI    ********************/
EIntrinSdivI::EIntrinSdivI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinSdivI::EIntrinSdivI(const EIntrinSdivI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSdivI &EIntrinSdivI::operator=(const EIntrinSdivI & other) {
  EIntrinSdivI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSdivI::swap(EIntrinSdivI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSdivI::~EIntrinSdivI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinSdivI::accept(Visitor *v) { v->visitEIntrinSdivI(this); }
EIntrinSdivI *EIntrinSdivI::clone() const {
  return new EIntrinSdivI(*this);
}

/********************   EIntrinUremI    ********************/
EIntrinUremI::EIntrinUremI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinUremI::EIntrinUremI(const EIntrinUremI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinUremI &EIntrinUremI::operator=(const EIntrinUremI & other) {
  EIntrinUremI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinUremI::swap(EIntrinUremI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinUremI::~EIntrinUremI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinUremI::accept(Visitor *v) { v->visitEIntrinUremI(this); }
EIntrinUremI *EIntrinUremI::clone() const {
  return new EIntrinUremI(*this);
}

/********************   EIntrinSremI    ********************/
EIntrinSremI::EIntrinSremI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinSremI::EIntrinSremI(const EIntrinSremI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinSremI &EIntrinSremI::operator=(const EIntrinSremI & other) {
  EIntrinSremI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinSremI::swap(EIntrinSremI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinSremI::~EIntrinSremI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinSremI::accept(Visitor *v) { v->visitEIntrinSremI(this); }
EIntrinSremI *EIntrinSremI::clone() const {
  return new EIntrinSremI(*this);
}

/********************   EIntrinAndI    ********************/
EIntrinAndI::EIntrinAndI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinAndI::EIntrinAndI(const EIntrinAndI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAndI &EIntrinAndI::operator=(const EIntrinAndI & other) {
  EIntrinAndI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAndI::swap(EIntrinAndI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAndI::~EIntrinAndI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinAndI::accept(Visitor *v) { v->visitEIntrinAndI(this); }
EIntrinAndI *EIntrinAndI::clone() const {
  return new EIntrinAndI(*this);
}

/********************   EIntrinOrI    ********************/
EIntrinOrI::EIntrinOrI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinOrI::EIntrinOrI(const EIntrinOrI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinOrI &EIntrinOrI::operator=(const EIntrinOrI & other) {
  EIntrinOrI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinOrI::swap(EIntrinOrI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinOrI::~EIntrinOrI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinOrI::accept(Visitor *v) { v->visitEIntrinOrI(this); }
EIntrinOrI *EIntrinOrI::clone() const {
  return new EIntrinOrI(*this);
}

/********************   EIntrinXorI    ********************/
EIntrinXorI::EIntrinXorI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinXorI::EIntrinXorI(const EIntrinXorI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinXorI &EIntrinXorI::operator=(const EIntrinXorI & other) {
  EIntrinXorI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinXorI::swap(EIntrinXorI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinXorI::~EIntrinXorI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinXorI::accept(Visitor *v) { v->visitEIntrinXorI(this); }
EIntrinXorI *EIntrinXorI::clone() const {
  return new EIntrinXorI(*this);
}

/********************   EIntrinShlI    ********************/
EIntrinShlI::EIntrinShlI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinShlI::EIntrinShlI(const EIntrinShlI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinShlI &EIntrinShlI::operator=(const EIntrinShlI & other) {
  EIntrinShlI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinShlI::swap(EIntrinShlI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinShlI::~EIntrinShlI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinShlI::accept(Visitor *v) { v->visitEIntrinShlI(this); }
EIntrinShlI *EIntrinShlI::clone() const {
  return new EIntrinShlI(*this);
}

/********************   EIntrinLshrI    ********************/
EIntrinLshrI::EIntrinLshrI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinLshrI::EIntrinLshrI(const EIntrinLshrI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinLshrI &EIntrinLshrI::operator=(const EIntrinLshrI & other) {
  EIntrinLshrI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinLshrI::swap(EIntrinLshrI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinLshrI::~EIntrinLshrI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinLshrI::accept(Visitor *v) { v->visitEIntrinLshrI(this); }
EIntrinLshrI *EIntrinLshrI::clone() const {
  return new EIntrinLshrI(*this);
}

/********************   EIntrinAshrI    ********************/
EIntrinAshrI::EIntrinAshrI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinAshrI::EIntrinAshrI(const EIntrinAshrI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinAshrI &EIntrinAshrI::operator=(const EIntrinAshrI & other) {
  EIntrinAshrI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinAshrI::swap(EIntrinAshrI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinAshrI::~EIntrinAshrI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinAshrI::accept(Visitor *v) { v->visitEIntrinAshrI(this); }
EIntrinAshrI *EIntrinAshrI::clone() const {
  return new EIntrinAshrI(*this);
}

/********************   EIntrinNotI    ********************/
EIntrinNotI::EIntrinNotI(Type *p1, Expression *p2) { type_ = p1; expression_ = p2; }
EIntrinNotI::EIntrinNotI(const EIntrinNotI & other) {   type_ = other.type_->clone();
  expression_ = other.expression_->clone();

}
EIntrinNotI &EIntrinNotI::operator=(const EIntrinNotI & other) {
  EIntrinNotI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNotI::swap(EIntrinNotI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_, other.expression_);

}

EIntrinNotI::~EIntrinNotI() { delete(type_); delete(expression_); }

void EIntrinNotI::accept(Visitor *v) { v->visitEIntrinNotI(this); }
EIntrinNotI *EIntrinNotI::clone() const {
  return new EIntrinNotI(*this);
}

/********************   EIntrinNegI    ********************/
EIntrinNegI::EIntrinNegI(Type *p1, Expression *p2) { type_ = p1; expression_ = p2; }
EIntrinNegI::EIntrinNegI(const EIntrinNegI & other) {   type_ = other.type_->clone();
  expression_ = other.expression_->clone();

}
EIntrinNegI &EIntrinNegI::operator=(const EIntrinNegI & other) {
  EIntrinNegI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinNegI::swap(EIntrinNegI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_, other.expression_);

}

EIntrinNegI::~EIntrinNegI() { delete(type_); delete(expression_); }

void EIntrinNegI::accept(Visitor *v) { v->visitEIntrinNegI(this); }
EIntrinNegI *EIntrinNegI::clone() const {
  return new EIntrinNegI(*this);
}

/********************   EIntrinCEqI    ********************/
EIntrinCEqI::EIntrinCEqI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinCEqI::EIntrinCEqI(const EIntrinCEqI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCEqI &EIntrinCEqI::operator=(const EIntrinCEqI & other) {
  EIntrinCEqI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCEqI::swap(EIntrinCEqI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCEqI::~EIntrinCEqI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinCEqI::accept(Visitor *v) { v->visitEIntrinCEqI(this); }
EIntrinCEqI *EIntrinCEqI::clone() const {
  return new EIntrinCEqI(*this);
}

/********************   EIntrinCNeI    ********************/
EIntrinCNeI::EIntrinCNeI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinCNeI::EIntrinCNeI(const EIntrinCNeI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCNeI &EIntrinCNeI::operator=(const EIntrinCNeI & other) {
  EIntrinCNeI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCNeI::swap(EIntrinCNeI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCNeI::~EIntrinCNeI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinCNeI::accept(Visitor *v) { v->visitEIntrinCNeI(this); }
EIntrinCNeI *EIntrinCNeI::clone() const {
  return new EIntrinCNeI(*this);
}

/********************   EIntrinCLtI    ********************/
EIntrinCLtI::EIntrinCLtI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinCLtI::EIntrinCLtI(const EIntrinCLtI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLtI &EIntrinCLtI::operator=(const EIntrinCLtI & other) {
  EIntrinCLtI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLtI::swap(EIntrinCLtI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLtI::~EIntrinCLtI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinCLtI::accept(Visitor *v) { v->visitEIntrinCLtI(this); }
EIntrinCLtI *EIntrinCLtI::clone() const {
  return new EIntrinCLtI(*this);
}

/********************   EIntrinCGtI    ********************/
EIntrinCGtI::EIntrinCGtI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinCGtI::EIntrinCGtI(const EIntrinCGtI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGtI &EIntrinCGtI::operator=(const EIntrinCGtI & other) {
  EIntrinCGtI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGtI::swap(EIntrinCGtI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGtI::~EIntrinCGtI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinCGtI::accept(Visitor *v) { v->visitEIntrinCGtI(this); }
EIntrinCGtI *EIntrinCGtI::clone() const {
  return new EIntrinCGtI(*this);
}

/********************   EIntrinCLeI    ********************/
EIntrinCLeI::EIntrinCLeI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinCLeI::EIntrinCLeI(const EIntrinCLeI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCLeI &EIntrinCLeI::operator=(const EIntrinCLeI & other) {
  EIntrinCLeI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCLeI::swap(EIntrinCLeI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCLeI::~EIntrinCLeI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinCLeI::accept(Visitor *v) { v->visitEIntrinCLeI(this); }
EIntrinCLeI *EIntrinCLeI::clone() const {
  return new EIntrinCLeI(*this);
}

/********************   EIntrinCGeI    ********************/
EIntrinCGeI::EIntrinCGeI(Type *p1, Expression *p2, Expression *p3) { type_ = p1; expression_1 = p2; expression_2 = p3; }
EIntrinCGeI::EIntrinCGeI(const EIntrinCGeI & other) {   type_ = other.type_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EIntrinCGeI &EIntrinCGeI::operator=(const EIntrinCGeI & other) {
  EIntrinCGeI tmp(other);
  swap(tmp);
  return *this;
}
void EIntrinCGeI::swap(EIntrinCGeI & other) {
  std::swap(type_, other.type_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EIntrinCGeI::~EIntrinCGeI() { delete(type_); delete(expression_1); delete(expression_2); }

void EIntrinCGeI::accept(Visitor *v) { v->visitEIntrinCGeI(this); }
EIntrinCGeI *EIntrinCGeI::clone() const {
  return new EIntrinCGeI(*this);
}

/********************   ELnot    ********************/
ELnot::ELnot(Expression *p1) { expression_ = p1; }
ELnot::ELnot(const ELnot & other) {   expression_ = other.expression_->clone();

}
ELnot &ELnot::operator=(const ELnot & other) {
  ELnot tmp(other);
  swap(tmp);
  return *this;
}
void ELnot::swap(ELnot & other) {
  std::swap(expression_, other.expression_);

}

ELnot::~ELnot() { delete(expression_); }

void ELnot::accept(Visitor *v) { v->visitELnot(this); }
ELnot *ELnot::clone() const {
  return new ELnot(*this);
}

/********************   EPreInc    ********************/
EPreInc::EPreInc(RValue *p1) { rvalue_ = p1; }
EPreInc::EPreInc(const EPreInc & other) {   rvalue_ = other.rvalue_->clone();

}
EPreInc &EPreInc::operator=(const EPreInc & other) {
  EPreInc tmp(other);
  swap(tmp);
  return *this;
}
void EPreInc::swap(EPreInc & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPreInc::~EPreInc() { delete(rvalue_); }

void EPreInc::accept(Visitor *v) { v->visitEPreInc(this); }
EPreInc *EPreInc::clone() const {
  return new EPreInc(*this);
}

/********************   EPreDec    ********************/
EPreDec::EPreDec(RValue *p1) { rvalue_ = p1; }
EPreDec::EPreDec(const EPreDec & other) {   rvalue_ = other.rvalue_->clone();

}
EPreDec &EPreDec::operator=(const EPreDec & other) {
  EPreDec tmp(other);
  swap(tmp);
  return *this;
}
void EPreDec::swap(EPreDec & other) {
  std::swap(rvalue_, other.rvalue_);

}

EPreDec::~EPreDec() { delete(rvalue_); }

void EPreDec::accept(Visitor *v) { v->visitEPreDec(this); }
EPreDec *EPreDec::clone() const {
  return new EPreDec(*this);
}

/********************   ENeg    ********************/
ENeg::ENeg(Expression *p1) { expression_ = p1; }
ENeg::ENeg(const ENeg & other) {   expression_ = other.expression_->clone();

}
ENeg &ENeg::operator=(const ENeg & other) {
  ENeg tmp(other);
  swap(tmp);
  return *this;
}
void ENeg::swap(ENeg & other) {
  std::swap(expression_, other.expression_);

}

ENeg::~ENeg() { delete(expression_); }

void ENeg::accept(Visitor *v) { v->visitENeg(this); }
ENeg *ENeg::clone() const {
  return new ENeg(*this);
}

/********************   EBnot    ********************/
EBnot::EBnot(Expression *p1) { expression_ = p1; }
EBnot::EBnot(const EBnot & other) {   expression_ = other.expression_->clone();

}
EBnot &EBnot::operator=(const EBnot & other) {
  EBnot tmp(other);
  swap(tmp);
  return *this;
}
void EBnot::swap(EBnot & other) {
  std::swap(expression_, other.expression_);

}

EBnot::~EBnot() { delete(expression_); }

void EBnot::accept(Visitor *v) { v->visitEBnot(this); }
EBnot *EBnot::clone() const {
  return new EBnot(*this);
}

/********************   EPos    ********************/
EPos::EPos(Expression *p1) { expression_ = p1; }
EPos::EPos(const EPos & other) {   expression_ = other.expression_->clone();

}
EPos &EPos::operator=(const EPos & other) {
  EPos tmp(other);
  swap(tmp);
  return *this;
}
void EPos::swap(EPos & other) {
  std::swap(expression_, other.expression_);

}

EPos::~EPos() { delete(expression_); }

void EPos::accept(Visitor *v) { v->visitEPos(this); }
EPos *EPos::clone() const {
  return new EPos(*this);
}

/********************   EMul    ********************/
EMul::EMul(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EMul::EMul(const EMul & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EMul &EMul::operator=(const EMul & other) {
  EMul tmp(other);
  swap(tmp);
  return *this;
}
void EMul::swap(EMul & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMul::~EMul() { delete(expression_1); delete(expression_2); }

void EMul::accept(Visitor *v) { v->visitEMul(this); }
EMul *EMul::clone() const {
  return new EMul(*this);
}

/********************   EDiv    ********************/
EDiv::EDiv(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EDiv::EDiv(const EDiv & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EDiv &EDiv::operator=(const EDiv & other) {
  EDiv tmp(other);
  swap(tmp);
  return *this;
}
void EDiv::swap(EDiv & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EDiv::~EDiv() { delete(expression_1); delete(expression_2); }

void EDiv::accept(Visitor *v) { v->visitEDiv(this); }
EDiv *EDiv::clone() const {
  return new EDiv(*this);
}

/********************   EMod    ********************/
EMod::EMod(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EMod::EMod(const EMod & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EMod &EMod::operator=(const EMod & other) {
  EMod tmp(other);
  swap(tmp);
  return *this;
}
void EMod::swap(EMod & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMod::~EMod() { delete(expression_1); delete(expression_2); }

void EMod::accept(Visitor *v) { v->visitEMod(this); }
EMod *EMod::clone() const {
  return new EMod(*this);
}

/********************   EAdd    ********************/
EAdd::EAdd(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EAdd::EAdd(const EAdd & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EAdd &EAdd::operator=(const EAdd & other) {
  EAdd tmp(other);
  swap(tmp);
  return *this;
}
void EAdd::swap(EAdd & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAdd::~EAdd() { delete(expression_1); delete(expression_2); }

void EAdd::accept(Visitor *v) { v->visitEAdd(this); }
EAdd *EAdd::clone() const {
  return new EAdd(*this);
}

/********************   ESub    ********************/
ESub::ESub(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ESub::ESub(const ESub & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ESub &ESub::operator=(const ESub & other) {
  ESub tmp(other);
  swap(tmp);
  return *this;
}
void ESub::swap(ESub & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ESub::~ESub() { delete(expression_1); delete(expression_2); }

void ESub::accept(Visitor *v) { v->visitESub(this); }
ESub *ESub::clone() const {
  return new ESub(*this);
}

/********************   ELSh    ********************/
ELSh::ELSh(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELSh::ELSh(const ELSh & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELSh &ELSh::operator=(const ELSh & other) {
  ELSh tmp(other);
  swap(tmp);
  return *this;
}
void ELSh::swap(ELSh & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELSh::~ELSh() { delete(expression_1); delete(expression_2); }

void ELSh::accept(Visitor *v) { v->visitELSh(this); }
ELSh *ELSh::clone() const {
  return new ELSh(*this);
}

/********************   ERSh    ********************/
ERSh::ERSh(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ERSh::ERSh(const ERSh & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ERSh &ERSh::operator=(const ERSh & other) {
  ERSh tmp(other);
  swap(tmp);
  return *this;
}
void ERSh::swap(ERSh & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ERSh::~ERSh() { delete(expression_1); delete(expression_2); }

void ERSh::accept(Visitor *v) { v->visitERSh(this); }
ERSh *ERSh::clone() const {
  return new ERSh(*this);
}

/********************   ELT    ********************/
ELT::ELT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELT::ELT(const ELT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELT &ELT::operator=(const ELT & other) {
  ELT tmp(other);
  swap(tmp);
  return *this;
}
void ELT::swap(ELT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELT::~ELT() { delete(expression_1); delete(expression_2); }

void ELT::accept(Visitor *v) { v->visitELT(this); }
ELT *ELT::clone() const {
  return new ELT(*this);
}

/********************   EGT    ********************/
EGT::EGT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EGT::EGT(const EGT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EGT &EGT::operator=(const EGT & other) {
  EGT tmp(other);
  swap(tmp);
  return *this;
}
void EGT::swap(EGT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGT::~EGT() { delete(expression_1); delete(expression_2); }

void EGT::accept(Visitor *v) { v->visitEGT(this); }
EGT *EGT::clone() const {
  return new EGT(*this);
}

/********************   ELE    ********************/
ELE::ELE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELE::ELE(const ELE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELE &ELE::operator=(const ELE & other) {
  ELE tmp(other);
  swap(tmp);
  return *this;
}
void ELE::swap(ELE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELE::~ELE() { delete(expression_1); delete(expression_2); }

void ELE::accept(Visitor *v) { v->visitELE(this); }
ELE *ELE::clone() const {
  return new ELE(*this);
}

/********************   EGE    ********************/
EGE::EGE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EGE::EGE(const EGE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EGE &EGE::operator=(const EGE & other) {
  EGE tmp(other);
  swap(tmp);
  return *this;
}
void EGE::swap(EGE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGE::~EGE() { delete(expression_1); delete(expression_2); }

void EGE::accept(Visitor *v) { v->visitEGE(this); }
EGE *EGE::clone() const {
  return new EGE(*this);
}

/********************   EE    ********************/
EE::EE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EE::EE(const EE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EE &EE::operator=(const EE & other) {
  EE tmp(other);
  swap(tmp);
  return *this;
}
void EE::swap(EE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EE::~EE() { delete(expression_1); delete(expression_2); }

void EE::accept(Visitor *v) { v->visitEE(this); }
EE *EE::clone() const {
  return new EE(*this);
}

/********************   ENE    ********************/
ENE::ENE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ENE::ENE(const ENE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ENE &ENE::operator=(const ENE & other) {
  ENE tmp(other);
  swap(tmp);
  return *this;
}
void ENE::swap(ENE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ENE::~ENE() { delete(expression_1); delete(expression_2); }

void ENE::accept(Visitor *v) { v->visitENE(this); }
ENE *ENE::clone() const {
  return new ENE(*this);
}

/********************   EBand    ********************/
EBand::EBand(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBand::EBand(const EBand & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBand &EBand::operator=(const EBand & other) {
  EBand tmp(other);
  swap(tmp);
  return *this;
}
void EBand::swap(EBand & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBand::~EBand() { delete(expression_1); delete(expression_2); }

void EBand::accept(Visitor *v) { v->visitEBand(this); }
EBand *EBand::clone() const {
  return new EBand(*this);
}

/********************   EBor    ********************/
EBor::EBor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBor::EBor(const EBor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBor &EBor::operator=(const EBor & other) {
  EBor tmp(other);
  swap(tmp);
  return *this;
}
void EBor::swap(EBor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBor::~EBor() { delete(expression_1); delete(expression_2); }

void EBor::accept(Visitor *v) { v->visitEBor(this); }
EBor *EBor::clone() const {
  return new EBor(*this);
}

/********************   EBxor    ********************/
EBxor::EBxor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBxor::EBxor(const EBxor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBxor &EBxor::operator=(const EBxor & other) {
  EBxor tmp(other);
  swap(tmp);
  return *this;
}
void EBxor::swap(EBxor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBxor::~EBxor() { delete(expression_1); delete(expression_2); }

void EBxor::accept(Visitor *v) { v->visitEBxor(this); }
EBxor *EBxor::clone() const {
  return new EBxor(*this);
}

/********************   ELand    ********************/
ELand::ELand(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELand::ELand(const ELand & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELand &ELand::operator=(const ELand & other) {
  ELand tmp(other);
  swap(tmp);
  return *this;
}
void ELand::swap(ELand & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELand::~ELand() { delete(expression_1); delete(expression_2); }

void ELand::accept(Visitor *v) { v->visitELand(this); }
ELand *ELand::clone() const {
  return new ELand(*this);
}

/********************   ELor    ********************/
ELor::ELor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELor::ELor(const ELor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELor &ELor::operator=(const ELor & other) {
  ELor tmp(other);
  swap(tmp);
  return *this;
}
void ELor::swap(ELor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELor::~ELor() { delete(expression_1); delete(expression_2); }

void ELor::accept(Visitor *v) { v->visitELor(this); }
ELor *ELor::clone() const {
  return new ELor(*this);
}

/********************   ELxor    ********************/
ELxor::ELxor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELxor::ELxor(const ELxor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELxor &ELxor::operator=(const ELxor & other) {
  ELxor tmp(other);
  swap(tmp);
  return *this;
}
void ELxor::swap(ELxor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELxor::~ELxor() { delete(expression_1); delete(expression_2); }

void ELxor::accept(Visitor *v) { v->visitELxor(this); }
ELxor *ELxor::clone() const {
  return new ELxor(*this);
}

/********************   EConditional    ********************/
EConditional::EConditional(Expression *p1, Expression *p2, Expression *p3) { expression_1 = p1; expression_2 = p2; expression_3 = p3; }
EConditional::EConditional(const EConditional & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  expression_3 = other.expression_3->clone();

}
EConditional &EConditional::operator=(const EConditional & other) {
  EConditional tmp(other);
  swap(tmp);
  return *this;
}
void EConditional::swap(EConditional & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(expression_3, other.expression_3);

}

EConditional::~EConditional() { delete(expression_1); delete(expression_2); delete(expression_3); }

void EConditional::accept(Visitor *v) { v->visitEConditional(this); }
EConditional *EConditional::clone() const {
  return new EConditional(*this);
}

/********************   EAssign    ********************/
EAssign::EAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EAssign::EAssign(const EAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EAssign &EAssign::operator=(const EAssign & other) {
  EAssign tmp(other);
  swap(tmp);
  return *this;
}
void EAssign::swap(EAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EAssign::~EAssign() { delete(rvalue_); delete(expression_); }

void EAssign::accept(Visitor *v) { v->visitEAssign(this); }
EAssign *EAssign::clone() const {
  return new EAssign(*this);
}

/********************   EAddAssign    ********************/
EAddAssign::EAddAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EAddAssign::EAddAssign(const EAddAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EAddAssign &EAddAssign::operator=(const EAddAssign & other) {
  EAddAssign tmp(other);
  swap(tmp);
  return *this;
}
void EAddAssign::swap(EAddAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EAddAssign::~EAddAssign() { delete(rvalue_); delete(expression_); }

void EAddAssign::accept(Visitor *v) { v->visitEAddAssign(this); }
EAddAssign *EAddAssign::clone() const {
  return new EAddAssign(*this);
}

/********************   ESubAssign    ********************/
ESubAssign::ESubAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
ESubAssign::ESubAssign(const ESubAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
ESubAssign &ESubAssign::operator=(const ESubAssign & other) {
  ESubAssign tmp(other);
  swap(tmp);
  return *this;
}
void ESubAssign::swap(ESubAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

ESubAssign::~ESubAssign() { delete(rvalue_); delete(expression_); }

void ESubAssign::accept(Visitor *v) { v->visitESubAssign(this); }
ESubAssign *ESubAssign::clone() const {
  return new ESubAssign(*this);
}

/********************   EMulAssign    ********************/
EMulAssign::EMulAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EMulAssign::EMulAssign(const EMulAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EMulAssign &EMulAssign::operator=(const EMulAssign & other) {
  EMulAssign tmp(other);
  swap(tmp);
  return *this;
}
void EMulAssign::swap(EMulAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EMulAssign::~EMulAssign() { delete(rvalue_); delete(expression_); }

void EMulAssign::accept(Visitor *v) { v->visitEMulAssign(this); }
EMulAssign *EMulAssign::clone() const {
  return new EMulAssign(*this);
}

/********************   EDivAssign    ********************/
EDivAssign::EDivAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EDivAssign::EDivAssign(const EDivAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EDivAssign &EDivAssign::operator=(const EDivAssign & other) {
  EDivAssign tmp(other);
  swap(tmp);
  return *this;
}
void EDivAssign::swap(EDivAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EDivAssign::~EDivAssign() { delete(rvalue_); delete(expression_); }

void EDivAssign::accept(Visitor *v) { v->visitEDivAssign(this); }
EDivAssign *EDivAssign::clone() const {
  return new EDivAssign(*this);
}

/********************   EModAssign    ********************/
EModAssign::EModAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EModAssign::EModAssign(const EModAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EModAssign &EModAssign::operator=(const EModAssign & other) {
  EModAssign tmp(other);
  swap(tmp);
  return *this;
}
void EModAssign::swap(EModAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EModAssign::~EModAssign() { delete(rvalue_); delete(expression_); }

void EModAssign::accept(Visitor *v) { v->visitEModAssign(this); }
EModAssign *EModAssign::clone() const {
  return new EModAssign(*this);
}

/********************   EAndAssign    ********************/
EAndAssign::EAndAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EAndAssign::EAndAssign(const EAndAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EAndAssign &EAndAssign::operator=(const EAndAssign & other) {
  EAndAssign tmp(other);
  swap(tmp);
  return *this;
}
void EAndAssign::swap(EAndAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EAndAssign::~EAndAssign() { delete(rvalue_); delete(expression_); }

void EAndAssign::accept(Visitor *v) { v->visitEAndAssign(this); }
EAndAssign *EAndAssign::clone() const {
  return new EAndAssign(*this);
}

/********************   EOrAssign    ********************/
EOrAssign::EOrAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EOrAssign::EOrAssign(const EOrAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EOrAssign &EOrAssign::operator=(const EOrAssign & other) {
  EOrAssign tmp(other);
  swap(tmp);
  return *this;
}
void EOrAssign::swap(EOrAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EOrAssign::~EOrAssign() { delete(rvalue_); delete(expression_); }

void EOrAssign::accept(Visitor *v) { v->visitEOrAssign(this); }
EOrAssign *EOrAssign::clone() const {
  return new EOrAssign(*this);
}

/********************   EXorAssign    ********************/
EXorAssign::EXorAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
EXorAssign::EXorAssign(const EXorAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
EXorAssign &EXorAssign::operator=(const EXorAssign & other) {
  EXorAssign tmp(other);
  swap(tmp);
  return *this;
}
void EXorAssign::swap(EXorAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

EXorAssign::~EXorAssign() { delete(rvalue_); delete(expression_); }

void EXorAssign::accept(Visitor *v) { v->visitEXorAssign(this); }
EXorAssign *EXorAssign::clone() const {
  return new EXorAssign(*this);
}

/********************   ELShAssign    ********************/
ELShAssign::ELShAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
ELShAssign::ELShAssign(const ELShAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
ELShAssign &ELShAssign::operator=(const ELShAssign & other) {
  ELShAssign tmp(other);
  swap(tmp);
  return *this;
}
void ELShAssign::swap(ELShAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

ELShAssign::~ELShAssign() { delete(rvalue_); delete(expression_); }

void ELShAssign::accept(Visitor *v) { v->visitELShAssign(this); }
ELShAssign *ELShAssign::clone() const {
  return new ELShAssign(*this);
}

/********************   ERShAssign    ********************/
ERShAssign::ERShAssign(RValue *p1, Expression *p2) { rvalue_ = p1; expression_ = p2; }
ERShAssign::ERShAssign(const ERShAssign & other) {   rvalue_ = other.rvalue_->clone();
  expression_ = other.expression_->clone();

}
ERShAssign &ERShAssign::operator=(const ERShAssign & other) {
  ERShAssign tmp(other);
  swap(tmp);
  return *this;
}
void ERShAssign::swap(ERShAssign & other) {
  std::swap(rvalue_, other.rvalue_);
  std::swap(expression_, other.expression_);

}

ERShAssign::~ERShAssign() { delete(rvalue_); delete(expression_); }

void ERShAssign::accept(Visitor *v) { v->visitERShAssign(this); }
ERShAssign *ERShAssign::clone() const {
  return new ERShAssign(*this);
}

/********************   ListTLDeclaration    ********************/
ListTLDeclaration::ListTLDeclaration(TLDeclaration *p1, ListTLDeclaration *p2) { tldeclaration_ = p1; listtldeclaration_ = p2; }
ListTLDeclaration::ListTLDeclaration(const ListTLDeclaration & other) {   tldeclaration_ = other.tldeclaration_->clone();
  listtldeclaration_ = other.listtldeclaration_->clone();

}
ListTLDeclaration &ListTLDeclaration::operator=(const ListTLDeclaration & other) {
  ListTLDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListTLDeclaration::swap(ListTLDeclaration & other) {
  std::swap(tldeclaration_, other.tldeclaration_);
  std::swap(listtldeclaration_, other.listtldeclaration_);

}

ListTLDeclaration::~ListTLDeclaration() { delete(tldeclaration_); delete(listtldeclaration_); }
ListTLDeclaration::ListTLDeclaration(TLDeclaration *p)
{
  tldeclaration_ = p;
  listtldeclaration_= 0;
}
ListTLDeclaration* ListTLDeclaration::reverse()
{
  if (listtldeclaration_ == 0) return this;
  else
  {
    ListTLDeclaration *tmp = listtldeclaration_->reverse(this);
    listtldeclaration_ = 0;
    return tmp;
  }
}

ListTLDeclaration* ListTLDeclaration::reverse(ListTLDeclaration* prev)
{
  if (listtldeclaration_ == 0)
  {
    listtldeclaration_ = prev;
    return this;
  }
  else
  {
    ListTLDeclaration *tmp = listtldeclaration_->reverse(this);
    listtldeclaration_ = prev;
    return tmp;
  }
}


void ListTLDeclaration::accept(Visitor *v) { v->visitListTLDeclaration(this); }
ListTLDeclaration *ListTLDeclaration::clone() const {
  return new ListTLDeclaration(*this);
}

/********************   ListDeclaration    ********************/
ListDeclaration::ListDeclaration(Declaration *p1, ListDeclaration *p2) { declaration_ = p1; listdeclaration_ = p2; }
ListDeclaration::ListDeclaration(const ListDeclaration & other) {   declaration_ = other.declaration_->clone();
  listdeclaration_ = other.listdeclaration_->clone();

}
ListDeclaration &ListDeclaration::operator=(const ListDeclaration & other) {
  ListDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListDeclaration::swap(ListDeclaration & other) {
  std::swap(declaration_, other.declaration_);
  std::swap(listdeclaration_, other.listdeclaration_);

}

ListDeclaration::~ListDeclaration() { delete(declaration_); delete(listdeclaration_); }
ListDeclaration::ListDeclaration(Declaration *p)
{
  declaration_ = p;
  listdeclaration_= 0;
}
ListDeclaration* ListDeclaration::reverse()
{
  if (listdeclaration_ == 0) return this;
  else
  {
    ListDeclaration *tmp = listdeclaration_->reverse(this);
    listdeclaration_ = 0;
    return tmp;
  }
}

ListDeclaration* ListDeclaration::reverse(ListDeclaration* prev)
{
  if (listdeclaration_ == 0)
  {
    listdeclaration_ = prev;
    return this;
  }
  else
  {
    ListDeclaration *tmp = listdeclaration_->reverse(this);
    listdeclaration_ = prev;
    return tmp;
  }
}


void ListDeclaration::accept(Visitor *v) { v->visitListDeclaration(this); }
ListDeclaration *ListDeclaration::clone() const {
  return new ListDeclaration(*this);
}

/********************   ListStatement    ********************/
ListStatement::ListStatement(Statement *p1, ListStatement *p2) { statement_ = p1; liststatement_ = p2; }
ListStatement::ListStatement(const ListStatement & other) {   statement_ = other.statement_->clone();
  liststatement_ = other.liststatement_->clone();

}
ListStatement &ListStatement::operator=(const ListStatement & other) {
  ListStatement tmp(other);
  swap(tmp);
  return *this;
}
void ListStatement::swap(ListStatement & other) {
  std::swap(statement_, other.statement_);
  std::swap(liststatement_, other.liststatement_);

}

ListStatement::~ListStatement() { delete(statement_); delete(liststatement_); }
ListStatement::ListStatement(Statement *p)
{
  statement_ = p;
  liststatement_= 0;
}
ListStatement* ListStatement::reverse()
{
  if (liststatement_ == 0) return this;
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = 0;
    return tmp;
  }
}

ListStatement* ListStatement::reverse(ListStatement* prev)
{
  if (liststatement_ == 0)
  {
    liststatement_ = prev;
    return this;
  }
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = prev;
    return tmp;
  }
}


void ListStatement::accept(Visitor *v) { v->visitListStatement(this); }
ListStatement *ListStatement::clone() const {
  return new ListStatement(*this);
}

/********************   ListTypeSpecifier    ********************/
ListTypeSpecifier::ListTypeSpecifier(TypeSpecifier *p1, ListTypeSpecifier *p2) { typespecifier_ = p1; listtypespecifier_ = p2; }
ListTypeSpecifier::ListTypeSpecifier(const ListTypeSpecifier & other) {   typespecifier_ = other.typespecifier_->clone();
  listtypespecifier_ = other.listtypespecifier_->clone();

}
ListTypeSpecifier &ListTypeSpecifier::operator=(const ListTypeSpecifier & other) {
  ListTypeSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListTypeSpecifier::swap(ListTypeSpecifier & other) {
  std::swap(typespecifier_, other.typespecifier_);
  std::swap(listtypespecifier_, other.listtypespecifier_);

}

ListTypeSpecifier::~ListTypeSpecifier() { delete(typespecifier_); delete(listtypespecifier_); }
ListTypeSpecifier::ListTypeSpecifier(TypeSpecifier *p)
{
  typespecifier_ = p;
  listtypespecifier_= 0;
}
ListTypeSpecifier* ListTypeSpecifier::reverse()
{
  if (listtypespecifier_ == 0) return this;
  else
  {
    ListTypeSpecifier *tmp = listtypespecifier_->reverse(this);
    listtypespecifier_ = 0;
    return tmp;
  }
}

ListTypeSpecifier* ListTypeSpecifier::reverse(ListTypeSpecifier* prev)
{
  if (listtypespecifier_ == 0)
  {
    listtypespecifier_ = prev;
    return this;
  }
  else
  {
    ListTypeSpecifier *tmp = listtypespecifier_->reverse(this);
    listtypespecifier_ = prev;
    return tmp;
  }
}


void ListTypeSpecifier::accept(Visitor *v) { v->visitListTypeSpecifier(this); }
ListTypeSpecifier *ListTypeSpecifier::clone() const {
  return new ListTypeSpecifier(*this);
}

/********************   ListConversionSpecifier    ********************/
ListConversionSpecifier::ListConversionSpecifier(ConversionSpecifier *p1, ListConversionSpecifier *p2) { conversionspecifier_ = p1; listconversionspecifier_ = p2; }
ListConversionSpecifier::ListConversionSpecifier(const ListConversionSpecifier & other) {   conversionspecifier_ = other.conversionspecifier_->clone();
  listconversionspecifier_ = other.listconversionspecifier_->clone();

}
ListConversionSpecifier &ListConversionSpecifier::operator=(const ListConversionSpecifier & other) {
  ListConversionSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListConversionSpecifier::swap(ListConversionSpecifier & other) {
  std::swap(conversionspecifier_, other.conversionspecifier_);
  std::swap(listconversionspecifier_, other.listconversionspecifier_);

}

ListConversionSpecifier::~ListConversionSpecifier() { delete(conversionspecifier_); delete(listconversionspecifier_); }
ListConversionSpecifier::ListConversionSpecifier(ConversionSpecifier *p)
{
  conversionspecifier_ = p;
  listconversionspecifier_= 0;
}
ListConversionSpecifier* ListConversionSpecifier::reverse()
{
  if (listconversionspecifier_ == 0) return this;
  else
  {
    ListConversionSpecifier *tmp = listconversionspecifier_->reverse(this);
    listconversionspecifier_ = 0;
    return tmp;
  }
}

ListConversionSpecifier* ListConversionSpecifier::reverse(ListConversionSpecifier* prev)
{
  if (listconversionspecifier_ == 0)
  {
    listconversionspecifier_ = prev;
    return this;
  }
  else
  {
    ListConversionSpecifier *tmp = listconversionspecifier_->reverse(this);
    listconversionspecifier_ = prev;
    return tmp;
  }
}


void ListConversionSpecifier::accept(Visitor *v) { v->visitListConversionSpecifier(this); }
ListConversionSpecifier *ListConversionSpecifier::clone() const {
  return new ListConversionSpecifier(*this);
}

/********************   ListFunctionSpecifier    ********************/
ListFunctionSpecifier::ListFunctionSpecifier(FunctionSpecifier *p1, ListFunctionSpecifier *p2) { functionspecifier_ = p1; listfunctionspecifier_ = p2; }
ListFunctionSpecifier::ListFunctionSpecifier(const ListFunctionSpecifier & other) {   functionspecifier_ = other.functionspecifier_->clone();
  listfunctionspecifier_ = other.listfunctionspecifier_->clone();

}
ListFunctionSpecifier &ListFunctionSpecifier::operator=(const ListFunctionSpecifier & other) {
  ListFunctionSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListFunctionSpecifier::swap(ListFunctionSpecifier & other) {
  std::swap(functionspecifier_, other.functionspecifier_);
  std::swap(listfunctionspecifier_, other.listfunctionspecifier_);

}

ListFunctionSpecifier::~ListFunctionSpecifier() { delete(functionspecifier_); delete(listfunctionspecifier_); }
ListFunctionSpecifier::ListFunctionSpecifier(FunctionSpecifier *p)
{
  functionspecifier_ = p;
  listfunctionspecifier_= 0;
}
ListFunctionSpecifier* ListFunctionSpecifier::reverse()
{
  if (listfunctionspecifier_ == 0) return this;
  else
  {
    ListFunctionSpecifier *tmp = listfunctionspecifier_->reverse(this);
    listfunctionspecifier_ = 0;
    return tmp;
  }
}

ListFunctionSpecifier* ListFunctionSpecifier::reverse(ListFunctionSpecifier* prev)
{
  if (listfunctionspecifier_ == 0)
  {
    listfunctionspecifier_ = prev;
    return this;
  }
  else
  {
    ListFunctionSpecifier *tmp = listfunctionspecifier_->reverse(this);
    listfunctionspecifier_ = prev;
    return tmp;
  }
}


void ListFunctionSpecifier::accept(Visitor *v) { v->visitListFunctionSpecifier(this); }
ListFunctionSpecifier *ListFunctionSpecifier::clone() const {
  return new ListFunctionSpecifier(*this);
}

/********************   ListVariableSpecifier    ********************/
ListVariableSpecifier::ListVariableSpecifier(VariableSpecifier *p1, ListVariableSpecifier *p2) { variablespecifier_ = p1; listvariablespecifier_ = p2; }
ListVariableSpecifier::ListVariableSpecifier(const ListVariableSpecifier & other) {   variablespecifier_ = other.variablespecifier_->clone();
  listvariablespecifier_ = other.listvariablespecifier_->clone();

}
ListVariableSpecifier &ListVariableSpecifier::operator=(const ListVariableSpecifier & other) {
  ListVariableSpecifier tmp(other);
  swap(tmp);
  return *this;
}
void ListVariableSpecifier::swap(ListVariableSpecifier & other) {
  std::swap(variablespecifier_, other.variablespecifier_);
  std::swap(listvariablespecifier_, other.listvariablespecifier_);

}

ListVariableSpecifier::~ListVariableSpecifier() { delete(variablespecifier_); delete(listvariablespecifier_); }
ListVariableSpecifier::ListVariableSpecifier(VariableSpecifier *p)
{
  variablespecifier_ = p;
  listvariablespecifier_= 0;
}
ListVariableSpecifier* ListVariableSpecifier::reverse()
{
  if (listvariablespecifier_ == 0) return this;
  else
  {
    ListVariableSpecifier *tmp = listvariablespecifier_->reverse(this);
    listvariablespecifier_ = 0;
    return tmp;
  }
}

ListVariableSpecifier* ListVariableSpecifier::reverse(ListVariableSpecifier* prev)
{
  if (listvariablespecifier_ == 0)
  {
    listvariablespecifier_ = prev;
    return this;
  }
  else
  {
    ListVariableSpecifier *tmp = listvariablespecifier_->reverse(this);
    listvariablespecifier_ = prev;
    return tmp;
  }
}


void ListVariableSpecifier::accept(Visitor *v) { v->visitListVariableSpecifier(this); }
ListVariableSpecifier *ListVariableSpecifier::clone() const {
  return new ListVariableSpecifier(*this);
}

/********************   ListStructMemberDeclaration    ********************/
ListStructMemberDeclaration::ListStructMemberDeclaration(StructMemberDeclaration *p1, ListStructMemberDeclaration *p2) { structmemberdeclaration_ = p1; liststructmemberdeclaration_ = p2; }
ListStructMemberDeclaration::ListStructMemberDeclaration(const ListStructMemberDeclaration & other) {   structmemberdeclaration_ = other.structmemberdeclaration_->clone();
  liststructmemberdeclaration_ = other.liststructmemberdeclaration_->clone();

}
ListStructMemberDeclaration &ListStructMemberDeclaration::operator=(const ListStructMemberDeclaration & other) {
  ListStructMemberDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListStructMemberDeclaration::swap(ListStructMemberDeclaration & other) {
  std::swap(structmemberdeclaration_, other.structmemberdeclaration_);
  std::swap(liststructmemberdeclaration_, other.liststructmemberdeclaration_);

}

ListStructMemberDeclaration::~ListStructMemberDeclaration() { delete(structmemberdeclaration_); delete(liststructmemberdeclaration_); }
ListStructMemberDeclaration::ListStructMemberDeclaration(StructMemberDeclaration *p)
{
  structmemberdeclaration_ = p;
  liststructmemberdeclaration_= 0;
}
ListStructMemberDeclaration* ListStructMemberDeclaration::reverse()
{
  if (liststructmemberdeclaration_ == 0) return this;
  else
  {
    ListStructMemberDeclaration *tmp = liststructmemberdeclaration_->reverse(this);
    liststructmemberdeclaration_ = 0;
    return tmp;
  }
}

ListStructMemberDeclaration* ListStructMemberDeclaration::reverse(ListStructMemberDeclaration* prev)
{
  if (liststructmemberdeclaration_ == 0)
  {
    liststructmemberdeclaration_ = prev;
    return this;
  }
  else
  {
    ListStructMemberDeclaration *tmp = liststructmemberdeclaration_->reverse(this);
    liststructmemberdeclaration_ = prev;
    return tmp;
  }
}


void ListStructMemberDeclaration::accept(Visitor *v) { v->visitListStructMemberDeclaration(this); }
ListStructMemberDeclaration *ListStructMemberDeclaration::clone() const {
  return new ListStructMemberDeclaration(*this);
}

/********************   ListGenericParam    ********************/
ListGenericParam::ListGenericParam(GenericParam *p1, ListGenericParam *p2) { genericparam_ = p1; listgenericparam_ = p2; }
ListGenericParam::ListGenericParam(const ListGenericParam & other) {   genericparam_ = other.genericparam_->clone();
  listgenericparam_ = other.listgenericparam_->clone();

}
ListGenericParam &ListGenericParam::operator=(const ListGenericParam & other) {
  ListGenericParam tmp(other);
  swap(tmp);
  return *this;
}
void ListGenericParam::swap(ListGenericParam & other) {
  std::swap(genericparam_, other.genericparam_);
  std::swap(listgenericparam_, other.listgenericparam_);

}

ListGenericParam::~ListGenericParam() { delete(genericparam_); delete(listgenericparam_); }
ListGenericParam::ListGenericParam(GenericParam *p)
{
  genericparam_ = p;
  listgenericparam_= 0;
}
ListGenericParam* ListGenericParam::reverse()
{
  if (listgenericparam_ == 0) return this;
  else
  {
    ListGenericParam *tmp = listgenericparam_->reverse(this);
    listgenericparam_ = 0;
    return tmp;
  }
}

ListGenericParam* ListGenericParam::reverse(ListGenericParam* prev)
{
  if (listgenericparam_ == 0)
  {
    listgenericparam_ = prev;
    return this;
  }
  else
  {
    ListGenericParam *tmp = listgenericparam_->reverse(this);
    listgenericparam_ = prev;
    return tmp;
  }
}


void ListGenericParam::accept(Visitor *v) { v->visitListGenericParam(this); }
ListGenericParam *ListGenericParam::clone() const {
  return new ListGenericParam(*this);
}

/********************   ListParameterDeclaration    ********************/
ListParameterDeclaration::ListParameterDeclaration(ParameterDeclaration *p1, ListParameterDeclaration *p2) { parameterdeclaration_ = p1; listparameterdeclaration_ = p2; }
ListParameterDeclaration::ListParameterDeclaration(const ListParameterDeclaration & other) {   parameterdeclaration_ = other.parameterdeclaration_->clone();
  listparameterdeclaration_ = other.listparameterdeclaration_->clone();

}
ListParameterDeclaration &ListParameterDeclaration::operator=(const ListParameterDeclaration & other) {
  ListParameterDeclaration tmp(other);
  swap(tmp);
  return *this;
}
void ListParameterDeclaration::swap(ListParameterDeclaration & other) {
  std::swap(parameterdeclaration_, other.parameterdeclaration_);
  std::swap(listparameterdeclaration_, other.listparameterdeclaration_);

}

ListParameterDeclaration::~ListParameterDeclaration() { delete(parameterdeclaration_); delete(listparameterdeclaration_); }
ListParameterDeclaration::ListParameterDeclaration(ParameterDeclaration *p)
{
  parameterdeclaration_ = p;
  listparameterdeclaration_= 0;
}
ListParameterDeclaration* ListParameterDeclaration::reverse()
{
  if (listparameterdeclaration_ == 0) return this;
  else
  {
    ListParameterDeclaration *tmp = listparameterdeclaration_->reverse(this);
    listparameterdeclaration_ = 0;
    return tmp;
  }
}

ListParameterDeclaration* ListParameterDeclaration::reverse(ListParameterDeclaration* prev)
{
  if (listparameterdeclaration_ == 0)
  {
    listparameterdeclaration_ = prev;
    return this;
  }
  else
  {
    ListParameterDeclaration *tmp = listparameterdeclaration_->reverse(this);
    listparameterdeclaration_ = prev;
    return tmp;
  }
}


void ListParameterDeclaration::accept(Visitor *v) { v->visitListParameterDeclaration(this); }
ListParameterDeclaration *ListParameterDeclaration::clone() const {
  return new ListParameterDeclaration(*this);
}

/********************   ListExpression    ********************/
ListExpression::ListExpression(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
ListExpression::ListExpression(const ListExpression & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
ListExpression &ListExpression::operator=(const ListExpression & other) {
  ListExpression tmp(other);
  swap(tmp);
  return *this;
}
void ListExpression::swap(ListExpression & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

ListExpression::~ListExpression() { delete(expression_); delete(listexpression_); }
ListExpression::ListExpression(Expression *p)
{
  expression_ = p;
  listexpression_= 0;
}
ListExpression* ListExpression::reverse()
{
  if (listexpression_ == 0) return this;
  else
  {
    ListExpression *tmp = listexpression_->reverse(this);
    listexpression_ = 0;
    return tmp;
  }
}

ListExpression* ListExpression::reverse(ListExpression* prev)
{
  if (listexpression_ == 0)
  {
    listexpression_ = prev;
    return this;
  }
  else
  {
    ListExpression *tmp = listexpression_->reverse(this);
    listexpression_ = prev;
    return tmp;
  }
}


void ListExpression::accept(Visitor *v) { v->visitListExpression(this); }
ListExpression *ListExpression::clone() const {
  return new ListExpression(*this);
}


