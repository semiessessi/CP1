#ifndef ABSYN_HEADER
#define ABSYN_HEADER

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* CString;
typedef char* CChar;
typedef char* Operator;


/********************   Forward Declarations    ********************/

class Main;
class DImport;
class DExpose;
class DNamespace;
class DDefaultFunction;
class DFunction;
class DOperator;
class DOperatorInfo;
class DTypeDecl;
class DTypeConv;
class DExtern;
class DIVariable;
class DVariable;
class PFunction;
class ONLnot;
class ONPreInc;
class ONPreDec;
class ONBnot;
class ONMul;
class ONExp;
class ONDiv;
class ONRDiv;
class ONMod;
class ONAdd;
class ONSub;
class ONLSh;
class ONRSh;
class ONLT;
class ONGT;
class ONLE;
class ONGE;
class ONE;
class ONNE;
class ONBand;
class ONBor;
class ONBxor;
class ONLand;
class ONLor;
class ONLxor;
class ONRight;
class ONLeft;
class OTIdentity;
class FSEntryPoint;
class FSPure;
class FSConst;
class FSInline;
class FSAssociative;
class FSCommutative;
class FSAntiCommutative;
class FSInverse;
class FSSelfInverse;
class CSUp;
class CSDown;
class CSImplicit;
class VSConst;
class TSAlign;
class TSGeneric;
class TSInteger;
class TSReal;
class TSGParam;
class TAddress;
class TByte;
class TCustom;
class TFixedArray;
class TGenericArray;
class TStruct;
class TType;
class SMDMemberDeclaration;
class PDAutoParameter;
class PDTypedParameter;
class SReturn;
class SExpression;
class SScope;
class SIf;
class SIfElse;
class SLoop;
class SWhile;
class SUntil;
class SFor;
class SForEach;
class SForAll;
class SBreak;
class SContinue;
class SBreakpoint;
class SIVariable;
class SVariable;
class RVIdent;
class RVQualified;
class EDouble;
class EInteger;
class EString;
class EChar;
class EPi;
class ERValue;
class EArray;
class EList;
class EAComp;
class ELComp;
class EIndex;
class ESimpleCall;
class ECall;
class EPostInc;
class EPostDec;
class EAddress;
class EIntrinSExt;
class EIntrinZExt;
class EIntrinAddI;
class EIntrinSubI;
class EIntrinMulI;
class EIntrinUdivI;
class EIntrinSdivI;
class EIntrinUremI;
class EIntrinSremI;
class EIntrinAndI;
class EIntrinOrI;
class EIntrinXorI;
class EIntrinShlI;
class EIntrinLshrI;
class EIntrinAshrI;
class EIntrinNotI;
class EIntrinNegI;
class EIntrinCEqI;
class EIntrinCNeI;
class EIntrinCLtI;
class EIntrinCGtI;
class EIntrinCLeI;
class EIntrinCGeI;
class ELnot;
class EPreInc;
class EPreDec;
class ENeg;
class EBnot;
class EPos;
class EMul;
class EDiv;
class EMod;
class EAdd;
class ESub;
class ELSh;
class ERSh;
class ELT;
class EGT;
class ELE;
class EGE;
class EE;
class ENE;
class EBand;
class EBor;
class EBxor;
class ELand;
class ELor;
class ELxor;
class EConditional;
class EAssign;
class EAddAssign;
class ESubAssign;
class EMulAssign;
class EDivAssign;
class EModAssign;
class EAndAssign;
class EOrAssign;
class EXorAssign;
class ELShAssign;
class ERShAssign;
class ListTLDeclaration;
class ListDeclaration;
class ListStatement;
class ListTypeSpecifier;
class ListConversionSpecifier;
class ListFunctionSpecifier;
class ListVariableSpecifier;
class ListStructMemberDeclaration;
class ListGenericParam;
class ListParameterDeclaration;
class ListExpression;
class Code;
class TLDeclaration;
class Declaration;
class Prototype;
class OperatorName;
class OperatorTrait;
class FunctionSpecifier;
class ConversionSpecifier;
class VariableSpecifier;
class TypeSpecifier;
class GenericParam;
class Type;
class StructMemberDeclaration;
class ParameterDeclaration;
class Statement;
class RValue;
class Expression;


/********************   Visitor Interfaces    ********************/

class Visitor
{
 public:
  virtual ~Visitor() {}
  virtual void visitMain(Main *p) = 0;
  virtual void visitDImport(DImport *p) = 0;
  virtual void visitDExpose(DExpose *p) = 0;
  virtual void visitDNamespace(DNamespace *p) = 0;
  virtual void visitDDefaultFunction(DDefaultFunction *p) = 0;
  virtual void visitDFunction(DFunction *p) = 0;
  virtual void visitDOperator(DOperator *p) = 0;
  virtual void visitDOperatorInfo(DOperatorInfo *p) = 0;
  virtual void visitDTypeDecl(DTypeDecl *p) = 0;
  virtual void visitDTypeConv(DTypeConv *p) = 0;
  virtual void visitDExtern(DExtern *p) = 0;
  virtual void visitDIVariable(DIVariable *p) = 0;
  virtual void visitDVariable(DVariable *p) = 0;
  virtual void visitPFunction(PFunction *p) = 0;
  virtual void visitONLnot(ONLnot *p) = 0;
  virtual void visitONPreInc(ONPreInc *p) = 0;
  virtual void visitONPreDec(ONPreDec *p) = 0;
  virtual void visitONBnot(ONBnot *p) = 0;
  virtual void visitONMul(ONMul *p) = 0;
  virtual void visitONExp(ONExp *p) = 0;
  virtual void visitONDiv(ONDiv *p) = 0;
  virtual void visitONRDiv(ONRDiv *p) = 0;
  virtual void visitONMod(ONMod *p) = 0;
  virtual void visitONAdd(ONAdd *p) = 0;
  virtual void visitONSub(ONSub *p) = 0;
  virtual void visitONLSh(ONLSh *p) = 0;
  virtual void visitONRSh(ONRSh *p) = 0;
  virtual void visitONLT(ONLT *p) = 0;
  virtual void visitONGT(ONGT *p) = 0;
  virtual void visitONLE(ONLE *p) = 0;
  virtual void visitONGE(ONGE *p) = 0;
  virtual void visitONE(ONE *p) = 0;
  virtual void visitONNE(ONNE *p) = 0;
  virtual void visitONBand(ONBand *p) = 0;
  virtual void visitONBor(ONBor *p) = 0;
  virtual void visitONBxor(ONBxor *p) = 0;
  virtual void visitONLand(ONLand *p) = 0;
  virtual void visitONLor(ONLor *p) = 0;
  virtual void visitONLxor(ONLxor *p) = 0;
  virtual void visitONRight(ONRight *p) = 0;
  virtual void visitONLeft(ONLeft *p) = 0;
  virtual void visitOTIdentity(OTIdentity *p) = 0;
  virtual void visitFSEntryPoint(FSEntryPoint *p) = 0;
  virtual void visitFSPure(FSPure *p) = 0;
  virtual void visitFSConst(FSConst *p) = 0;
  virtual void visitFSInline(FSInline *p) = 0;
  virtual void visitFSAssociative(FSAssociative *p) = 0;
  virtual void visitFSCommutative(FSCommutative *p) = 0;
  virtual void visitFSAntiCommutative(FSAntiCommutative *p) = 0;
  virtual void visitFSInverse(FSInverse *p) = 0;
  virtual void visitFSSelfInverse(FSSelfInverse *p) = 0;
  virtual void visitCSUp(CSUp *p) = 0;
  virtual void visitCSDown(CSDown *p) = 0;
  virtual void visitCSImplicit(CSImplicit *p) = 0;
  virtual void visitVSConst(VSConst *p) = 0;
  virtual void visitTSAlign(TSAlign *p) = 0;
  virtual void visitTSGeneric(TSGeneric *p) = 0;
  virtual void visitTSInteger(TSInteger *p) = 0;
  virtual void visitTSReal(TSReal *p) = 0;
  virtual void visitTSGParam(TSGParam *p) = 0;
  virtual void visitTAddress(TAddress *p) = 0;
  virtual void visitTByte(TByte *p) = 0;
  virtual void visitTCustom(TCustom *p) = 0;
  virtual void visitTFixedArray(TFixedArray *p) = 0;
  virtual void visitTGenericArray(TGenericArray *p) = 0;
  virtual void visitTStruct(TStruct *p) = 0;
  virtual void visitTType(TType *p) = 0;
  virtual void visitSMDMemberDeclaration(SMDMemberDeclaration *p) = 0;
  virtual void visitPDAutoParameter(PDAutoParameter *p) = 0;
  virtual void visitPDTypedParameter(PDTypedParameter *p) = 0;
  virtual void visitSReturn(SReturn *p) = 0;
  virtual void visitSExpression(SExpression *p) = 0;
  virtual void visitSScope(SScope *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitSLoop(SLoop *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSUntil(SUntil *p) = 0;
  virtual void visitSFor(SFor *p) = 0;
  virtual void visitSForEach(SForEach *p) = 0;
  virtual void visitSForAll(SForAll *p) = 0;
  virtual void visitSBreak(SBreak *p) = 0;
  virtual void visitSContinue(SContinue *p) = 0;
  virtual void visitSBreakpoint(SBreakpoint *p) = 0;
  virtual void visitSIVariable(SIVariable *p) = 0;
  virtual void visitSVariable(SVariable *p) = 0;
  virtual void visitRVIdent(RVIdent *p) = 0;
  virtual void visitRVQualified(RVQualified *p) = 0;
  virtual void visitEDouble(EDouble *p) = 0;
  virtual void visitEInteger(EInteger *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEChar(EChar *p) = 0;
  virtual void visitEPi(EPi *p) = 0;
  virtual void visitERValue(ERValue *p) = 0;
  virtual void visitEArray(EArray *p) = 0;
  virtual void visitEList(EList *p) = 0;
  virtual void visitEAComp(EAComp *p) = 0;
  virtual void visitELComp(ELComp *p) = 0;
  virtual void visitEIndex(EIndex *p) = 0;
  virtual void visitESimpleCall(ESimpleCall *p) = 0;
  virtual void visitECall(ECall *p) = 0;
  virtual void visitEPostInc(EPostInc *p) = 0;
  virtual void visitEPostDec(EPostDec *p) = 0;
  virtual void visitEAddress(EAddress *p) = 0;
  virtual void visitEIntrinSExt(EIntrinSExt *p) = 0;
  virtual void visitEIntrinZExt(EIntrinZExt *p) = 0;
  virtual void visitEIntrinAddI(EIntrinAddI *p) = 0;
  virtual void visitEIntrinSubI(EIntrinSubI *p) = 0;
  virtual void visitEIntrinMulI(EIntrinMulI *p) = 0;
  virtual void visitEIntrinUdivI(EIntrinUdivI *p) = 0;
  virtual void visitEIntrinSdivI(EIntrinSdivI *p) = 0;
  virtual void visitEIntrinUremI(EIntrinUremI *p) = 0;
  virtual void visitEIntrinSremI(EIntrinSremI *p) = 0;
  virtual void visitEIntrinAndI(EIntrinAndI *p) = 0;
  virtual void visitEIntrinOrI(EIntrinOrI *p) = 0;
  virtual void visitEIntrinXorI(EIntrinXorI *p) = 0;
  virtual void visitEIntrinShlI(EIntrinShlI *p) = 0;
  virtual void visitEIntrinLshrI(EIntrinLshrI *p) = 0;
  virtual void visitEIntrinAshrI(EIntrinAshrI *p) = 0;
  virtual void visitEIntrinNotI(EIntrinNotI *p) = 0;
  virtual void visitEIntrinNegI(EIntrinNegI *p) = 0;
  virtual void visitEIntrinCEqI(EIntrinCEqI *p) = 0;
  virtual void visitEIntrinCNeI(EIntrinCNeI *p) = 0;
  virtual void visitEIntrinCLtI(EIntrinCLtI *p) = 0;
  virtual void visitEIntrinCGtI(EIntrinCGtI *p) = 0;
  virtual void visitEIntrinCLeI(EIntrinCLeI *p) = 0;
  virtual void visitEIntrinCGeI(EIntrinCGeI *p) = 0;
  virtual void visitELnot(ELnot *p) = 0;
  virtual void visitEPreInc(EPreInc *p) = 0;
  virtual void visitEPreDec(EPreDec *p) = 0;
  virtual void visitENeg(ENeg *p) = 0;
  virtual void visitEBnot(EBnot *p) = 0;
  virtual void visitEPos(EPos *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEMod(EMod *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitELSh(ELSh *p) = 0;
  virtual void visitERSh(ERSh *p) = 0;
  virtual void visitELT(ELT *p) = 0;
  virtual void visitEGT(EGT *p) = 0;
  virtual void visitELE(ELE *p) = 0;
  virtual void visitEGE(EGE *p) = 0;
  virtual void visitEE(EE *p) = 0;
  virtual void visitENE(ENE *p) = 0;
  virtual void visitEBand(EBand *p) = 0;
  virtual void visitEBor(EBor *p) = 0;
  virtual void visitEBxor(EBxor *p) = 0;
  virtual void visitELand(ELand *p) = 0;
  virtual void visitELor(ELor *p) = 0;
  virtual void visitELxor(ELxor *p) = 0;
  virtual void visitEConditional(EConditional *p) = 0;
  virtual void visitEAssign(EAssign *p) = 0;
  virtual void visitEAddAssign(EAddAssign *p) = 0;
  virtual void visitESubAssign(ESubAssign *p) = 0;
  virtual void visitEMulAssign(EMulAssign *p) = 0;
  virtual void visitEDivAssign(EDivAssign *p) = 0;
  virtual void visitEModAssign(EModAssign *p) = 0;
  virtual void visitEAndAssign(EAndAssign *p) = 0;
  virtual void visitEOrAssign(EOrAssign *p) = 0;
  virtual void visitEXorAssign(EXorAssign *p) = 0;
  virtual void visitELShAssign(ELShAssign *p) = 0;
  virtual void visitERShAssign(ERShAssign *p) = 0;
  virtual void visitListTLDeclaration(ListTLDeclaration *p) = 0;
  virtual void visitListDeclaration(ListDeclaration *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListTypeSpecifier(ListTypeSpecifier *p) = 0;
  virtual void visitListConversionSpecifier(ListConversionSpecifier *p) = 0;
  virtual void visitListFunctionSpecifier(ListFunctionSpecifier *p) = 0;
  virtual void visitListVariableSpecifier(ListVariableSpecifier *p) = 0;
  virtual void visitListStructMemberDeclaration(ListStructMemberDeclaration *p) = 0;
  virtual void visitListGenericParam(ListGenericParam *p) = 0;
  virtual void visitListParameterDeclaration(ListParameterDeclaration *p) = 0;
  virtual void visitListExpression(ListExpression *p) = 0;
  virtual void visitCode(Code *p) = 0;
  virtual void visitTLDeclaration(TLDeclaration *p) = 0;
  virtual void visitDeclaration(Declaration *p) = 0;
  virtual void visitPrototype(Prototype *p) = 0;
  virtual void visitOperatorName(OperatorName *p) = 0;
  virtual void visitOperatorTrait(OperatorTrait *p) = 0;
  virtual void visitFunctionSpecifier(FunctionSpecifier *p) = 0;
  virtual void visitConversionSpecifier(ConversionSpecifier *p) = 0;
  virtual void visitVariableSpecifier(VariableSpecifier *p) = 0;
  virtual void visitTypeSpecifier(TypeSpecifier *p) = 0;
  virtual void visitGenericParam(GenericParam *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitStructMemberDeclaration(StructMemberDeclaration *p) = 0;
  virtual void visitParameterDeclaration(ParameterDeclaration *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitRValue(RValue *p) = 0;
  virtual void visitExpression(Expression *p) = 0;

  virtual void visitInteger(Integer i) = 0;
  virtual void visitDouble(Double d) = 0;
  virtual void visitChar(Char c) = 0;
  virtual void visitString(String s) = 0;
};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};



/********************   Abstract Syntax Classes    ********************/

class Code : public Visitable {
public:
  virtual Code *clone() const = 0;
};

class Main : public Code
{
 public:
  ListTLDeclaration *listtldeclaration_;
  ListDeclaration *listdeclaration_;

  Main(const Main &);
  Main &operator=(const Main &);
  Main(ListTLDeclaration *p1, ListDeclaration *p2);
  ~Main();
  virtual void accept(Visitor *v);
  virtual  Main  *clone() const;
  void swap(Main &);
};


class TLDeclaration : public Visitable {
public:
  virtual TLDeclaration *clone() const = 0;
};

class DImport : public TLDeclaration
{
 public:
  Ident ident_;

  DImport(const DImport &);
  DImport &operator=(const DImport &);
  DImport(Ident p1);
  ~DImport();
  virtual void accept(Visitor *v);
  virtual  DImport  *clone() const;
  void swap(DImport &);
};

class DExpose : public TLDeclaration
{
 public:
  Ident ident_;

  DExpose(const DExpose &);
  DExpose &operator=(const DExpose &);
  DExpose(Ident p1);
  ~DExpose();
  virtual void accept(Visitor *v);
  virtual  DExpose  *clone() const;
  void swap(DExpose &);
};


class Declaration : public Visitable {
public:
  virtual Declaration *clone() const = 0;
};

class DNamespace : public Declaration
{
 public:
  Ident ident_;
  ListDeclaration *listdeclaration_;

  DNamespace(const DNamespace &);
  DNamespace &operator=(const DNamespace &);
  DNamespace(Ident p1, ListDeclaration *p2);
  ~DNamespace();
  virtual void accept(Visitor *v);
  virtual  DNamespace  *clone() const;
  void swap(DNamespace &);
};

class DDefaultFunction : public Declaration
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Ident ident_;
  ListParameterDeclaration *listparameterdeclaration_;
  ListStatement *liststatement_;

  DDefaultFunction(const DDefaultFunction &);
  DDefaultFunction &operator=(const DDefaultFunction &);
  DDefaultFunction(ListFunctionSpecifier *p1, Ident p2, ListParameterDeclaration *p3, ListStatement *p4);
  ~DDefaultFunction();
  virtual void accept(Visitor *v);
  virtual  DDefaultFunction  *clone() const;
  void swap(DDefaultFunction &);
};

class DFunction : public Declaration
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Type *type_;
  Ident ident_;
  ListParameterDeclaration *listparameterdeclaration_;
  ListStatement *liststatement_;

  DFunction(const DFunction &);
  DFunction &operator=(const DFunction &);
  DFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4, ListStatement *p5);
  ~DFunction();
  virtual void accept(Visitor *v);
  virtual  DFunction  *clone() const;
  void swap(DFunction &);
};

class DOperator : public Declaration
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Type *type_;
  OperatorName *operatorname_;
  ListParameterDeclaration *listparameterdeclaration_;
  ListStatement *liststatement_;

  DOperator(const DOperator &);
  DOperator &operator=(const DOperator &);
  DOperator(ListFunctionSpecifier *p1, Type *p2, OperatorName *p3, ListParameterDeclaration *p4, ListStatement *p5);
  ~DOperator();
  virtual void accept(Visitor *v);
  virtual  DOperator  *clone() const;
  void swap(DOperator &);
};

class DOperatorInfo : public Declaration
{
 public:
  OperatorTrait *operatortrait_;

  DOperatorInfo(const DOperatorInfo &);
  DOperatorInfo &operator=(const DOperatorInfo &);
  DOperatorInfo(OperatorTrait *p1);
  ~DOperatorInfo();
  virtual void accept(Visitor *v);
  virtual  DOperatorInfo  *clone() const;
  void swap(DOperatorInfo &);
};

class DTypeDecl : public Declaration
{
 public:
  ListTypeSpecifier *listtypespecifier_;
  Type *type_;
  Ident ident_;

  DTypeDecl(const DTypeDecl &);
  DTypeDecl &operator=(const DTypeDecl &);
  DTypeDecl(ListTypeSpecifier *p1, Type *p2, Ident p3);
  ~DTypeDecl();
  virtual void accept(Visitor *v);
  virtual  DTypeDecl  *clone() const;
  void swap(DTypeDecl &);
};

class DTypeConv : public Declaration
{
 public:
  Type *type_1, *type_2;
  ListConversionSpecifier *listconversionspecifier_;
  Ident ident_;
  ListStatement *liststatement_;

  DTypeConv(const DTypeConv &);
  DTypeConv &operator=(const DTypeConv &);
  DTypeConv(Type *p1, ListConversionSpecifier *p2, Type *p3, Ident p4, ListStatement *p5);
  ~DTypeConv();
  virtual void accept(Visitor *v);
  virtual  DTypeConv  *clone() const;
  void swap(DTypeConv &);
};

class DExtern : public Declaration
{
 public:
  Prototype *prototype_;

  DExtern(const DExtern &);
  DExtern &operator=(const DExtern &);
  DExtern(Prototype *p1);
  ~DExtern();
  virtual void accept(Visitor *v);
  virtual  DExtern  *clone() const;
  void swap(DExtern &);
};

class DIVariable : public Declaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;
  Expression *expression_;

  DIVariable(const DIVariable &);
  DIVariable &operator=(const DIVariable &);
  DIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4);
  ~DIVariable();
  virtual void accept(Visitor *v);
  virtual  DIVariable  *clone() const;
  void swap(DIVariable &);
};

class DVariable : public Declaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;

  DVariable(const DVariable &);
  DVariable &operator=(const DVariable &);
  DVariable(ListVariableSpecifier *p1, Type *p2, Ident p3);
  ~DVariable();
  virtual void accept(Visitor *v);
  virtual  DVariable  *clone() const;
  void swap(DVariable &);
};


class Prototype : public Visitable {
public:
  virtual Prototype *clone() const = 0;
};

class PFunction : public Prototype
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Type *type_;
  Ident ident_;
  ListParameterDeclaration *listparameterdeclaration_;

  PFunction(const PFunction &);
  PFunction &operator=(const PFunction &);
  PFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4);
  ~PFunction();
  virtual void accept(Visitor *v);
  virtual  PFunction  *clone() const;
  void swap(PFunction &);
};


class OperatorName : public Visitable {
public:
  virtual OperatorName *clone() const = 0;
};

class ONLnot : public OperatorName
{
 public:

  ONLnot(const ONLnot &);
  ONLnot &operator=(const ONLnot &);
  ONLnot();
  ~ONLnot();
  virtual void accept(Visitor *v);
  virtual  ONLnot  *clone() const;
  void swap(ONLnot &);
};

class ONPreInc : public OperatorName
{
 public:

  ONPreInc(const ONPreInc &);
  ONPreInc &operator=(const ONPreInc &);
  ONPreInc();
  ~ONPreInc();
  virtual void accept(Visitor *v);
  virtual  ONPreInc  *clone() const;
  void swap(ONPreInc &);
};

class ONPreDec : public OperatorName
{
 public:

  ONPreDec(const ONPreDec &);
  ONPreDec &operator=(const ONPreDec &);
  ONPreDec();
  ~ONPreDec();
  virtual void accept(Visitor *v);
  virtual  ONPreDec  *clone() const;
  void swap(ONPreDec &);
};

class ONBnot : public OperatorName
{
 public:

  ONBnot(const ONBnot &);
  ONBnot &operator=(const ONBnot &);
  ONBnot();
  ~ONBnot();
  virtual void accept(Visitor *v);
  virtual  ONBnot  *clone() const;
  void swap(ONBnot &);
};

class ONMul : public OperatorName
{
 public:

  ONMul(const ONMul &);
  ONMul &operator=(const ONMul &);
  ONMul();
  ~ONMul();
  virtual void accept(Visitor *v);
  virtual  ONMul  *clone() const;
  void swap(ONMul &);
};

class ONExp : public OperatorName
{
 public:

  ONExp(const ONExp &);
  ONExp &operator=(const ONExp &);
  ONExp();
  ~ONExp();
  virtual void accept(Visitor *v);
  virtual  ONExp  *clone() const;
  void swap(ONExp &);
};

class ONDiv : public OperatorName
{
 public:

  ONDiv(const ONDiv &);
  ONDiv &operator=(const ONDiv &);
  ONDiv();
  ~ONDiv();
  virtual void accept(Visitor *v);
  virtual  ONDiv  *clone() const;
  void swap(ONDiv &);
};

class ONRDiv : public OperatorName
{
 public:

  ONRDiv(const ONRDiv &);
  ONRDiv &operator=(const ONRDiv &);
  ONRDiv();
  ~ONRDiv();
  virtual void accept(Visitor *v);
  virtual  ONRDiv  *clone() const;
  void swap(ONRDiv &);
};

class ONMod : public OperatorName
{
 public:

  ONMod(const ONMod &);
  ONMod &operator=(const ONMod &);
  ONMod();
  ~ONMod();
  virtual void accept(Visitor *v);
  virtual  ONMod  *clone() const;
  void swap(ONMod &);
};

class ONAdd : public OperatorName
{
 public:

  ONAdd(const ONAdd &);
  ONAdd &operator=(const ONAdd &);
  ONAdd();
  ~ONAdd();
  virtual void accept(Visitor *v);
  virtual  ONAdd  *clone() const;
  void swap(ONAdd &);
};

class ONSub : public OperatorName
{
 public:

  ONSub(const ONSub &);
  ONSub &operator=(const ONSub &);
  ONSub();
  ~ONSub();
  virtual void accept(Visitor *v);
  virtual  ONSub  *clone() const;
  void swap(ONSub &);
};

class ONLSh : public OperatorName
{
 public:

  ONLSh(const ONLSh &);
  ONLSh &operator=(const ONLSh &);
  ONLSh();
  ~ONLSh();
  virtual void accept(Visitor *v);
  virtual  ONLSh  *clone() const;
  void swap(ONLSh &);
};

class ONRSh : public OperatorName
{
 public:

  ONRSh(const ONRSh &);
  ONRSh &operator=(const ONRSh &);
  ONRSh();
  ~ONRSh();
  virtual void accept(Visitor *v);
  virtual  ONRSh  *clone() const;
  void swap(ONRSh &);
};

class ONLT : public OperatorName
{
 public:

  ONLT(const ONLT &);
  ONLT &operator=(const ONLT &);
  ONLT();
  ~ONLT();
  virtual void accept(Visitor *v);
  virtual  ONLT  *clone() const;
  void swap(ONLT &);
};

class ONGT : public OperatorName
{
 public:

  ONGT(const ONGT &);
  ONGT &operator=(const ONGT &);
  ONGT();
  ~ONGT();
  virtual void accept(Visitor *v);
  virtual  ONGT  *clone() const;
  void swap(ONGT &);
};

class ONLE : public OperatorName
{
 public:

  ONLE(const ONLE &);
  ONLE &operator=(const ONLE &);
  ONLE();
  ~ONLE();
  virtual void accept(Visitor *v);
  virtual  ONLE  *clone() const;
  void swap(ONLE &);
};

class ONGE : public OperatorName
{
 public:

  ONGE(const ONGE &);
  ONGE &operator=(const ONGE &);
  ONGE();
  ~ONGE();
  virtual void accept(Visitor *v);
  virtual  ONGE  *clone() const;
  void swap(ONGE &);
};

class ONE : public OperatorName
{
 public:

  ONE(const ONE &);
  ONE &operator=(const ONE &);
  ONE();
  ~ONE();
  virtual void accept(Visitor *v);
  virtual  ONE  *clone() const;
  void swap(ONE &);
};

class ONNE : public OperatorName
{
 public:

  ONNE(const ONNE &);
  ONNE &operator=(const ONNE &);
  ONNE();
  ~ONNE();
  virtual void accept(Visitor *v);
  virtual  ONNE  *clone() const;
  void swap(ONNE &);
};

class ONBand : public OperatorName
{
 public:

  ONBand(const ONBand &);
  ONBand &operator=(const ONBand &);
  ONBand();
  ~ONBand();
  virtual void accept(Visitor *v);
  virtual  ONBand  *clone() const;
  void swap(ONBand &);
};

class ONBor : public OperatorName
{
 public:

  ONBor(const ONBor &);
  ONBor &operator=(const ONBor &);
  ONBor();
  ~ONBor();
  virtual void accept(Visitor *v);
  virtual  ONBor  *clone() const;
  void swap(ONBor &);
};

class ONBxor : public OperatorName
{
 public:

  ONBxor(const ONBxor &);
  ONBxor &operator=(const ONBxor &);
  ONBxor();
  ~ONBxor();
  virtual void accept(Visitor *v);
  virtual  ONBxor  *clone() const;
  void swap(ONBxor &);
};

class ONLand : public OperatorName
{
 public:

  ONLand(const ONLand &);
  ONLand &operator=(const ONLand &);
  ONLand();
  ~ONLand();
  virtual void accept(Visitor *v);
  virtual  ONLand  *clone() const;
  void swap(ONLand &);
};

class ONLor : public OperatorName
{
 public:

  ONLor(const ONLor &);
  ONLor &operator=(const ONLor &);
  ONLor();
  ~ONLor();
  virtual void accept(Visitor *v);
  virtual  ONLor  *clone() const;
  void swap(ONLor &);
};

class ONLxor : public OperatorName
{
 public:

  ONLxor(const ONLxor &);
  ONLxor &operator=(const ONLxor &);
  ONLxor();
  ~ONLxor();
  virtual void accept(Visitor *v);
  virtual  ONLxor  *clone() const;
  void swap(ONLxor &);
};

class ONRight : public OperatorName
{
 public:

  ONRight(const ONRight &);
  ONRight &operator=(const ONRight &);
  ONRight();
  ~ONRight();
  virtual void accept(Visitor *v);
  virtual  ONRight  *clone() const;
  void swap(ONRight &);
};

class ONLeft : public OperatorName
{
 public:

  ONLeft(const ONLeft &);
  ONLeft &operator=(const ONLeft &);
  ONLeft();
  ~ONLeft();
  virtual void accept(Visitor *v);
  virtual  ONLeft  *clone() const;
  void swap(ONLeft &);
};


class OperatorTrait : public Visitable {
public:
  virtual OperatorTrait *clone() const = 0;
};

class OTIdentity : public OperatorTrait
{
 public:
  Type *type_;
  OperatorName *operatorname_;
  Expression *expression_;

  OTIdentity(const OTIdentity &);
  OTIdentity &operator=(const OTIdentity &);
  OTIdentity(Type *p1, OperatorName *p2, Expression *p3);
  ~OTIdentity();
  virtual void accept(Visitor *v);
  virtual  OTIdentity  *clone() const;
  void swap(OTIdentity &);
};


class FunctionSpecifier : public Visitable {
public:
  virtual FunctionSpecifier *clone() const = 0;
};

class FSEntryPoint : public FunctionSpecifier
{
 public:

  FSEntryPoint(const FSEntryPoint &);
  FSEntryPoint &operator=(const FSEntryPoint &);
  FSEntryPoint();
  ~FSEntryPoint();
  virtual void accept(Visitor *v);
  virtual  FSEntryPoint  *clone() const;
  void swap(FSEntryPoint &);
};

class FSPure : public FunctionSpecifier
{
 public:

  FSPure(const FSPure &);
  FSPure &operator=(const FSPure &);
  FSPure();
  ~FSPure();
  virtual void accept(Visitor *v);
  virtual  FSPure  *clone() const;
  void swap(FSPure &);
};

class FSConst : public FunctionSpecifier
{
 public:

  FSConst(const FSConst &);
  FSConst &operator=(const FSConst &);
  FSConst();
  ~FSConst();
  virtual void accept(Visitor *v);
  virtual  FSConst  *clone() const;
  void swap(FSConst &);
};

class FSInline : public FunctionSpecifier
{
 public:

  FSInline(const FSInline &);
  FSInline &operator=(const FSInline &);
  FSInline();
  ~FSInline();
  virtual void accept(Visitor *v);
  virtual  FSInline  *clone() const;
  void swap(FSInline &);
};

class FSAssociative : public FunctionSpecifier
{
 public:

  FSAssociative(const FSAssociative &);
  FSAssociative &operator=(const FSAssociative &);
  FSAssociative();
  ~FSAssociative();
  virtual void accept(Visitor *v);
  virtual  FSAssociative  *clone() const;
  void swap(FSAssociative &);
};

class FSCommutative : public FunctionSpecifier
{
 public:

  FSCommutative(const FSCommutative &);
  FSCommutative &operator=(const FSCommutative &);
  FSCommutative();
  ~FSCommutative();
  virtual void accept(Visitor *v);
  virtual  FSCommutative  *clone() const;
  void swap(FSCommutative &);
};

class FSAntiCommutative : public FunctionSpecifier
{
 public:

  FSAntiCommutative(const FSAntiCommutative &);
  FSAntiCommutative &operator=(const FSAntiCommutative &);
  FSAntiCommutative();
  ~FSAntiCommutative();
  virtual void accept(Visitor *v);
  virtual  FSAntiCommutative  *clone() const;
  void swap(FSAntiCommutative &);
};

class FSInverse : public FunctionSpecifier
{
 public:
  OperatorName *operatorname_;

  FSInverse(const FSInverse &);
  FSInverse &operator=(const FSInverse &);
  FSInverse(OperatorName *p1);
  ~FSInverse();
  virtual void accept(Visitor *v);
  virtual  FSInverse  *clone() const;
  void swap(FSInverse &);
};

class FSSelfInverse : public FunctionSpecifier
{
 public:

  FSSelfInverse(const FSSelfInverse &);
  FSSelfInverse &operator=(const FSSelfInverse &);
  FSSelfInverse();
  ~FSSelfInverse();
  virtual void accept(Visitor *v);
  virtual  FSSelfInverse  *clone() const;
  void swap(FSSelfInverse &);
};


class ConversionSpecifier : public Visitable {
public:
  virtual ConversionSpecifier *clone() const = 0;
};

class CSUp : public ConversionSpecifier
{
 public:

  CSUp(const CSUp &);
  CSUp &operator=(const CSUp &);
  CSUp();
  ~CSUp();
  virtual void accept(Visitor *v);
  virtual  CSUp  *clone() const;
  void swap(CSUp &);
};

class CSDown : public ConversionSpecifier
{
 public:

  CSDown(const CSDown &);
  CSDown &operator=(const CSDown &);
  CSDown();
  ~CSDown();
  virtual void accept(Visitor *v);
  virtual  CSDown  *clone() const;
  void swap(CSDown &);
};

class CSImplicit : public ConversionSpecifier
{
 public:

  CSImplicit(const CSImplicit &);
  CSImplicit &operator=(const CSImplicit &);
  CSImplicit();
  ~CSImplicit();
  virtual void accept(Visitor *v);
  virtual  CSImplicit  *clone() const;
  void swap(CSImplicit &);
};


class VariableSpecifier : public Visitable {
public:
  virtual VariableSpecifier *clone() const = 0;
};

class VSConst : public VariableSpecifier
{
 public:

  VSConst(const VSConst &);
  VSConst &operator=(const VSConst &);
  VSConst();
  ~VSConst();
  virtual void accept(Visitor *v);
  virtual  VSConst  *clone() const;
  void swap(VSConst &);
};


class TypeSpecifier : public Visitable {
public:
  virtual TypeSpecifier *clone() const = 0;
};

class TSAlign : public TypeSpecifier
{
 public:
  Integer integer_;

  TSAlign(const TSAlign &);
  TSAlign &operator=(const TSAlign &);
  TSAlign(Integer p1);
  ~TSAlign();
  virtual void accept(Visitor *v);
  virtual  TSAlign  *clone() const;
  void swap(TSAlign &);
};

class TSGeneric : public TypeSpecifier
{
 public:
  ListGenericParam *listgenericparam_;

  TSGeneric(const TSGeneric &);
  TSGeneric &operator=(const TSGeneric &);
  TSGeneric(ListGenericParam *p1);
  ~TSGeneric();
  virtual void accept(Visitor *v);
  virtual  TSGeneric  *clone() const;
  void swap(TSGeneric &);
};

class TSInteger : public TypeSpecifier
{
 public:

  TSInteger(const TSInteger &);
  TSInteger &operator=(const TSInteger &);
  TSInteger();
  ~TSInteger();
  virtual void accept(Visitor *v);
  virtual  TSInteger  *clone() const;
  void swap(TSInteger &);
};

class TSReal : public TypeSpecifier
{
 public:

  TSReal(const TSReal &);
  TSReal &operator=(const TSReal &);
  TSReal();
  ~TSReal();
  virtual void accept(Visitor *v);
  virtual  TSReal  *clone() const;
  void swap(TSReal &);
};


class GenericParam : public Visitable {
public:
  virtual GenericParam *clone() const = 0;
};

class TSGParam : public GenericParam
{
 public:
  Type *type_;
  Ident ident_;

  TSGParam(const TSGParam &);
  TSGParam &operator=(const TSGParam &);
  TSGParam(Type *p1, Ident p2);
  ~TSGParam();
  virtual void accept(Visitor *v);
  virtual  TSGParam  *clone() const;
  void swap(TSGParam &);
};


class Type : public Visitable {
public:
  virtual Type *clone() const = 0;
};

class TAddress : public Type
{
 public:

  TAddress(const TAddress &);
  TAddress &operator=(const TAddress &);
  TAddress();
  ~TAddress();
  virtual void accept(Visitor *v);
  virtual  TAddress  *clone() const;
  void swap(TAddress &);
};

class TByte : public Type
{
 public:

  TByte(const TByte &);
  TByte &operator=(const TByte &);
  TByte();
  ~TByte();
  virtual void accept(Visitor *v);
  virtual  TByte  *clone() const;
  void swap(TByte &);
};

class TCustom : public Type
{
 public:
  Ident ident_;

  TCustom(const TCustom &);
  TCustom &operator=(const TCustom &);
  TCustom(Ident p1);
  ~TCustom();
  virtual void accept(Visitor *v);
  virtual  TCustom  *clone() const;
  void swap(TCustom &);
};

class TFixedArray : public Type
{
 public:
  Type *type_;
  Integer integer_;

  TFixedArray(const TFixedArray &);
  TFixedArray &operator=(const TFixedArray &);
  TFixedArray(Type *p1, Integer p2);
  ~TFixedArray();
  virtual void accept(Visitor *v);
  virtual  TFixedArray  *clone() const;
  void swap(TFixedArray &);
};

class TGenericArray : public Type
{
 public:
  Type *type_;

  TGenericArray(const TGenericArray &);
  TGenericArray &operator=(const TGenericArray &);
  TGenericArray(Type *p1);
  ~TGenericArray();
  virtual void accept(Visitor *v);
  virtual  TGenericArray  *clone() const;
  void swap(TGenericArray &);
};

class TStruct : public Type
{
 public:
  ListStructMemberDeclaration *liststructmemberdeclaration_;

  TStruct(const TStruct &);
  TStruct &operator=(const TStruct &);
  TStruct(ListStructMemberDeclaration *p1);
  ~TStruct();
  virtual void accept(Visitor *v);
  virtual  TStruct  *clone() const;
  void swap(TStruct &);
};

class TType : public Type
{
 public:

  TType(const TType &);
  TType &operator=(const TType &);
  TType();
  ~TType();
  virtual void accept(Visitor *v);
  virtual  TType  *clone() const;
  void swap(TType &);
};


class StructMemberDeclaration : public Visitable {
public:
  virtual StructMemberDeclaration *clone() const = 0;
};

class SMDMemberDeclaration : public StructMemberDeclaration
{
 public:
  Type *type_;
  Ident ident_;

  SMDMemberDeclaration(const SMDMemberDeclaration &);
  SMDMemberDeclaration &operator=(const SMDMemberDeclaration &);
  SMDMemberDeclaration(Type *p1, Ident p2);
  ~SMDMemberDeclaration();
  virtual void accept(Visitor *v);
  virtual  SMDMemberDeclaration  *clone() const;
  void swap(SMDMemberDeclaration &);
};


class ParameterDeclaration : public Visitable {
public:
  virtual ParameterDeclaration *clone() const = 0;
};

class PDAutoParameter : public ParameterDeclaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Ident ident_;

  PDAutoParameter(const PDAutoParameter &);
  PDAutoParameter &operator=(const PDAutoParameter &);
  PDAutoParameter(ListVariableSpecifier *p1, Ident p2);
  ~PDAutoParameter();
  virtual void accept(Visitor *v);
  virtual  PDAutoParameter  *clone() const;
  void swap(PDAutoParameter &);
};

class PDTypedParameter : public ParameterDeclaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;

  PDTypedParameter(const PDTypedParameter &);
  PDTypedParameter &operator=(const PDTypedParameter &);
  PDTypedParameter(ListVariableSpecifier *p1, Type *p2, Ident p3);
  ~PDTypedParameter();
  virtual void accept(Visitor *v);
  virtual  PDTypedParameter  *clone() const;
  void swap(PDTypedParameter &);
};


class Statement : public Visitable {
public:
  virtual Statement *clone() const = 0;
};

class SReturn : public Statement
{
 public:
  Expression *expression_;

  SReturn(const SReturn &);
  SReturn &operator=(const SReturn &);
  SReturn(Expression *p1);
  ~SReturn();
  virtual void accept(Visitor *v);
  virtual  SReturn  *clone() const;
  void swap(SReturn &);
};

class SExpression : public Statement
{
 public:
  Expression *expression_;

  SExpression(const SExpression &);
  SExpression &operator=(const SExpression &);
  SExpression(Expression *p1);
  ~SExpression();
  virtual void accept(Visitor *v);
  virtual  SExpression  *clone() const;
  void swap(SExpression &);
};

class SScope : public Statement
{
 public:
  ListStatement *liststatement_;

  SScope(const SScope &);
  SScope &operator=(const SScope &);
  SScope(ListStatement *p1);
  ~SScope();
  virtual void accept(Visitor *v);
  virtual  SScope  *clone() const;
  void swap(SScope &);
};

class SIf : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Expression *p1, ListStatement *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual  SIf  *clone() const;
  void swap(SIf &);
};

class SIfElse : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_1, *liststatement_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Expression *p1, ListStatement *p2, ListStatement *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual  SIfElse  *clone() const;
  void swap(SIfElse &);
};

class SLoop : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SLoop(const SLoop &);
  SLoop &operator=(const SLoop &);
  SLoop(Expression *p1, ListStatement *p2);
  ~SLoop();
  virtual void accept(Visitor *v);
  virtual  SLoop  *clone() const;
  void swap(SLoop &);
};

class SWhile : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Expression *p1, ListStatement *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual  SWhile  *clone() const;
  void swap(SWhile &);
};

class SUntil : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SUntil(const SUntil &);
  SUntil &operator=(const SUntil &);
  SUntil(Expression *p1, ListStatement *p2);
  ~SUntil();
  virtual void accept(Visitor *v);
  virtual  SUntil  *clone() const;
  void swap(SUntil &);
};

class SFor : public Statement
{
 public:
  ListExpression *listexpression_1, *listexpression_2;
  Expression *expression_;
  ListStatement *liststatement_;

  SFor(const SFor &);
  SFor &operator=(const SFor &);
  SFor(ListExpression *p1, Expression *p2, ListExpression *p3, ListStatement *p4);
  ~SFor();
  virtual void accept(Visitor *v);
  virtual  SFor  *clone() const;
  void swap(SFor &);
};

class SForEach : public Statement
{
 public:
  Ident ident_;
  Expression *expression_;
  ListStatement *liststatement_;

  SForEach(const SForEach &);
  SForEach &operator=(const SForEach &);
  SForEach(Ident p1, Expression *p2, ListStatement *p3);
  ~SForEach();
  virtual void accept(Visitor *v);
  virtual  SForEach  *clone() const;
  void swap(SForEach &);
};

class SForAll : public Statement
{
 public:
  Ident ident_;
  Expression *expression_;
  ListStatement *liststatement_;

  SForAll(const SForAll &);
  SForAll &operator=(const SForAll &);
  SForAll(Ident p1, Expression *p2, ListStatement *p3);
  ~SForAll();
  virtual void accept(Visitor *v);
  virtual  SForAll  *clone() const;
  void swap(SForAll &);
};

class SBreak : public Statement
{
 public:

  SBreak(const SBreak &);
  SBreak &operator=(const SBreak &);
  SBreak();
  ~SBreak();
  virtual void accept(Visitor *v);
  virtual  SBreak  *clone() const;
  void swap(SBreak &);
};

class SContinue : public Statement
{
 public:

  SContinue(const SContinue &);
  SContinue &operator=(const SContinue &);
  SContinue();
  ~SContinue();
  virtual void accept(Visitor *v);
  virtual  SContinue  *clone() const;
  void swap(SContinue &);
};

class SBreakpoint : public Statement
{
 public:

  SBreakpoint(const SBreakpoint &);
  SBreakpoint &operator=(const SBreakpoint &);
  SBreakpoint();
  ~SBreakpoint();
  virtual void accept(Visitor *v);
  virtual  SBreakpoint  *clone() const;
  void swap(SBreakpoint &);
};

class SIVariable : public Statement
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;
  Expression *expression_;

  SIVariable(const SIVariable &);
  SIVariable &operator=(const SIVariable &);
  SIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4);
  ~SIVariable();
  virtual void accept(Visitor *v);
  virtual  SIVariable  *clone() const;
  void swap(SIVariable &);
};

class SVariable : public Statement
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;

  SVariable(const SVariable &);
  SVariable &operator=(const SVariable &);
  SVariable(ListVariableSpecifier *p1, Type *p2, Ident p3);
  ~SVariable();
  virtual void accept(Visitor *v);
  virtual  SVariable  *clone() const;
  void swap(SVariable &);
};


class RValue : public Visitable {
public:
  virtual RValue *clone() const = 0;
};

class RVIdent : public RValue
{
 public:
  Ident ident_;

  RVIdent(const RVIdent &);
  RVIdent &operator=(const RVIdent &);
  RVIdent(Ident p1);
  ~RVIdent();
  virtual void accept(Visitor *v);
  virtual  RVIdent  *clone() const;
  void swap(RVIdent &);
};

class RVQualified : public RValue
{
 public:
  Ident ident_;
  RValue *rvalue_;

  RVQualified(const RVQualified &);
  RVQualified &operator=(const RVQualified &);
  RVQualified(Ident p1, RValue *p2);
  ~RVQualified();
  virtual void accept(Visitor *v);
  virtual  RVQualified  *clone() const;
  void swap(RVQualified &);
};


class Expression : public Visitable {
public:
  virtual Expression *clone() const = 0;
};

class EDouble : public Expression
{
 public:
  Double double_;

  EDouble(const EDouble &);
  EDouble &operator=(const EDouble &);
  EDouble(Double p1);
  ~EDouble();
  virtual void accept(Visitor *v);
  virtual  EDouble  *clone() const;
  void swap(EDouble &);
};

class EInteger : public Expression
{
 public:
  Integer integer_;

  EInteger(const EInteger &);
  EInteger &operator=(const EInteger &);
  EInteger(Integer p1);
  ~EInteger();
  virtual void accept(Visitor *v);
  virtual  EInteger  *clone() const;
  void swap(EInteger &);
};

class EString : public Expression
{
 public:
  CString cstring_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(CString p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual  EString  *clone() const;
  void swap(EString &);
};

class EChar : public Expression
{
 public:
  CChar cchar_;

  EChar(const EChar &);
  EChar &operator=(const EChar &);
  EChar(CChar p1);
  ~EChar();
  virtual void accept(Visitor *v);
  virtual  EChar  *clone() const;
  void swap(EChar &);
};

class EPi : public Expression
{
 public:

  EPi(const EPi &);
  EPi &operator=(const EPi &);
  EPi();
  ~EPi();
  virtual void accept(Visitor *v);
  virtual  EPi  *clone() const;
  void swap(EPi &);
};

class ERValue : public Expression
{
 public:
  RValue *rvalue_;

  ERValue(const ERValue &);
  ERValue &operator=(const ERValue &);
  ERValue(RValue *p1);
  ~ERValue();
  virtual void accept(Visitor *v);
  virtual  ERValue  *clone() const;
  void swap(ERValue &);
};

class EArray : public Expression
{
 public:
  ListExpression *listexpression_;

  EArray(const EArray &);
  EArray &operator=(const EArray &);
  EArray(ListExpression *p1);
  ~EArray();
  virtual void accept(Visitor *v);
  virtual  EArray  *clone() const;
  void swap(EArray &);
};

class EList : public Expression
{
 public:
  ListExpression *listexpression_;

  EList(const EList &);
  EList &operator=(const EList &);
  EList(ListExpression *p1);
  ~EList();
  virtual void accept(Visitor *v);
  virtual  EList  *clone() const;
  void swap(EList &);
};

class EAComp : public Expression
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  EAComp(const EAComp &);
  EAComp &operator=(const EAComp &);
  EAComp(Expression *p1, ListExpression *p2);
  ~EAComp();
  virtual void accept(Visitor *v);
  virtual  EAComp  *clone() const;
  void swap(EAComp &);
};

class ELComp : public Expression
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  ELComp(const ELComp &);
  ELComp &operator=(const ELComp &);
  ELComp(Expression *p1, ListExpression *p2);
  ~ELComp();
  virtual void accept(Visitor *v);
  virtual  ELComp  *clone() const;
  void swap(ELComp &);
};

class EIndex : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIndex(const EIndex &);
  EIndex &operator=(const EIndex &);
  EIndex(Expression *p1, Expression *p2);
  ~EIndex();
  virtual void accept(Visitor *v);
  virtual  EIndex  *clone() const;
  void swap(EIndex &);
};

class ESimpleCall : public Expression
{
 public:
  RValue *rvalue_;

  ESimpleCall(const ESimpleCall &);
  ESimpleCall &operator=(const ESimpleCall &);
  ESimpleCall(RValue *p1);
  ~ESimpleCall();
  virtual void accept(Visitor *v);
  virtual  ESimpleCall  *clone() const;
  void swap(ESimpleCall &);
};

class ECall : public Expression
{
 public:
  RValue *rvalue_;
  ListExpression *listexpression_;

  ECall(const ECall &);
  ECall &operator=(const ECall &);
  ECall(RValue *p1, ListExpression *p2);
  ~ECall();
  virtual void accept(Visitor *v);
  virtual  ECall  *clone() const;
  void swap(ECall &);
};

class EPostInc : public Expression
{
 public:
  RValue *rvalue_;

  EPostInc(const EPostInc &);
  EPostInc &operator=(const EPostInc &);
  EPostInc(RValue *p1);
  ~EPostInc();
  virtual void accept(Visitor *v);
  virtual  EPostInc  *clone() const;
  void swap(EPostInc &);
};

class EPostDec : public Expression
{
 public:
  RValue *rvalue_;

  EPostDec(const EPostDec &);
  EPostDec &operator=(const EPostDec &);
  EPostDec(RValue *p1);
  ~EPostDec();
  virtual void accept(Visitor *v);
  virtual  EPostDec  *clone() const;
  void swap(EPostDec &);
};

class EAddress : public Expression
{
 public:
  Expression *expression_;

  EAddress(const EAddress &);
  EAddress &operator=(const EAddress &);
  EAddress(Expression *p1);
  ~EAddress();
  virtual void accept(Visitor *v);
  virtual  EAddress  *clone() const;
  void swap(EAddress &);
};

class EIntrinSExt : public Expression
{
 public:
  Type *type_;
  Expression *expression_;

  EIntrinSExt(const EIntrinSExt &);
  EIntrinSExt &operator=(const EIntrinSExt &);
  EIntrinSExt(Type *p1, Expression *p2);
  ~EIntrinSExt();
  virtual void accept(Visitor *v);
  virtual  EIntrinSExt  *clone() const;
  void swap(EIntrinSExt &);
};

class EIntrinZExt : public Expression
{
 public:
  Type *type_;
  Expression *expression_;

  EIntrinZExt(const EIntrinZExt &);
  EIntrinZExt &operator=(const EIntrinZExt &);
  EIntrinZExt(Type *p1, Expression *p2);
  ~EIntrinZExt();
  virtual void accept(Visitor *v);
  virtual  EIntrinZExt  *clone() const;
  void swap(EIntrinZExt &);
};

class EIntrinAddI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinAddI(const EIntrinAddI &);
  EIntrinAddI &operator=(const EIntrinAddI &);
  EIntrinAddI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinAddI();
  virtual void accept(Visitor *v);
  virtual  EIntrinAddI  *clone() const;
  void swap(EIntrinAddI &);
};

class EIntrinSubI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinSubI(const EIntrinSubI &);
  EIntrinSubI &operator=(const EIntrinSubI &);
  EIntrinSubI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinSubI();
  virtual void accept(Visitor *v);
  virtual  EIntrinSubI  *clone() const;
  void swap(EIntrinSubI &);
};

class EIntrinMulI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinMulI(const EIntrinMulI &);
  EIntrinMulI &operator=(const EIntrinMulI &);
  EIntrinMulI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinMulI();
  virtual void accept(Visitor *v);
  virtual  EIntrinMulI  *clone() const;
  void swap(EIntrinMulI &);
};

class EIntrinUdivI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinUdivI(const EIntrinUdivI &);
  EIntrinUdivI &operator=(const EIntrinUdivI &);
  EIntrinUdivI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinUdivI();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdivI  *clone() const;
  void swap(EIntrinUdivI &);
};

class EIntrinSdivI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinSdivI(const EIntrinSdivI &);
  EIntrinSdivI &operator=(const EIntrinSdivI &);
  EIntrinSdivI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinSdivI();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdivI  *clone() const;
  void swap(EIntrinSdivI &);
};

class EIntrinUremI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinUremI(const EIntrinUremI &);
  EIntrinUremI &operator=(const EIntrinUremI &);
  EIntrinUremI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinUremI();
  virtual void accept(Visitor *v);
  virtual  EIntrinUremI  *clone() const;
  void swap(EIntrinUremI &);
};

class EIntrinSremI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinSremI(const EIntrinSremI &);
  EIntrinSremI &operator=(const EIntrinSremI &);
  EIntrinSremI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinSremI();
  virtual void accept(Visitor *v);
  virtual  EIntrinSremI  *clone() const;
  void swap(EIntrinSremI &);
};

class EIntrinAndI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinAndI(const EIntrinAndI &);
  EIntrinAndI &operator=(const EIntrinAndI &);
  EIntrinAndI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinAndI();
  virtual void accept(Visitor *v);
  virtual  EIntrinAndI  *clone() const;
  void swap(EIntrinAndI &);
};

class EIntrinOrI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinOrI(const EIntrinOrI &);
  EIntrinOrI &operator=(const EIntrinOrI &);
  EIntrinOrI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinOrI();
  virtual void accept(Visitor *v);
  virtual  EIntrinOrI  *clone() const;
  void swap(EIntrinOrI &);
};

class EIntrinXorI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinXorI(const EIntrinXorI &);
  EIntrinXorI &operator=(const EIntrinXorI &);
  EIntrinXorI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinXorI();
  virtual void accept(Visitor *v);
  virtual  EIntrinXorI  *clone() const;
  void swap(EIntrinXorI &);
};

class EIntrinShlI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinShlI(const EIntrinShlI &);
  EIntrinShlI &operator=(const EIntrinShlI &);
  EIntrinShlI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinShlI();
  virtual void accept(Visitor *v);
  virtual  EIntrinShlI  *clone() const;
  void swap(EIntrinShlI &);
};

class EIntrinLshrI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinLshrI(const EIntrinLshrI &);
  EIntrinLshrI &operator=(const EIntrinLshrI &);
  EIntrinLshrI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinLshrI();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshrI  *clone() const;
  void swap(EIntrinLshrI &);
};

class EIntrinAshrI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinAshrI(const EIntrinAshrI &);
  EIntrinAshrI &operator=(const EIntrinAshrI &);
  EIntrinAshrI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinAshrI();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshrI  *clone() const;
  void swap(EIntrinAshrI &);
};

class EIntrinNotI : public Expression
{
 public:
  Type *type_;
  Expression *expression_;

  EIntrinNotI(const EIntrinNotI &);
  EIntrinNotI &operator=(const EIntrinNotI &);
  EIntrinNotI(Type *p1, Expression *p2);
  ~EIntrinNotI();
  virtual void accept(Visitor *v);
  virtual  EIntrinNotI  *clone() const;
  void swap(EIntrinNotI &);
};

class EIntrinNegI : public Expression
{
 public:
  Type *type_;
  Expression *expression_;

  EIntrinNegI(const EIntrinNegI &);
  EIntrinNegI &operator=(const EIntrinNegI &);
  EIntrinNegI(Type *p1, Expression *p2);
  ~EIntrinNegI();
  virtual void accept(Visitor *v);
  virtual  EIntrinNegI  *clone() const;
  void swap(EIntrinNegI &);
};

class EIntrinCEqI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinCEqI(const EIntrinCEqI &);
  EIntrinCEqI &operator=(const EIntrinCEqI &);
  EIntrinCEqI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinCEqI();
  virtual void accept(Visitor *v);
  virtual  EIntrinCEqI  *clone() const;
  void swap(EIntrinCEqI &);
};

class EIntrinCNeI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinCNeI(const EIntrinCNeI &);
  EIntrinCNeI &operator=(const EIntrinCNeI &);
  EIntrinCNeI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinCNeI();
  virtual void accept(Visitor *v);
  virtual  EIntrinCNeI  *clone() const;
  void swap(EIntrinCNeI &);
};

class EIntrinCLtI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinCLtI(const EIntrinCLtI &);
  EIntrinCLtI &operator=(const EIntrinCLtI &);
  EIntrinCLtI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinCLtI();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLtI  *clone() const;
  void swap(EIntrinCLtI &);
};

class EIntrinCGtI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinCGtI(const EIntrinCGtI &);
  EIntrinCGtI &operator=(const EIntrinCGtI &);
  EIntrinCGtI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinCGtI();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGtI  *clone() const;
  void swap(EIntrinCGtI &);
};

class EIntrinCLeI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinCLeI(const EIntrinCLeI &);
  EIntrinCLeI &operator=(const EIntrinCLeI &);
  EIntrinCLeI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinCLeI();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLeI  *clone() const;
  void swap(EIntrinCLeI &);
};

class EIntrinCGeI : public Expression
{
 public:
  Type *type_;
  Expression *expression_1, *expression_2;

  EIntrinCGeI(const EIntrinCGeI &);
  EIntrinCGeI &operator=(const EIntrinCGeI &);
  EIntrinCGeI(Type *p1, Expression *p2, Expression *p3);
  ~EIntrinCGeI();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGeI  *clone() const;
  void swap(EIntrinCGeI &);
};

class ELnot : public Expression
{
 public:
  Expression *expression_;

  ELnot(const ELnot &);
  ELnot &operator=(const ELnot &);
  ELnot(Expression *p1);
  ~ELnot();
  virtual void accept(Visitor *v);
  virtual  ELnot  *clone() const;
  void swap(ELnot &);
};

class EPreInc : public Expression
{
 public:
  RValue *rvalue_;

  EPreInc(const EPreInc &);
  EPreInc &operator=(const EPreInc &);
  EPreInc(RValue *p1);
  ~EPreInc();
  virtual void accept(Visitor *v);
  virtual  EPreInc  *clone() const;
  void swap(EPreInc &);
};

class EPreDec : public Expression
{
 public:
  RValue *rvalue_;

  EPreDec(const EPreDec &);
  EPreDec &operator=(const EPreDec &);
  EPreDec(RValue *p1);
  ~EPreDec();
  virtual void accept(Visitor *v);
  virtual  EPreDec  *clone() const;
  void swap(EPreDec &);
};

class ENeg : public Expression
{
 public:
  Expression *expression_;

  ENeg(const ENeg &);
  ENeg &operator=(const ENeg &);
  ENeg(Expression *p1);
  ~ENeg();
  virtual void accept(Visitor *v);
  virtual  ENeg  *clone() const;
  void swap(ENeg &);
};

class EBnot : public Expression
{
 public:
  Expression *expression_;

  EBnot(const EBnot &);
  EBnot &operator=(const EBnot &);
  EBnot(Expression *p1);
  ~EBnot();
  virtual void accept(Visitor *v);
  virtual  EBnot  *clone() const;
  void swap(EBnot &);
};

class EPos : public Expression
{
 public:
  Expression *expression_;

  EPos(const EPos &);
  EPos &operator=(const EPos &);
  EPos(Expression *p1);
  ~EPos();
  virtual void accept(Visitor *v);
  virtual  EPos  *clone() const;
  void swap(EPos &);
};

class EMul : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Expression *p1, Expression *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual  EMul  *clone() const;
  void swap(EMul &);
};

class EDiv : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Expression *p1, Expression *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual  EDiv  *clone() const;
  void swap(EDiv &);
};

class EMod : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EMod(const EMod &);
  EMod &operator=(const EMod &);
  EMod(Expression *p1, Expression *p2);
  ~EMod();
  virtual void accept(Visitor *v);
  virtual  EMod  *clone() const;
  void swap(EMod &);
};

class EAdd : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Expression *p1, Expression *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual  EAdd  *clone() const;
  void swap(EAdd &);
};

class ESub : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Expression *p1, Expression *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual  ESub  *clone() const;
  void swap(ESub &);
};

class ELSh : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELSh(const ELSh &);
  ELSh &operator=(const ELSh &);
  ELSh(Expression *p1, Expression *p2);
  ~ELSh();
  virtual void accept(Visitor *v);
  virtual  ELSh  *clone() const;
  void swap(ELSh &);
};

class ERSh : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ERSh(const ERSh &);
  ERSh &operator=(const ERSh &);
  ERSh(Expression *p1, Expression *p2);
  ~ERSh();
  virtual void accept(Visitor *v);
  virtual  ERSh  *clone() const;
  void swap(ERSh &);
};

class ELT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELT(const ELT &);
  ELT &operator=(const ELT &);
  ELT(Expression *p1, Expression *p2);
  ~ELT();
  virtual void accept(Visitor *v);
  virtual  ELT  *clone() const;
  void swap(ELT &);
};

class EGT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EGT(const EGT &);
  EGT &operator=(const EGT &);
  EGT(Expression *p1, Expression *p2);
  ~EGT();
  virtual void accept(Visitor *v);
  virtual  EGT  *clone() const;
  void swap(EGT &);
};

class ELE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELE(const ELE &);
  ELE &operator=(const ELE &);
  ELE(Expression *p1, Expression *p2);
  ~ELE();
  virtual void accept(Visitor *v);
  virtual  ELE  *clone() const;
  void swap(ELE &);
};

class EGE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EGE(const EGE &);
  EGE &operator=(const EGE &);
  EGE(Expression *p1, Expression *p2);
  ~EGE();
  virtual void accept(Visitor *v);
  virtual  EGE  *clone() const;
  void swap(EGE &);
};

class EE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EE(const EE &);
  EE &operator=(const EE &);
  EE(Expression *p1, Expression *p2);
  ~EE();
  virtual void accept(Visitor *v);
  virtual  EE  *clone() const;
  void swap(EE &);
};

class ENE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ENE(const ENE &);
  ENE &operator=(const ENE &);
  ENE(Expression *p1, Expression *p2);
  ~ENE();
  virtual void accept(Visitor *v);
  virtual  ENE  *clone() const;
  void swap(ENE &);
};

class EBand : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBand(const EBand &);
  EBand &operator=(const EBand &);
  EBand(Expression *p1, Expression *p2);
  ~EBand();
  virtual void accept(Visitor *v);
  virtual  EBand  *clone() const;
  void swap(EBand &);
};

class EBor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBor(const EBor &);
  EBor &operator=(const EBor &);
  EBor(Expression *p1, Expression *p2);
  ~EBor();
  virtual void accept(Visitor *v);
  virtual  EBor  *clone() const;
  void swap(EBor &);
};

class EBxor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBxor(const EBxor &);
  EBxor &operator=(const EBxor &);
  EBxor(Expression *p1, Expression *p2);
  ~EBxor();
  virtual void accept(Visitor *v);
  virtual  EBxor  *clone() const;
  void swap(EBxor &);
};

class ELand : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELand(const ELand &);
  ELand &operator=(const ELand &);
  ELand(Expression *p1, Expression *p2);
  ~ELand();
  virtual void accept(Visitor *v);
  virtual  ELand  *clone() const;
  void swap(ELand &);
};

class ELor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELor(const ELor &);
  ELor &operator=(const ELor &);
  ELor(Expression *p1, Expression *p2);
  ~ELor();
  virtual void accept(Visitor *v);
  virtual  ELor  *clone() const;
  void swap(ELor &);
};

class ELxor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELxor(const ELxor &);
  ELxor &operator=(const ELxor &);
  ELxor(Expression *p1, Expression *p2);
  ~ELxor();
  virtual void accept(Visitor *v);
  virtual  ELxor  *clone() const;
  void swap(ELxor &);
};

class EConditional : public Expression
{
 public:
  Expression *expression_1, *expression_2, *expression_3;

  EConditional(const EConditional &);
  EConditional &operator=(const EConditional &);
  EConditional(Expression *p1, Expression *p2, Expression *p3);
  ~EConditional();
  virtual void accept(Visitor *v);
  virtual  EConditional  *clone() const;
  void swap(EConditional &);
};

class EAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EAssign(const EAssign &);
  EAssign &operator=(const EAssign &);
  EAssign(RValue *p1, Expression *p2);
  ~EAssign();
  virtual void accept(Visitor *v);
  virtual  EAssign  *clone() const;
  void swap(EAssign &);
};

class EAddAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EAddAssign(const EAddAssign &);
  EAddAssign &operator=(const EAddAssign &);
  EAddAssign(RValue *p1, Expression *p2);
  ~EAddAssign();
  virtual void accept(Visitor *v);
  virtual  EAddAssign  *clone() const;
  void swap(EAddAssign &);
};

class ESubAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  ESubAssign(const ESubAssign &);
  ESubAssign &operator=(const ESubAssign &);
  ESubAssign(RValue *p1, Expression *p2);
  ~ESubAssign();
  virtual void accept(Visitor *v);
  virtual  ESubAssign  *clone() const;
  void swap(ESubAssign &);
};

class EMulAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EMulAssign(const EMulAssign &);
  EMulAssign &operator=(const EMulAssign &);
  EMulAssign(RValue *p1, Expression *p2);
  ~EMulAssign();
  virtual void accept(Visitor *v);
  virtual  EMulAssign  *clone() const;
  void swap(EMulAssign &);
};

class EDivAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EDivAssign(const EDivAssign &);
  EDivAssign &operator=(const EDivAssign &);
  EDivAssign(RValue *p1, Expression *p2);
  ~EDivAssign();
  virtual void accept(Visitor *v);
  virtual  EDivAssign  *clone() const;
  void swap(EDivAssign &);
};

class EModAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EModAssign(const EModAssign &);
  EModAssign &operator=(const EModAssign &);
  EModAssign(RValue *p1, Expression *p2);
  ~EModAssign();
  virtual void accept(Visitor *v);
  virtual  EModAssign  *clone() const;
  void swap(EModAssign &);
};

class EAndAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EAndAssign(const EAndAssign &);
  EAndAssign &operator=(const EAndAssign &);
  EAndAssign(RValue *p1, Expression *p2);
  ~EAndAssign();
  virtual void accept(Visitor *v);
  virtual  EAndAssign  *clone() const;
  void swap(EAndAssign &);
};

class EOrAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EOrAssign(const EOrAssign &);
  EOrAssign &operator=(const EOrAssign &);
  EOrAssign(RValue *p1, Expression *p2);
  ~EOrAssign();
  virtual void accept(Visitor *v);
  virtual  EOrAssign  *clone() const;
  void swap(EOrAssign &);
};

class EXorAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EXorAssign(const EXorAssign &);
  EXorAssign &operator=(const EXorAssign &);
  EXorAssign(RValue *p1, Expression *p2);
  ~EXorAssign();
  virtual void accept(Visitor *v);
  virtual  EXorAssign  *clone() const;
  void swap(EXorAssign &);
};

class ELShAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  ELShAssign(const ELShAssign &);
  ELShAssign &operator=(const ELShAssign &);
  ELShAssign(RValue *p1, Expression *p2);
  ~ELShAssign();
  virtual void accept(Visitor *v);
  virtual  ELShAssign  *clone() const;
  void swap(ELShAssign &);
};

class ERShAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  ERShAssign(const ERShAssign &);
  ERShAssign &operator=(const ERShAssign &);
  ERShAssign(RValue *p1, Expression *p2);
  ~ERShAssign();
  virtual void accept(Visitor *v);
  virtual  ERShAssign  *clone() const;
  void swap(ERShAssign &);
};


class ListTLDeclaration : public Visitable
{
 public:
  TLDeclaration *tldeclaration_;
  ListTLDeclaration *listtldeclaration_;

  ListTLDeclaration(const ListTLDeclaration &);
  ListTLDeclaration &operator=(const ListTLDeclaration &);
  ListTLDeclaration(TLDeclaration *p1, ListTLDeclaration *p2);
  ListTLDeclaration(TLDeclaration *p);
  ~ListTLDeclaration();
  ListTLDeclaration* reverse();
  ListTLDeclaration* reverse(ListTLDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListTLDeclaration *clone() const;
  void swap(ListTLDeclaration &);
};
class ListDeclaration : public Visitable
{
 public:
  Declaration *declaration_;
  ListDeclaration *listdeclaration_;

  ListDeclaration(const ListDeclaration &);
  ListDeclaration &operator=(const ListDeclaration &);
  ListDeclaration(Declaration *p1, ListDeclaration *p2);
  ListDeclaration(Declaration *p);
  ~ListDeclaration();
  ListDeclaration* reverse();
  ListDeclaration* reverse(ListDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListDeclaration *clone() const;
  void swap(ListDeclaration &);
};
class ListStatement : public Visitable
{
 public:
  Statement *statement_;
  ListStatement *liststatement_;

  ListStatement(const ListStatement &);
  ListStatement &operator=(const ListStatement &);
  ListStatement(Statement *p1, ListStatement *p2);
  ListStatement(Statement *p);
  ~ListStatement();
  ListStatement* reverse();
  ListStatement* reverse(ListStatement *l);
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
  void swap(ListStatement &);
};
class ListTypeSpecifier : public Visitable
{
 public:
  TypeSpecifier *typespecifier_;
  ListTypeSpecifier *listtypespecifier_;

  ListTypeSpecifier(const ListTypeSpecifier &);
  ListTypeSpecifier &operator=(const ListTypeSpecifier &);
  ListTypeSpecifier(TypeSpecifier *p1, ListTypeSpecifier *p2);
  ListTypeSpecifier(TypeSpecifier *p);
  ~ListTypeSpecifier();
  ListTypeSpecifier* reverse();
  ListTypeSpecifier* reverse(ListTypeSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListTypeSpecifier *clone() const;
  void swap(ListTypeSpecifier &);
};
class ListConversionSpecifier : public Visitable
{
 public:
  ConversionSpecifier *conversionspecifier_;
  ListConversionSpecifier *listconversionspecifier_;

  ListConversionSpecifier(const ListConversionSpecifier &);
  ListConversionSpecifier &operator=(const ListConversionSpecifier &);
  ListConversionSpecifier(ConversionSpecifier *p1, ListConversionSpecifier *p2);
  ListConversionSpecifier(ConversionSpecifier *p);
  ~ListConversionSpecifier();
  ListConversionSpecifier* reverse();
  ListConversionSpecifier* reverse(ListConversionSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListConversionSpecifier *clone() const;
  void swap(ListConversionSpecifier &);
};
class ListFunctionSpecifier : public Visitable
{
 public:
  FunctionSpecifier *functionspecifier_;
  ListFunctionSpecifier *listfunctionspecifier_;

  ListFunctionSpecifier(const ListFunctionSpecifier &);
  ListFunctionSpecifier &operator=(const ListFunctionSpecifier &);
  ListFunctionSpecifier(FunctionSpecifier *p1, ListFunctionSpecifier *p2);
  ListFunctionSpecifier(FunctionSpecifier *p);
  ~ListFunctionSpecifier();
  ListFunctionSpecifier* reverse();
  ListFunctionSpecifier* reverse(ListFunctionSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListFunctionSpecifier *clone() const;
  void swap(ListFunctionSpecifier &);
};
class ListVariableSpecifier : public Visitable
{
 public:
  VariableSpecifier *variablespecifier_;
  ListVariableSpecifier *listvariablespecifier_;

  ListVariableSpecifier(const ListVariableSpecifier &);
  ListVariableSpecifier &operator=(const ListVariableSpecifier &);
  ListVariableSpecifier(VariableSpecifier *p1, ListVariableSpecifier *p2);
  ListVariableSpecifier(VariableSpecifier *p);
  ~ListVariableSpecifier();
  ListVariableSpecifier* reverse();
  ListVariableSpecifier* reverse(ListVariableSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListVariableSpecifier *clone() const;
  void swap(ListVariableSpecifier &);
};
class ListStructMemberDeclaration : public Visitable
{
 public:
  StructMemberDeclaration *structmemberdeclaration_;
  ListStructMemberDeclaration *liststructmemberdeclaration_;

  ListStructMemberDeclaration(const ListStructMemberDeclaration &);
  ListStructMemberDeclaration &operator=(const ListStructMemberDeclaration &);
  ListStructMemberDeclaration(StructMemberDeclaration *p1, ListStructMemberDeclaration *p2);
  ListStructMemberDeclaration(StructMemberDeclaration *p);
  ~ListStructMemberDeclaration();
  ListStructMemberDeclaration* reverse();
  ListStructMemberDeclaration* reverse(ListStructMemberDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListStructMemberDeclaration *clone() const;
  void swap(ListStructMemberDeclaration &);
};
class ListGenericParam : public Visitable
{
 public:
  GenericParam *genericparam_;
  ListGenericParam *listgenericparam_;

  ListGenericParam(const ListGenericParam &);
  ListGenericParam &operator=(const ListGenericParam &);
  ListGenericParam(GenericParam *p1, ListGenericParam *p2);
  ListGenericParam(GenericParam *p);
  ~ListGenericParam();
  ListGenericParam* reverse();
  ListGenericParam* reverse(ListGenericParam *l);
  virtual void accept(Visitor *v);
  virtual ListGenericParam *clone() const;
  void swap(ListGenericParam &);
};
class ListParameterDeclaration : public Visitable
{
 public:
  ParameterDeclaration *parameterdeclaration_;
  ListParameterDeclaration *listparameterdeclaration_;

  ListParameterDeclaration(const ListParameterDeclaration &);
  ListParameterDeclaration &operator=(const ListParameterDeclaration &);
  ListParameterDeclaration(ParameterDeclaration *p1, ListParameterDeclaration *p2);
  ListParameterDeclaration(ParameterDeclaration *p);
  ~ListParameterDeclaration();
  ListParameterDeclaration* reverse();
  ListParameterDeclaration* reverse(ListParameterDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListParameterDeclaration *clone() const;
  void swap(ListParameterDeclaration &);
};
class ListExpression : public Visitable
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  ListExpression(const ListExpression &);
  ListExpression &operator=(const ListExpression &);
  ListExpression(Expression *p1, ListExpression *p2);
  ListExpression(Expression *p);
  ~ListExpression();
  ListExpression* reverse();
  ListExpression* reverse(ListExpression *l);
  virtual void accept(Visitor *v);
  virtual ListExpression *clone() const;
  void swap(ListExpression &);
};


#endif
