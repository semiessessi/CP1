#ifndef ABSYN_HEADER
#define ABSYN_HEADER

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* CString;
typedef char* CChar;
typedef char* Operator;


/********************   Forward Declarations    ********************/

class Main;
class DImport;
class DExpose;
class DNamespace;
class DDefaultFunction;
class DFunction;
class DOperator;
class DOperatorInfo;
class DTypeDecl;
class DTypeConv;
class DExtern;
class DIVariable;
class DVariable;
class PFunction;
class ONLnot;
class ONPreInc;
class ONPreDec;
class ONBnot;
class ONMul;
class ONExp;
class ONDiv;
class ONRDiv;
class ONMod;
class ONAdd;
class ONSub;
class ONLSh;
class ONRSh;
class ONLT;
class ONGT;
class ONLE;
class ONGE;
class ONE;
class ONNE;
class ONBand;
class ONBor;
class ONBxor;
class ONLand;
class ONLor;
class ONLxor;
class ONRight;
class ONLeft;
class OTIdentity;
class FSEntryPoint;
class FSPure;
class FSInline;
class FSAssociative;
class FSCommutative;
class FSAntiCommutative;
class FSInverse;
class FSSelfInverse;
class CSUp;
class CSDown;
class CSImplicit;
class VSConst;
class TSAlign;
class TSGeneric;
class TSInteger;
class TSReal;
class TSGParam;
class TAddress;
class TByte;
class TCustom;
class TFixedArray;
class TGenericArray;
class TStruct;
class TType;
class SMDMemberDeclaration;
class PDAutoParameter;
class PDTypedParameter;
class SReturn;
class SExpression;
class SScope;
class SIf;
class SIfElse;
class SLoop;
class SWhile;
class SUntil;
class SFor;
class SForEach;
class SForAll;
class SBreak;
class SContinue;
class SBreakpoint;
class SIVariable;
class SVariable;
class RVIdent;
class RVQualified;
class EDouble;
class EInteger;
class EString;
class EChar;
class EPi;
class ERValue;
class EArray;
class EList;
class EAComp;
class ELComp;
class EIndex;
class ESimpleCall;
class ECall;
class EPostInc;
class EPostDec;
class EAddress;
class EIntrinAddB;
class EIntrinSubB;
class EIntrinMulB;
class EIntrinUdivB;
class EIntrinSdivB;
class EIntrinUremB;
class EIntrinSremB;
class EIntrinAndB;
class EIntrinOrB;
class EIntrinXorB;
class EIntrinShlB;
class EIntrinLshrB;
class EIntrinAshrB;
class EIntrinNotB;
class EIntrinNegB;
class EIntrinCEqB;
class EIntrinCNeB;
class EIntrinCLtB;
class EIntrinCGtB;
class EIntrinCLeB;
class EIntrinCGeB;
class EIntrinAdd2B;
class EIntrinSub2B;
class EIntrinMul2B;
class EIntrinUdiv2B;
class EIntrinSdiv2B;
class EIntrinUrem2B;
class EIntrinSrem2B;
class EIntrinAnd2B;
class EIntrinOr2B;
class EIntrinXor2B;
class EIntrinShl2B;
class EIntrinLshr2B;
class EIntrinAshr2B;
class EIntrinNot2B;
class EIntrinNeg2B;
class EIntrinCEq2B;
class EIntrinCNe2B;
class EIntrinCLt2B;
class EIntrinCGt2B;
class EIntrinCLe2B;
class EIntrinCGe2B;
class EIntrinAdd4B;
class EIntrinSub4B;
class EIntrinMul4B;
class EIntrinUdiv4B;
class EIntrinSdiv4B;
class EIntrinUrem4B;
class EIntrinSrem4B;
class EIntrinAnd4B;
class EIntrinOr4B;
class EIntrinXor4B;
class EIntrinShl4B;
class EIntrinLshr4B;
class EIntrinAshr4B;
class EIntrinNot4B;
class EIntrinNeg4B;
class EIntrinCEq4B;
class EIntrinCNe4B;
class EIntrinCLt4B;
class EIntrinCGt4B;
class EIntrinCLe4B;
class EIntrinCGe4B;
class EIntrinAdd8B;
class EIntrinSub8B;
class EIntrinMul8B;
class EIntrinUdiv8B;
class EIntrinSdiv8B;
class EIntrinUrem8B;
class EIntrinSrem8B;
class EIntrinAnd8B;
class EIntrinOr8B;
class EIntrinXor8B;
class EIntrinShl8B;
class EIntrinLshr8B;
class EIntrinAshr8B;
class EIntrinNot8B;
class EIntrinNeg8B;
class EIntrinCEq8B;
class EIntrinCNe8B;
class EIntrinCLt8B;
class EIntrinCGt8B;
class EIntrinCLe8B;
class EIntrinCGe8B;
class EIntrinAddB4V;
class EIntrinSubB4V;
class EIntrinMulB4V;
class EIntrinUdivB4V;
class EIntrinSdivB4V;
class EIntrinUremB4V;
class EIntrinSremB4V;
class EIntrinShlB4V;
class EIntrinLshrB4V;
class EIntrinAshrB4V;
class EIntrinNegB4V;
class EIntrinAddB8V;
class EIntrinSubB8V;
class EIntrinMulB8V;
class EIntrinUdivB8V;
class EIntrinSdivB8V;
class EIntrinUremB8V;
class EIntrinSremB8V;
class EIntrinShlB8V;
class EIntrinLshrB8V;
class EIntrinAshrB8V;
class EIntrinNegB8V;
class EIntrinAdd2F;
class EIntrinSub2F;
class EIntrinMul2F;
class EIntrinUdiv2F;
class EIntrinUrem2F;
class EIntrinAdd4F;
class EIntrinSub4F;
class EIntrinMul4F;
class EIntrinUdiv4F;
class EIntrinUrem4F;
class EIntrinAdd8F;
class EIntrinSub8F;
class EIntrinMul8F;
class EIntrinUdiv8F;
class EIntrinUrem8F;
class EIntrinAdd4F4V;
class EIntrinSub4F4V;
class EIntrinMul4F4V;
class EIntrinUdiv4F4V;
class EIntrinUrem4F4V;
class ELnot;
class EPreInc;
class EPreDec;
class ENeg;
class EBnot;
class EPos;
class EMul;
class EDiv;
class EMod;
class EAdd;
class ESub;
class ELSh;
class ERSh;
class ELT;
class EGT;
class ELE;
class EGE;
class EE;
class ENE;
class EBand;
class EBor;
class EBxor;
class ELand;
class ELor;
class ELxor;
class EConditional;
class EAssign;
class EAddAssign;
class ESubAssign;
class EMulAssign;
class EDivAssign;
class EModAssign;
class EAndAssign;
class EOrAssign;
class EXorAssign;
class ELShAssign;
class ERShAssign;
class ListTLDeclaration;
class ListDeclaration;
class ListStatement;
class ListTypeSpecifier;
class ListConversionSpecifier;
class ListFunctionSpecifier;
class ListVariableSpecifier;
class ListStructMemberDeclaration;
class ListGenericParam;
class ListParameterDeclaration;
class ListExpression;
class Code;
class TLDeclaration;
class Declaration;
class Prototype;
class OperatorName;
class OperatorTrait;
class FunctionSpecifier;
class ConversionSpecifier;
class VariableSpecifier;
class TypeSpecifier;
class GenericParam;
class Type;
class StructMemberDeclaration;
class ParameterDeclaration;
class Statement;
class RValue;
class Expression;


/********************   Visitor Interfaces    ********************/

class Visitor
{
 public:
  virtual ~Visitor() {}
  virtual void visitMain(Main *p) = 0;
  virtual void visitDImport(DImport *p) = 0;
  virtual void visitDExpose(DExpose *p) = 0;
  virtual void visitDNamespace(DNamespace *p) = 0;
  virtual void visitDDefaultFunction(DDefaultFunction *p) = 0;
  virtual void visitDFunction(DFunction *p) = 0;
  virtual void visitDOperator(DOperator *p) = 0;
  virtual void visitDOperatorInfo(DOperatorInfo *p) = 0;
  virtual void visitDTypeDecl(DTypeDecl *p) = 0;
  virtual void visitDTypeConv(DTypeConv *p) = 0;
  virtual void visitDExtern(DExtern *p) = 0;
  virtual void visitDIVariable(DIVariable *p) = 0;
  virtual void visitDVariable(DVariable *p) = 0;
  virtual void visitPFunction(PFunction *p) = 0;
  virtual void visitONLnot(ONLnot *p) = 0;
  virtual void visitONPreInc(ONPreInc *p) = 0;
  virtual void visitONPreDec(ONPreDec *p) = 0;
  virtual void visitONBnot(ONBnot *p) = 0;
  virtual void visitONMul(ONMul *p) = 0;
  virtual void visitONExp(ONExp *p) = 0;
  virtual void visitONDiv(ONDiv *p) = 0;
  virtual void visitONRDiv(ONRDiv *p) = 0;
  virtual void visitONMod(ONMod *p) = 0;
  virtual void visitONAdd(ONAdd *p) = 0;
  virtual void visitONSub(ONSub *p) = 0;
  virtual void visitONLSh(ONLSh *p) = 0;
  virtual void visitONRSh(ONRSh *p) = 0;
  virtual void visitONLT(ONLT *p) = 0;
  virtual void visitONGT(ONGT *p) = 0;
  virtual void visitONLE(ONLE *p) = 0;
  virtual void visitONGE(ONGE *p) = 0;
  virtual void visitONE(ONE *p) = 0;
  virtual void visitONNE(ONNE *p) = 0;
  virtual void visitONBand(ONBand *p) = 0;
  virtual void visitONBor(ONBor *p) = 0;
  virtual void visitONBxor(ONBxor *p) = 0;
  virtual void visitONLand(ONLand *p) = 0;
  virtual void visitONLor(ONLor *p) = 0;
  virtual void visitONLxor(ONLxor *p) = 0;
  virtual void visitONRight(ONRight *p) = 0;
  virtual void visitONLeft(ONLeft *p) = 0;
  virtual void visitOTIdentity(OTIdentity *p) = 0;
  virtual void visitFSEntryPoint(FSEntryPoint *p) = 0;
  virtual void visitFSPure(FSPure *p) = 0;
  virtual void visitFSInline(FSInline *p) = 0;
  virtual void visitFSAssociative(FSAssociative *p) = 0;
  virtual void visitFSCommutative(FSCommutative *p) = 0;
  virtual void visitFSAntiCommutative(FSAntiCommutative *p) = 0;
  virtual void visitFSInverse(FSInverse *p) = 0;
  virtual void visitFSSelfInverse(FSSelfInverse *p) = 0;
  virtual void visitCSUp(CSUp *p) = 0;
  virtual void visitCSDown(CSDown *p) = 0;
  virtual void visitCSImplicit(CSImplicit *p) = 0;
  virtual void visitVSConst(VSConst *p) = 0;
  virtual void visitTSAlign(TSAlign *p) = 0;
  virtual void visitTSGeneric(TSGeneric *p) = 0;
  virtual void visitTSInteger(TSInteger *p) = 0;
  virtual void visitTSReal(TSReal *p) = 0;
  virtual void visitTSGParam(TSGParam *p) = 0;
  virtual void visitTAddress(TAddress *p) = 0;
  virtual void visitTByte(TByte *p) = 0;
  virtual void visitTCustom(TCustom *p) = 0;
  virtual void visitTFixedArray(TFixedArray *p) = 0;
  virtual void visitTGenericArray(TGenericArray *p) = 0;
  virtual void visitTStruct(TStruct *p) = 0;
  virtual void visitTType(TType *p) = 0;
  virtual void visitSMDMemberDeclaration(SMDMemberDeclaration *p) = 0;
  virtual void visitPDAutoParameter(PDAutoParameter *p) = 0;
  virtual void visitPDTypedParameter(PDTypedParameter *p) = 0;
  virtual void visitSReturn(SReturn *p) = 0;
  virtual void visitSExpression(SExpression *p) = 0;
  virtual void visitSScope(SScope *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitSLoop(SLoop *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSUntil(SUntil *p) = 0;
  virtual void visitSFor(SFor *p) = 0;
  virtual void visitSForEach(SForEach *p) = 0;
  virtual void visitSForAll(SForAll *p) = 0;
  virtual void visitSBreak(SBreak *p) = 0;
  virtual void visitSContinue(SContinue *p) = 0;
  virtual void visitSBreakpoint(SBreakpoint *p) = 0;
  virtual void visitSIVariable(SIVariable *p) = 0;
  virtual void visitSVariable(SVariable *p) = 0;
  virtual void visitRVIdent(RVIdent *p) = 0;
  virtual void visitRVQualified(RVQualified *p) = 0;
  virtual void visitEDouble(EDouble *p) = 0;
  virtual void visitEInteger(EInteger *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEChar(EChar *p) = 0;
  virtual void visitEPi(EPi *p) = 0;
  virtual void visitERValue(ERValue *p) = 0;
  virtual void visitEArray(EArray *p) = 0;
  virtual void visitEList(EList *p) = 0;
  virtual void visitEAComp(EAComp *p) = 0;
  virtual void visitELComp(ELComp *p) = 0;
  virtual void visitEIndex(EIndex *p) = 0;
  virtual void visitESimpleCall(ESimpleCall *p) = 0;
  virtual void visitECall(ECall *p) = 0;
  virtual void visitEPostInc(EPostInc *p) = 0;
  virtual void visitEPostDec(EPostDec *p) = 0;
  virtual void visitEAddress(EAddress *p) = 0;
  virtual void visitEIntrinAddB(EIntrinAddB *p) = 0;
  virtual void visitEIntrinSubB(EIntrinSubB *p) = 0;
  virtual void visitEIntrinMulB(EIntrinMulB *p) = 0;
  virtual void visitEIntrinUdivB(EIntrinUdivB *p) = 0;
  virtual void visitEIntrinSdivB(EIntrinSdivB *p) = 0;
  virtual void visitEIntrinUremB(EIntrinUremB *p) = 0;
  virtual void visitEIntrinSremB(EIntrinSremB *p) = 0;
  virtual void visitEIntrinAndB(EIntrinAndB *p) = 0;
  virtual void visitEIntrinOrB(EIntrinOrB *p) = 0;
  virtual void visitEIntrinXorB(EIntrinXorB *p) = 0;
  virtual void visitEIntrinShlB(EIntrinShlB *p) = 0;
  virtual void visitEIntrinLshrB(EIntrinLshrB *p) = 0;
  virtual void visitEIntrinAshrB(EIntrinAshrB *p) = 0;
  virtual void visitEIntrinNotB(EIntrinNotB *p) = 0;
  virtual void visitEIntrinNegB(EIntrinNegB *p) = 0;
  virtual void visitEIntrinCEqB(EIntrinCEqB *p) = 0;
  virtual void visitEIntrinCNeB(EIntrinCNeB *p) = 0;
  virtual void visitEIntrinCLtB(EIntrinCLtB *p) = 0;
  virtual void visitEIntrinCGtB(EIntrinCGtB *p) = 0;
  virtual void visitEIntrinCLeB(EIntrinCLeB *p) = 0;
  virtual void visitEIntrinCGeB(EIntrinCGeB *p) = 0;
  virtual void visitEIntrinAdd2B(EIntrinAdd2B *p) = 0;
  virtual void visitEIntrinSub2B(EIntrinSub2B *p) = 0;
  virtual void visitEIntrinMul2B(EIntrinMul2B *p) = 0;
  virtual void visitEIntrinUdiv2B(EIntrinUdiv2B *p) = 0;
  virtual void visitEIntrinSdiv2B(EIntrinSdiv2B *p) = 0;
  virtual void visitEIntrinUrem2B(EIntrinUrem2B *p) = 0;
  virtual void visitEIntrinSrem2B(EIntrinSrem2B *p) = 0;
  virtual void visitEIntrinAnd2B(EIntrinAnd2B *p) = 0;
  virtual void visitEIntrinOr2B(EIntrinOr2B *p) = 0;
  virtual void visitEIntrinXor2B(EIntrinXor2B *p) = 0;
  virtual void visitEIntrinShl2B(EIntrinShl2B *p) = 0;
  virtual void visitEIntrinLshr2B(EIntrinLshr2B *p) = 0;
  virtual void visitEIntrinAshr2B(EIntrinAshr2B *p) = 0;
  virtual void visitEIntrinNot2B(EIntrinNot2B *p) = 0;
  virtual void visitEIntrinNeg2B(EIntrinNeg2B *p) = 0;
  virtual void visitEIntrinCEq2B(EIntrinCEq2B *p) = 0;
  virtual void visitEIntrinCNe2B(EIntrinCNe2B *p) = 0;
  virtual void visitEIntrinCLt2B(EIntrinCLt2B *p) = 0;
  virtual void visitEIntrinCGt2B(EIntrinCGt2B *p) = 0;
  virtual void visitEIntrinCLe2B(EIntrinCLe2B *p) = 0;
  virtual void visitEIntrinCGe2B(EIntrinCGe2B *p) = 0;
  virtual void visitEIntrinAdd4B(EIntrinAdd4B *p) = 0;
  virtual void visitEIntrinSub4B(EIntrinSub4B *p) = 0;
  virtual void visitEIntrinMul4B(EIntrinMul4B *p) = 0;
  virtual void visitEIntrinUdiv4B(EIntrinUdiv4B *p) = 0;
  virtual void visitEIntrinSdiv4B(EIntrinSdiv4B *p) = 0;
  virtual void visitEIntrinUrem4B(EIntrinUrem4B *p) = 0;
  virtual void visitEIntrinSrem4B(EIntrinSrem4B *p) = 0;
  virtual void visitEIntrinAnd4B(EIntrinAnd4B *p) = 0;
  virtual void visitEIntrinOr4B(EIntrinOr4B *p) = 0;
  virtual void visitEIntrinXor4B(EIntrinXor4B *p) = 0;
  virtual void visitEIntrinShl4B(EIntrinShl4B *p) = 0;
  virtual void visitEIntrinLshr4B(EIntrinLshr4B *p) = 0;
  virtual void visitEIntrinAshr4B(EIntrinAshr4B *p) = 0;
  virtual void visitEIntrinNot4B(EIntrinNot4B *p) = 0;
  virtual void visitEIntrinNeg4B(EIntrinNeg4B *p) = 0;
  virtual void visitEIntrinCEq4B(EIntrinCEq4B *p) = 0;
  virtual void visitEIntrinCNe4B(EIntrinCNe4B *p) = 0;
  virtual void visitEIntrinCLt4B(EIntrinCLt4B *p) = 0;
  virtual void visitEIntrinCGt4B(EIntrinCGt4B *p) = 0;
  virtual void visitEIntrinCLe4B(EIntrinCLe4B *p) = 0;
  virtual void visitEIntrinCGe4B(EIntrinCGe4B *p) = 0;
  virtual void visitEIntrinAdd8B(EIntrinAdd8B *p) = 0;
  virtual void visitEIntrinSub8B(EIntrinSub8B *p) = 0;
  virtual void visitEIntrinMul8B(EIntrinMul8B *p) = 0;
  virtual void visitEIntrinUdiv8B(EIntrinUdiv8B *p) = 0;
  virtual void visitEIntrinSdiv8B(EIntrinSdiv8B *p) = 0;
  virtual void visitEIntrinUrem8B(EIntrinUrem8B *p) = 0;
  virtual void visitEIntrinSrem8B(EIntrinSrem8B *p) = 0;
  virtual void visitEIntrinAnd8B(EIntrinAnd8B *p) = 0;
  virtual void visitEIntrinOr8B(EIntrinOr8B *p) = 0;
  virtual void visitEIntrinXor8B(EIntrinXor8B *p) = 0;
  virtual void visitEIntrinShl8B(EIntrinShl8B *p) = 0;
  virtual void visitEIntrinLshr8B(EIntrinLshr8B *p) = 0;
  virtual void visitEIntrinAshr8B(EIntrinAshr8B *p) = 0;
  virtual void visitEIntrinNot8B(EIntrinNot8B *p) = 0;
  virtual void visitEIntrinNeg8B(EIntrinNeg8B *p) = 0;
  virtual void visitEIntrinCEq8B(EIntrinCEq8B *p) = 0;
  virtual void visitEIntrinCNe8B(EIntrinCNe8B *p) = 0;
  virtual void visitEIntrinCLt8B(EIntrinCLt8B *p) = 0;
  virtual void visitEIntrinCGt8B(EIntrinCGt8B *p) = 0;
  virtual void visitEIntrinCLe8B(EIntrinCLe8B *p) = 0;
  virtual void visitEIntrinCGe8B(EIntrinCGe8B *p) = 0;
  virtual void visitEIntrinAddB4V(EIntrinAddB4V *p) = 0;
  virtual void visitEIntrinSubB4V(EIntrinSubB4V *p) = 0;
  virtual void visitEIntrinMulB4V(EIntrinMulB4V *p) = 0;
  virtual void visitEIntrinUdivB4V(EIntrinUdivB4V *p) = 0;
  virtual void visitEIntrinSdivB4V(EIntrinSdivB4V *p) = 0;
  virtual void visitEIntrinUremB4V(EIntrinUremB4V *p) = 0;
  virtual void visitEIntrinSremB4V(EIntrinSremB4V *p) = 0;
  virtual void visitEIntrinShlB4V(EIntrinShlB4V *p) = 0;
  virtual void visitEIntrinLshrB4V(EIntrinLshrB4V *p) = 0;
  virtual void visitEIntrinAshrB4V(EIntrinAshrB4V *p) = 0;
  virtual void visitEIntrinNegB4V(EIntrinNegB4V *p) = 0;
  virtual void visitEIntrinAddB8V(EIntrinAddB8V *p) = 0;
  virtual void visitEIntrinSubB8V(EIntrinSubB8V *p) = 0;
  virtual void visitEIntrinMulB8V(EIntrinMulB8V *p) = 0;
  virtual void visitEIntrinUdivB8V(EIntrinUdivB8V *p) = 0;
  virtual void visitEIntrinSdivB8V(EIntrinSdivB8V *p) = 0;
  virtual void visitEIntrinUremB8V(EIntrinUremB8V *p) = 0;
  virtual void visitEIntrinSremB8V(EIntrinSremB8V *p) = 0;
  virtual void visitEIntrinShlB8V(EIntrinShlB8V *p) = 0;
  virtual void visitEIntrinLshrB8V(EIntrinLshrB8V *p) = 0;
  virtual void visitEIntrinAshrB8V(EIntrinAshrB8V *p) = 0;
  virtual void visitEIntrinNegB8V(EIntrinNegB8V *p) = 0;
  virtual void visitEIntrinAdd2F(EIntrinAdd2F *p) = 0;
  virtual void visitEIntrinSub2F(EIntrinSub2F *p) = 0;
  virtual void visitEIntrinMul2F(EIntrinMul2F *p) = 0;
  virtual void visitEIntrinUdiv2F(EIntrinUdiv2F *p) = 0;
  virtual void visitEIntrinUrem2F(EIntrinUrem2F *p) = 0;
  virtual void visitEIntrinAdd4F(EIntrinAdd4F *p) = 0;
  virtual void visitEIntrinSub4F(EIntrinSub4F *p) = 0;
  virtual void visitEIntrinMul4F(EIntrinMul4F *p) = 0;
  virtual void visitEIntrinUdiv4F(EIntrinUdiv4F *p) = 0;
  virtual void visitEIntrinUrem4F(EIntrinUrem4F *p) = 0;
  virtual void visitEIntrinAdd8F(EIntrinAdd8F *p) = 0;
  virtual void visitEIntrinSub8F(EIntrinSub8F *p) = 0;
  virtual void visitEIntrinMul8F(EIntrinMul8F *p) = 0;
  virtual void visitEIntrinUdiv8F(EIntrinUdiv8F *p) = 0;
  virtual void visitEIntrinUrem8F(EIntrinUrem8F *p) = 0;
  virtual void visitEIntrinAdd4F4V(EIntrinAdd4F4V *p) = 0;
  virtual void visitEIntrinSub4F4V(EIntrinSub4F4V *p) = 0;
  virtual void visitEIntrinMul4F4V(EIntrinMul4F4V *p) = 0;
  virtual void visitEIntrinUdiv4F4V(EIntrinUdiv4F4V *p) = 0;
  virtual void visitEIntrinUrem4F4V(EIntrinUrem4F4V *p) = 0;
  virtual void visitELnot(ELnot *p) = 0;
  virtual void visitEPreInc(EPreInc *p) = 0;
  virtual void visitEPreDec(EPreDec *p) = 0;
  virtual void visitENeg(ENeg *p) = 0;
  virtual void visitEBnot(EBnot *p) = 0;
  virtual void visitEPos(EPos *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEMod(EMod *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitELSh(ELSh *p) = 0;
  virtual void visitERSh(ERSh *p) = 0;
  virtual void visitELT(ELT *p) = 0;
  virtual void visitEGT(EGT *p) = 0;
  virtual void visitELE(ELE *p) = 0;
  virtual void visitEGE(EGE *p) = 0;
  virtual void visitEE(EE *p) = 0;
  virtual void visitENE(ENE *p) = 0;
  virtual void visitEBand(EBand *p) = 0;
  virtual void visitEBor(EBor *p) = 0;
  virtual void visitEBxor(EBxor *p) = 0;
  virtual void visitELand(ELand *p) = 0;
  virtual void visitELor(ELor *p) = 0;
  virtual void visitELxor(ELxor *p) = 0;
  virtual void visitEConditional(EConditional *p) = 0;
  virtual void visitEAssign(EAssign *p) = 0;
  virtual void visitEAddAssign(EAddAssign *p) = 0;
  virtual void visitESubAssign(ESubAssign *p) = 0;
  virtual void visitEMulAssign(EMulAssign *p) = 0;
  virtual void visitEDivAssign(EDivAssign *p) = 0;
  virtual void visitEModAssign(EModAssign *p) = 0;
  virtual void visitEAndAssign(EAndAssign *p) = 0;
  virtual void visitEOrAssign(EOrAssign *p) = 0;
  virtual void visitEXorAssign(EXorAssign *p) = 0;
  virtual void visitELShAssign(ELShAssign *p) = 0;
  virtual void visitERShAssign(ERShAssign *p) = 0;
  virtual void visitListTLDeclaration(ListTLDeclaration *p) = 0;
  virtual void visitListDeclaration(ListDeclaration *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListTypeSpecifier(ListTypeSpecifier *p) = 0;
  virtual void visitListConversionSpecifier(ListConversionSpecifier *p) = 0;
  virtual void visitListFunctionSpecifier(ListFunctionSpecifier *p) = 0;
  virtual void visitListVariableSpecifier(ListVariableSpecifier *p) = 0;
  virtual void visitListStructMemberDeclaration(ListStructMemberDeclaration *p) = 0;
  virtual void visitListGenericParam(ListGenericParam *p) = 0;
  virtual void visitListParameterDeclaration(ListParameterDeclaration *p) = 0;
  virtual void visitListExpression(ListExpression *p) = 0;
  virtual void visitCode(Code *p) = 0;
  virtual void visitTLDeclaration(TLDeclaration *p) = 0;
  virtual void visitDeclaration(Declaration *p) = 0;
  virtual void visitPrototype(Prototype *p) = 0;
  virtual void visitOperatorName(OperatorName *p) = 0;
  virtual void visitOperatorTrait(OperatorTrait *p) = 0;
  virtual void visitFunctionSpecifier(FunctionSpecifier *p) = 0;
  virtual void visitConversionSpecifier(ConversionSpecifier *p) = 0;
  virtual void visitVariableSpecifier(VariableSpecifier *p) = 0;
  virtual void visitTypeSpecifier(TypeSpecifier *p) = 0;
  virtual void visitGenericParam(GenericParam *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitStructMemberDeclaration(StructMemberDeclaration *p) = 0;
  virtual void visitParameterDeclaration(ParameterDeclaration *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitRValue(RValue *p) = 0;
  virtual void visitExpression(Expression *p) = 0;

  virtual void visitInteger(Integer i) = 0;
  virtual void visitDouble(Double d) = 0;
  virtual void visitChar(Char c) = 0;
  virtual void visitString(String s) = 0;
};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};



/********************   Abstract Syntax Classes    ********************/

class Code : public Visitable {
public:
  virtual Code *clone() const = 0;
};

class Main : public Code
{
 public:
  ListTLDeclaration *listtldeclaration_;
  ListDeclaration *listdeclaration_;

  Main(const Main &);
  Main &operator=(const Main &);
  Main(ListTLDeclaration *p1, ListDeclaration *p2);
  ~Main();
  virtual void accept(Visitor *v);
  virtual  Main  *clone() const;
  void swap(Main &);
};


class TLDeclaration : public Visitable {
public:
  virtual TLDeclaration *clone() const = 0;
};

class DImport : public TLDeclaration
{
 public:
  Ident ident_;

  DImport(const DImport &);
  DImport &operator=(const DImport &);
  DImport(Ident p1);
  ~DImport();
  virtual void accept(Visitor *v);
  virtual  DImport  *clone() const;
  void swap(DImport &);
};

class DExpose : public TLDeclaration
{
 public:
  Ident ident_;

  DExpose(const DExpose &);
  DExpose &operator=(const DExpose &);
  DExpose(Ident p1);
  ~DExpose();
  virtual void accept(Visitor *v);
  virtual  DExpose  *clone() const;
  void swap(DExpose &);
};


class Declaration : public Visitable {
public:
  virtual Declaration *clone() const = 0;
};

class DNamespace : public Declaration
{
 public:
  Ident ident_;
  ListDeclaration *listdeclaration_;

  DNamespace(const DNamespace &);
  DNamespace &operator=(const DNamespace &);
  DNamespace(Ident p1, ListDeclaration *p2);
  ~DNamespace();
  virtual void accept(Visitor *v);
  virtual  DNamespace  *clone() const;
  void swap(DNamespace &);
};

class DDefaultFunction : public Declaration
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Ident ident_;
  ListParameterDeclaration *listparameterdeclaration_;
  ListStatement *liststatement_;

  DDefaultFunction(const DDefaultFunction &);
  DDefaultFunction &operator=(const DDefaultFunction &);
  DDefaultFunction(ListFunctionSpecifier *p1, Ident p2, ListParameterDeclaration *p3, ListStatement *p4);
  ~DDefaultFunction();
  virtual void accept(Visitor *v);
  virtual  DDefaultFunction  *clone() const;
  void swap(DDefaultFunction &);
};

class DFunction : public Declaration
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Type *type_;
  Ident ident_;
  ListParameterDeclaration *listparameterdeclaration_;
  ListStatement *liststatement_;

  DFunction(const DFunction &);
  DFunction &operator=(const DFunction &);
  DFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4, ListStatement *p5);
  ~DFunction();
  virtual void accept(Visitor *v);
  virtual  DFunction  *clone() const;
  void swap(DFunction &);
};

class DOperator : public Declaration
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Type *type_;
  OperatorName *operatorname_;
  ListParameterDeclaration *listparameterdeclaration_;
  ListStatement *liststatement_;

  DOperator(const DOperator &);
  DOperator &operator=(const DOperator &);
  DOperator(ListFunctionSpecifier *p1, Type *p2, OperatorName *p3, ListParameterDeclaration *p4, ListStatement *p5);
  ~DOperator();
  virtual void accept(Visitor *v);
  virtual  DOperator  *clone() const;
  void swap(DOperator &);
};

class DOperatorInfo : public Declaration
{
 public:
  OperatorTrait *operatortrait_;

  DOperatorInfo(const DOperatorInfo &);
  DOperatorInfo &operator=(const DOperatorInfo &);
  DOperatorInfo(OperatorTrait *p1);
  ~DOperatorInfo();
  virtual void accept(Visitor *v);
  virtual  DOperatorInfo  *clone() const;
  void swap(DOperatorInfo &);
};

class DTypeDecl : public Declaration
{
 public:
  ListTypeSpecifier *listtypespecifier_;
  Type *type_;
  Ident ident_;

  DTypeDecl(const DTypeDecl &);
  DTypeDecl &operator=(const DTypeDecl &);
  DTypeDecl(ListTypeSpecifier *p1, Type *p2, Ident p3);
  ~DTypeDecl();
  virtual void accept(Visitor *v);
  virtual  DTypeDecl  *clone() const;
  void swap(DTypeDecl &);
};

class DTypeConv : public Declaration
{
 public:
  Type *type_1, *type_2;
  ListConversionSpecifier *listconversionspecifier_;
  Ident ident_;
  ListStatement *liststatement_;

  DTypeConv(const DTypeConv &);
  DTypeConv &operator=(const DTypeConv &);
  DTypeConv(Type *p1, ListConversionSpecifier *p2, Type *p3, Ident p4, ListStatement *p5);
  ~DTypeConv();
  virtual void accept(Visitor *v);
  virtual  DTypeConv  *clone() const;
  void swap(DTypeConv &);
};

class DExtern : public Declaration
{
 public:
  Prototype *prototype_;

  DExtern(const DExtern &);
  DExtern &operator=(const DExtern &);
  DExtern(Prototype *p1);
  ~DExtern();
  virtual void accept(Visitor *v);
  virtual  DExtern  *clone() const;
  void swap(DExtern &);
};

class DIVariable : public Declaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;
  Expression *expression_;

  DIVariable(const DIVariable &);
  DIVariable &operator=(const DIVariable &);
  DIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4);
  ~DIVariable();
  virtual void accept(Visitor *v);
  virtual  DIVariable  *clone() const;
  void swap(DIVariable &);
};

class DVariable : public Declaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;

  DVariable(const DVariable &);
  DVariable &operator=(const DVariable &);
  DVariable(ListVariableSpecifier *p1, Type *p2, Ident p3);
  ~DVariable();
  virtual void accept(Visitor *v);
  virtual  DVariable  *clone() const;
  void swap(DVariable &);
};


class Prototype : public Visitable {
public:
  virtual Prototype *clone() const = 0;
};

class PFunction : public Prototype
{
 public:
  ListFunctionSpecifier *listfunctionspecifier_;
  Type *type_;
  Ident ident_;
  ListParameterDeclaration *listparameterdeclaration_;

  PFunction(const PFunction &);
  PFunction &operator=(const PFunction &);
  PFunction(ListFunctionSpecifier *p1, Type *p2, Ident p3, ListParameterDeclaration *p4);
  ~PFunction();
  virtual void accept(Visitor *v);
  virtual  PFunction  *clone() const;
  void swap(PFunction &);
};


class OperatorName : public Visitable {
public:
  virtual OperatorName *clone() const = 0;
};

class ONLnot : public OperatorName
{
 public:

  ONLnot(const ONLnot &);
  ONLnot &operator=(const ONLnot &);
  ONLnot();
  ~ONLnot();
  virtual void accept(Visitor *v);
  virtual  ONLnot  *clone() const;
  void swap(ONLnot &);
};

class ONPreInc : public OperatorName
{
 public:

  ONPreInc(const ONPreInc &);
  ONPreInc &operator=(const ONPreInc &);
  ONPreInc();
  ~ONPreInc();
  virtual void accept(Visitor *v);
  virtual  ONPreInc  *clone() const;
  void swap(ONPreInc &);
};

class ONPreDec : public OperatorName
{
 public:

  ONPreDec(const ONPreDec &);
  ONPreDec &operator=(const ONPreDec &);
  ONPreDec();
  ~ONPreDec();
  virtual void accept(Visitor *v);
  virtual  ONPreDec  *clone() const;
  void swap(ONPreDec &);
};

class ONBnot : public OperatorName
{
 public:

  ONBnot(const ONBnot &);
  ONBnot &operator=(const ONBnot &);
  ONBnot();
  ~ONBnot();
  virtual void accept(Visitor *v);
  virtual  ONBnot  *clone() const;
  void swap(ONBnot &);
};

class ONMul : public OperatorName
{
 public:

  ONMul(const ONMul &);
  ONMul &operator=(const ONMul &);
  ONMul();
  ~ONMul();
  virtual void accept(Visitor *v);
  virtual  ONMul  *clone() const;
  void swap(ONMul &);
};

class ONExp : public OperatorName
{
 public:

  ONExp(const ONExp &);
  ONExp &operator=(const ONExp &);
  ONExp();
  ~ONExp();
  virtual void accept(Visitor *v);
  virtual  ONExp  *clone() const;
  void swap(ONExp &);
};

class ONDiv : public OperatorName
{
 public:

  ONDiv(const ONDiv &);
  ONDiv &operator=(const ONDiv &);
  ONDiv();
  ~ONDiv();
  virtual void accept(Visitor *v);
  virtual  ONDiv  *clone() const;
  void swap(ONDiv &);
};

class ONRDiv : public OperatorName
{
 public:

  ONRDiv(const ONRDiv &);
  ONRDiv &operator=(const ONRDiv &);
  ONRDiv();
  ~ONRDiv();
  virtual void accept(Visitor *v);
  virtual  ONRDiv  *clone() const;
  void swap(ONRDiv &);
};

class ONMod : public OperatorName
{
 public:

  ONMod(const ONMod &);
  ONMod &operator=(const ONMod &);
  ONMod();
  ~ONMod();
  virtual void accept(Visitor *v);
  virtual  ONMod  *clone() const;
  void swap(ONMod &);
};

class ONAdd : public OperatorName
{
 public:

  ONAdd(const ONAdd &);
  ONAdd &operator=(const ONAdd &);
  ONAdd();
  ~ONAdd();
  virtual void accept(Visitor *v);
  virtual  ONAdd  *clone() const;
  void swap(ONAdd &);
};

class ONSub : public OperatorName
{
 public:

  ONSub(const ONSub &);
  ONSub &operator=(const ONSub &);
  ONSub();
  ~ONSub();
  virtual void accept(Visitor *v);
  virtual  ONSub  *clone() const;
  void swap(ONSub &);
};

class ONLSh : public OperatorName
{
 public:

  ONLSh(const ONLSh &);
  ONLSh &operator=(const ONLSh &);
  ONLSh();
  ~ONLSh();
  virtual void accept(Visitor *v);
  virtual  ONLSh  *clone() const;
  void swap(ONLSh &);
};

class ONRSh : public OperatorName
{
 public:

  ONRSh(const ONRSh &);
  ONRSh &operator=(const ONRSh &);
  ONRSh();
  ~ONRSh();
  virtual void accept(Visitor *v);
  virtual  ONRSh  *clone() const;
  void swap(ONRSh &);
};

class ONLT : public OperatorName
{
 public:

  ONLT(const ONLT &);
  ONLT &operator=(const ONLT &);
  ONLT();
  ~ONLT();
  virtual void accept(Visitor *v);
  virtual  ONLT  *clone() const;
  void swap(ONLT &);
};

class ONGT : public OperatorName
{
 public:

  ONGT(const ONGT &);
  ONGT &operator=(const ONGT &);
  ONGT();
  ~ONGT();
  virtual void accept(Visitor *v);
  virtual  ONGT  *clone() const;
  void swap(ONGT &);
};

class ONLE : public OperatorName
{
 public:

  ONLE(const ONLE &);
  ONLE &operator=(const ONLE &);
  ONLE();
  ~ONLE();
  virtual void accept(Visitor *v);
  virtual  ONLE  *clone() const;
  void swap(ONLE &);
};

class ONGE : public OperatorName
{
 public:

  ONGE(const ONGE &);
  ONGE &operator=(const ONGE &);
  ONGE();
  ~ONGE();
  virtual void accept(Visitor *v);
  virtual  ONGE  *clone() const;
  void swap(ONGE &);
};

class ONE : public OperatorName
{
 public:

  ONE(const ONE &);
  ONE &operator=(const ONE &);
  ONE();
  ~ONE();
  virtual void accept(Visitor *v);
  virtual  ONE  *clone() const;
  void swap(ONE &);
};

class ONNE : public OperatorName
{
 public:

  ONNE(const ONNE &);
  ONNE &operator=(const ONNE &);
  ONNE();
  ~ONNE();
  virtual void accept(Visitor *v);
  virtual  ONNE  *clone() const;
  void swap(ONNE &);
};

class ONBand : public OperatorName
{
 public:

  ONBand(const ONBand &);
  ONBand &operator=(const ONBand &);
  ONBand();
  ~ONBand();
  virtual void accept(Visitor *v);
  virtual  ONBand  *clone() const;
  void swap(ONBand &);
};

class ONBor : public OperatorName
{
 public:

  ONBor(const ONBor &);
  ONBor &operator=(const ONBor &);
  ONBor();
  ~ONBor();
  virtual void accept(Visitor *v);
  virtual  ONBor  *clone() const;
  void swap(ONBor &);
};

class ONBxor : public OperatorName
{
 public:

  ONBxor(const ONBxor &);
  ONBxor &operator=(const ONBxor &);
  ONBxor();
  ~ONBxor();
  virtual void accept(Visitor *v);
  virtual  ONBxor  *clone() const;
  void swap(ONBxor &);
};

class ONLand : public OperatorName
{
 public:

  ONLand(const ONLand &);
  ONLand &operator=(const ONLand &);
  ONLand();
  ~ONLand();
  virtual void accept(Visitor *v);
  virtual  ONLand  *clone() const;
  void swap(ONLand &);
};

class ONLor : public OperatorName
{
 public:

  ONLor(const ONLor &);
  ONLor &operator=(const ONLor &);
  ONLor();
  ~ONLor();
  virtual void accept(Visitor *v);
  virtual  ONLor  *clone() const;
  void swap(ONLor &);
};

class ONLxor : public OperatorName
{
 public:

  ONLxor(const ONLxor &);
  ONLxor &operator=(const ONLxor &);
  ONLxor();
  ~ONLxor();
  virtual void accept(Visitor *v);
  virtual  ONLxor  *clone() const;
  void swap(ONLxor &);
};

class ONRight : public OperatorName
{
 public:

  ONRight(const ONRight &);
  ONRight &operator=(const ONRight &);
  ONRight();
  ~ONRight();
  virtual void accept(Visitor *v);
  virtual  ONRight  *clone() const;
  void swap(ONRight &);
};

class ONLeft : public OperatorName
{
 public:

  ONLeft(const ONLeft &);
  ONLeft &operator=(const ONLeft &);
  ONLeft();
  ~ONLeft();
  virtual void accept(Visitor *v);
  virtual  ONLeft  *clone() const;
  void swap(ONLeft &);
};


class OperatorTrait : public Visitable {
public:
  virtual OperatorTrait *clone() const = 0;
};

class OTIdentity : public OperatorTrait
{
 public:
  Type *type_;
  OperatorName *operatorname_;
  Expression *expression_;

  OTIdentity(const OTIdentity &);
  OTIdentity &operator=(const OTIdentity &);
  OTIdentity(Type *p1, OperatorName *p2, Expression *p3);
  ~OTIdentity();
  virtual void accept(Visitor *v);
  virtual  OTIdentity  *clone() const;
  void swap(OTIdentity &);
};


class FunctionSpecifier : public Visitable {
public:
  virtual FunctionSpecifier *clone() const = 0;
};

class FSEntryPoint : public FunctionSpecifier
{
 public:

  FSEntryPoint(const FSEntryPoint &);
  FSEntryPoint &operator=(const FSEntryPoint &);
  FSEntryPoint();
  ~FSEntryPoint();
  virtual void accept(Visitor *v);
  virtual  FSEntryPoint  *clone() const;
  void swap(FSEntryPoint &);
};

class FSPure : public FunctionSpecifier
{
 public:

  FSPure(const FSPure &);
  FSPure &operator=(const FSPure &);
  FSPure();
  ~FSPure();
  virtual void accept(Visitor *v);
  virtual  FSPure  *clone() const;
  void swap(FSPure &);
};

class FSInline : public FunctionSpecifier
{
 public:

  FSInline(const FSInline &);
  FSInline &operator=(const FSInline &);
  FSInline();
  ~FSInline();
  virtual void accept(Visitor *v);
  virtual  FSInline  *clone() const;
  void swap(FSInline &);
};

class FSAssociative : public FunctionSpecifier
{
 public:

  FSAssociative(const FSAssociative &);
  FSAssociative &operator=(const FSAssociative &);
  FSAssociative();
  ~FSAssociative();
  virtual void accept(Visitor *v);
  virtual  FSAssociative  *clone() const;
  void swap(FSAssociative &);
};

class FSCommutative : public FunctionSpecifier
{
 public:

  FSCommutative(const FSCommutative &);
  FSCommutative &operator=(const FSCommutative &);
  FSCommutative();
  ~FSCommutative();
  virtual void accept(Visitor *v);
  virtual  FSCommutative  *clone() const;
  void swap(FSCommutative &);
};

class FSAntiCommutative : public FunctionSpecifier
{
 public:

  FSAntiCommutative(const FSAntiCommutative &);
  FSAntiCommutative &operator=(const FSAntiCommutative &);
  FSAntiCommutative();
  ~FSAntiCommutative();
  virtual void accept(Visitor *v);
  virtual  FSAntiCommutative  *clone() const;
  void swap(FSAntiCommutative &);
};

class FSInverse : public FunctionSpecifier
{
 public:
  OperatorName *operatorname_;

  FSInverse(const FSInverse &);
  FSInverse &operator=(const FSInverse &);
  FSInverse(OperatorName *p1);
  ~FSInverse();
  virtual void accept(Visitor *v);
  virtual  FSInverse  *clone() const;
  void swap(FSInverse &);
};

class FSSelfInverse : public FunctionSpecifier
{
 public:

  FSSelfInverse(const FSSelfInverse &);
  FSSelfInverse &operator=(const FSSelfInverse &);
  FSSelfInverse();
  ~FSSelfInverse();
  virtual void accept(Visitor *v);
  virtual  FSSelfInverse  *clone() const;
  void swap(FSSelfInverse &);
};


class ConversionSpecifier : public Visitable {
public:
  virtual ConversionSpecifier *clone() const = 0;
};

class CSUp : public ConversionSpecifier
{
 public:

  CSUp(const CSUp &);
  CSUp &operator=(const CSUp &);
  CSUp();
  ~CSUp();
  virtual void accept(Visitor *v);
  virtual  CSUp  *clone() const;
  void swap(CSUp &);
};

class CSDown : public ConversionSpecifier
{
 public:

  CSDown(const CSDown &);
  CSDown &operator=(const CSDown &);
  CSDown();
  ~CSDown();
  virtual void accept(Visitor *v);
  virtual  CSDown  *clone() const;
  void swap(CSDown &);
};

class CSImplicit : public ConversionSpecifier
{
 public:

  CSImplicit(const CSImplicit &);
  CSImplicit &operator=(const CSImplicit &);
  CSImplicit();
  ~CSImplicit();
  virtual void accept(Visitor *v);
  virtual  CSImplicit  *clone() const;
  void swap(CSImplicit &);
};


class VariableSpecifier : public Visitable {
public:
  virtual VariableSpecifier *clone() const = 0;
};

class VSConst : public VariableSpecifier
{
 public:

  VSConst(const VSConst &);
  VSConst &operator=(const VSConst &);
  VSConst();
  ~VSConst();
  virtual void accept(Visitor *v);
  virtual  VSConst  *clone() const;
  void swap(VSConst &);
};


class TypeSpecifier : public Visitable {
public:
  virtual TypeSpecifier *clone() const = 0;
};

class TSAlign : public TypeSpecifier
{
 public:
  Integer integer_;

  TSAlign(const TSAlign &);
  TSAlign &operator=(const TSAlign &);
  TSAlign(Integer p1);
  ~TSAlign();
  virtual void accept(Visitor *v);
  virtual  TSAlign  *clone() const;
  void swap(TSAlign &);
};

class TSGeneric : public TypeSpecifier
{
 public:
  ListGenericParam *listgenericparam_;

  TSGeneric(const TSGeneric &);
  TSGeneric &operator=(const TSGeneric &);
  TSGeneric(ListGenericParam *p1);
  ~TSGeneric();
  virtual void accept(Visitor *v);
  virtual  TSGeneric  *clone() const;
  void swap(TSGeneric &);
};

class TSInteger : public TypeSpecifier
{
 public:

  TSInteger(const TSInteger &);
  TSInteger &operator=(const TSInteger &);
  TSInteger();
  ~TSInteger();
  virtual void accept(Visitor *v);
  virtual  TSInteger  *clone() const;
  void swap(TSInteger &);
};

class TSReal : public TypeSpecifier
{
 public:

  TSReal(const TSReal &);
  TSReal &operator=(const TSReal &);
  TSReal();
  ~TSReal();
  virtual void accept(Visitor *v);
  virtual  TSReal  *clone() const;
  void swap(TSReal &);
};


class GenericParam : public Visitable {
public:
  virtual GenericParam *clone() const = 0;
};

class TSGParam : public GenericParam
{
 public:
  Type *type_;
  Ident ident_;

  TSGParam(const TSGParam &);
  TSGParam &operator=(const TSGParam &);
  TSGParam(Type *p1, Ident p2);
  ~TSGParam();
  virtual void accept(Visitor *v);
  virtual  TSGParam  *clone() const;
  void swap(TSGParam &);
};


class Type : public Visitable {
public:
  virtual Type *clone() const = 0;
};

class TAddress : public Type
{
 public:

  TAddress(const TAddress &);
  TAddress &operator=(const TAddress &);
  TAddress();
  ~TAddress();
  virtual void accept(Visitor *v);
  virtual  TAddress  *clone() const;
  void swap(TAddress &);
};

class TByte : public Type
{
 public:

  TByte(const TByte &);
  TByte &operator=(const TByte &);
  TByte();
  ~TByte();
  virtual void accept(Visitor *v);
  virtual  TByte  *clone() const;
  void swap(TByte &);
};

class TCustom : public Type
{
 public:
  Ident ident_;

  TCustom(const TCustom &);
  TCustom &operator=(const TCustom &);
  TCustom(Ident p1);
  ~TCustom();
  virtual void accept(Visitor *v);
  virtual  TCustom  *clone() const;
  void swap(TCustom &);
};

class TFixedArray : public Type
{
 public:
  Type *type_;
  Integer integer_;

  TFixedArray(const TFixedArray &);
  TFixedArray &operator=(const TFixedArray &);
  TFixedArray(Type *p1, Integer p2);
  ~TFixedArray();
  virtual void accept(Visitor *v);
  virtual  TFixedArray  *clone() const;
  void swap(TFixedArray &);
};

class TGenericArray : public Type
{
 public:
  Type *type_;

  TGenericArray(const TGenericArray &);
  TGenericArray &operator=(const TGenericArray &);
  TGenericArray(Type *p1);
  ~TGenericArray();
  virtual void accept(Visitor *v);
  virtual  TGenericArray  *clone() const;
  void swap(TGenericArray &);
};

class TStruct : public Type
{
 public:
  ListStructMemberDeclaration *liststructmemberdeclaration_;

  TStruct(const TStruct &);
  TStruct &operator=(const TStruct &);
  TStruct(ListStructMemberDeclaration *p1);
  ~TStruct();
  virtual void accept(Visitor *v);
  virtual  TStruct  *clone() const;
  void swap(TStruct &);
};

class TType : public Type
{
 public:

  TType(const TType &);
  TType &operator=(const TType &);
  TType();
  ~TType();
  virtual void accept(Visitor *v);
  virtual  TType  *clone() const;
  void swap(TType &);
};


class StructMemberDeclaration : public Visitable {
public:
  virtual StructMemberDeclaration *clone() const = 0;
};

class SMDMemberDeclaration : public StructMemberDeclaration
{
 public:
  Type *type_;
  Ident ident_;

  SMDMemberDeclaration(const SMDMemberDeclaration &);
  SMDMemberDeclaration &operator=(const SMDMemberDeclaration &);
  SMDMemberDeclaration(Type *p1, Ident p2);
  ~SMDMemberDeclaration();
  virtual void accept(Visitor *v);
  virtual  SMDMemberDeclaration  *clone() const;
  void swap(SMDMemberDeclaration &);
};


class ParameterDeclaration : public Visitable {
public:
  virtual ParameterDeclaration *clone() const = 0;
};

class PDAutoParameter : public ParameterDeclaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Ident ident_;

  PDAutoParameter(const PDAutoParameter &);
  PDAutoParameter &operator=(const PDAutoParameter &);
  PDAutoParameter(ListVariableSpecifier *p1, Ident p2);
  ~PDAutoParameter();
  virtual void accept(Visitor *v);
  virtual  PDAutoParameter  *clone() const;
  void swap(PDAutoParameter &);
};

class PDTypedParameter : public ParameterDeclaration
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;

  PDTypedParameter(const PDTypedParameter &);
  PDTypedParameter &operator=(const PDTypedParameter &);
  PDTypedParameter(ListVariableSpecifier *p1, Type *p2, Ident p3);
  ~PDTypedParameter();
  virtual void accept(Visitor *v);
  virtual  PDTypedParameter  *clone() const;
  void swap(PDTypedParameter &);
};


class Statement : public Visitable {
public:
  virtual Statement *clone() const = 0;
};

class SReturn : public Statement
{
 public:
  Expression *expression_;

  SReturn(const SReturn &);
  SReturn &operator=(const SReturn &);
  SReturn(Expression *p1);
  ~SReturn();
  virtual void accept(Visitor *v);
  virtual  SReturn  *clone() const;
  void swap(SReturn &);
};

class SExpression : public Statement
{
 public:
  Expression *expression_;

  SExpression(const SExpression &);
  SExpression &operator=(const SExpression &);
  SExpression(Expression *p1);
  ~SExpression();
  virtual void accept(Visitor *v);
  virtual  SExpression  *clone() const;
  void swap(SExpression &);
};

class SScope : public Statement
{
 public:
  ListStatement *liststatement_;

  SScope(const SScope &);
  SScope &operator=(const SScope &);
  SScope(ListStatement *p1);
  ~SScope();
  virtual void accept(Visitor *v);
  virtual  SScope  *clone() const;
  void swap(SScope &);
};

class SIf : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Expression *p1, ListStatement *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual  SIf  *clone() const;
  void swap(SIf &);
};

class SIfElse : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_1, *liststatement_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Expression *p1, ListStatement *p2, ListStatement *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual  SIfElse  *clone() const;
  void swap(SIfElse &);
};

class SLoop : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SLoop(const SLoop &);
  SLoop &operator=(const SLoop &);
  SLoop(Expression *p1, ListStatement *p2);
  ~SLoop();
  virtual void accept(Visitor *v);
  virtual  SLoop  *clone() const;
  void swap(SLoop &);
};

class SWhile : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Expression *p1, ListStatement *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual  SWhile  *clone() const;
  void swap(SWhile &);
};

class SUntil : public Statement
{
 public:
  Expression *expression_;
  ListStatement *liststatement_;

  SUntil(const SUntil &);
  SUntil &operator=(const SUntil &);
  SUntil(Expression *p1, ListStatement *p2);
  ~SUntil();
  virtual void accept(Visitor *v);
  virtual  SUntil  *clone() const;
  void swap(SUntil &);
};

class SFor : public Statement
{
 public:
  ListExpression *listexpression_1, *listexpression_2;
  Expression *expression_;
  ListStatement *liststatement_;

  SFor(const SFor &);
  SFor &operator=(const SFor &);
  SFor(ListExpression *p1, Expression *p2, ListExpression *p3, ListStatement *p4);
  ~SFor();
  virtual void accept(Visitor *v);
  virtual  SFor  *clone() const;
  void swap(SFor &);
};

class SForEach : public Statement
{
 public:
  Ident ident_;
  Expression *expression_;
  ListStatement *liststatement_;

  SForEach(const SForEach &);
  SForEach &operator=(const SForEach &);
  SForEach(Ident p1, Expression *p2, ListStatement *p3);
  ~SForEach();
  virtual void accept(Visitor *v);
  virtual  SForEach  *clone() const;
  void swap(SForEach &);
};

class SForAll : public Statement
{
 public:
  Ident ident_;
  Expression *expression_;
  ListStatement *liststatement_;

  SForAll(const SForAll &);
  SForAll &operator=(const SForAll &);
  SForAll(Ident p1, Expression *p2, ListStatement *p3);
  ~SForAll();
  virtual void accept(Visitor *v);
  virtual  SForAll  *clone() const;
  void swap(SForAll &);
};

class SBreak : public Statement
{
 public:

  SBreak(const SBreak &);
  SBreak &operator=(const SBreak &);
  SBreak();
  ~SBreak();
  virtual void accept(Visitor *v);
  virtual  SBreak  *clone() const;
  void swap(SBreak &);
};

class SContinue : public Statement
{
 public:

  SContinue(const SContinue &);
  SContinue &operator=(const SContinue &);
  SContinue();
  ~SContinue();
  virtual void accept(Visitor *v);
  virtual  SContinue  *clone() const;
  void swap(SContinue &);
};

class SBreakpoint : public Statement
{
 public:

  SBreakpoint(const SBreakpoint &);
  SBreakpoint &operator=(const SBreakpoint &);
  SBreakpoint();
  ~SBreakpoint();
  virtual void accept(Visitor *v);
  virtual  SBreakpoint  *clone() const;
  void swap(SBreakpoint &);
};

class SIVariable : public Statement
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;
  Expression *expression_;

  SIVariable(const SIVariable &);
  SIVariable &operator=(const SIVariable &);
  SIVariable(ListVariableSpecifier *p1, Type *p2, Ident p3, Expression *p4);
  ~SIVariable();
  virtual void accept(Visitor *v);
  virtual  SIVariable  *clone() const;
  void swap(SIVariable &);
};

class SVariable : public Statement
{
 public:
  ListVariableSpecifier *listvariablespecifier_;
  Type *type_;
  Ident ident_;

  SVariable(const SVariable &);
  SVariable &operator=(const SVariable &);
  SVariable(ListVariableSpecifier *p1, Type *p2, Ident p3);
  ~SVariable();
  virtual void accept(Visitor *v);
  virtual  SVariable  *clone() const;
  void swap(SVariable &);
};


class RValue : public Visitable {
public:
  virtual RValue *clone() const = 0;
};

class RVIdent : public RValue
{
 public:
  Ident ident_;

  RVIdent(const RVIdent &);
  RVIdent &operator=(const RVIdent &);
  RVIdent(Ident p1);
  ~RVIdent();
  virtual void accept(Visitor *v);
  virtual  RVIdent  *clone() const;
  void swap(RVIdent &);
};

class RVQualified : public RValue
{
 public:
  Ident ident_;
  RValue *rvalue_;

  RVQualified(const RVQualified &);
  RVQualified &operator=(const RVQualified &);
  RVQualified(Ident p1, RValue *p2);
  ~RVQualified();
  virtual void accept(Visitor *v);
  virtual  RVQualified  *clone() const;
  void swap(RVQualified &);
};


class Expression : public Visitable {
public:
  virtual Expression *clone() const = 0;
};

class EDouble : public Expression
{
 public:
  Double double_;

  EDouble(const EDouble &);
  EDouble &operator=(const EDouble &);
  EDouble(Double p1);
  ~EDouble();
  virtual void accept(Visitor *v);
  virtual  EDouble  *clone() const;
  void swap(EDouble &);
};

class EInteger : public Expression
{
 public:
  Integer integer_;

  EInteger(const EInteger &);
  EInteger &operator=(const EInteger &);
  EInteger(Integer p1);
  ~EInteger();
  virtual void accept(Visitor *v);
  virtual  EInteger  *clone() const;
  void swap(EInteger &);
};

class EString : public Expression
{
 public:
  CString cstring_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(CString p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual  EString  *clone() const;
  void swap(EString &);
};

class EChar : public Expression
{
 public:
  CChar cchar_;

  EChar(const EChar &);
  EChar &operator=(const EChar &);
  EChar(CChar p1);
  ~EChar();
  virtual void accept(Visitor *v);
  virtual  EChar  *clone() const;
  void swap(EChar &);
};

class EPi : public Expression
{
 public:

  EPi(const EPi &);
  EPi &operator=(const EPi &);
  EPi();
  ~EPi();
  virtual void accept(Visitor *v);
  virtual  EPi  *clone() const;
  void swap(EPi &);
};

class ERValue : public Expression
{
 public:
  RValue *rvalue_;

  ERValue(const ERValue &);
  ERValue &operator=(const ERValue &);
  ERValue(RValue *p1);
  ~ERValue();
  virtual void accept(Visitor *v);
  virtual  ERValue  *clone() const;
  void swap(ERValue &);
};

class EArray : public Expression
{
 public:
  ListExpression *listexpression_;

  EArray(const EArray &);
  EArray &operator=(const EArray &);
  EArray(ListExpression *p1);
  ~EArray();
  virtual void accept(Visitor *v);
  virtual  EArray  *clone() const;
  void swap(EArray &);
};

class EList : public Expression
{
 public:
  ListExpression *listexpression_;

  EList(const EList &);
  EList &operator=(const EList &);
  EList(ListExpression *p1);
  ~EList();
  virtual void accept(Visitor *v);
  virtual  EList  *clone() const;
  void swap(EList &);
};

class EAComp : public Expression
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  EAComp(const EAComp &);
  EAComp &operator=(const EAComp &);
  EAComp(Expression *p1, ListExpression *p2);
  ~EAComp();
  virtual void accept(Visitor *v);
  virtual  EAComp  *clone() const;
  void swap(EAComp &);
};

class ELComp : public Expression
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  ELComp(const ELComp &);
  ELComp &operator=(const ELComp &);
  ELComp(Expression *p1, ListExpression *p2);
  ~ELComp();
  virtual void accept(Visitor *v);
  virtual  ELComp  *clone() const;
  void swap(ELComp &);
};

class EIndex : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIndex(const EIndex &);
  EIndex &operator=(const EIndex &);
  EIndex(Expression *p1, Expression *p2);
  ~EIndex();
  virtual void accept(Visitor *v);
  virtual  EIndex  *clone() const;
  void swap(EIndex &);
};

class ESimpleCall : public Expression
{
 public:
  RValue *rvalue_;

  ESimpleCall(const ESimpleCall &);
  ESimpleCall &operator=(const ESimpleCall &);
  ESimpleCall(RValue *p1);
  ~ESimpleCall();
  virtual void accept(Visitor *v);
  virtual  ESimpleCall  *clone() const;
  void swap(ESimpleCall &);
};

class ECall : public Expression
{
 public:
  RValue *rvalue_;
  ListExpression *listexpression_;

  ECall(const ECall &);
  ECall &operator=(const ECall &);
  ECall(RValue *p1, ListExpression *p2);
  ~ECall();
  virtual void accept(Visitor *v);
  virtual  ECall  *clone() const;
  void swap(ECall &);
};

class EPostInc : public Expression
{
 public:
  RValue *rvalue_;

  EPostInc(const EPostInc &);
  EPostInc &operator=(const EPostInc &);
  EPostInc(RValue *p1);
  ~EPostInc();
  virtual void accept(Visitor *v);
  virtual  EPostInc  *clone() const;
  void swap(EPostInc &);
};

class EPostDec : public Expression
{
 public:
  RValue *rvalue_;

  EPostDec(const EPostDec &);
  EPostDec &operator=(const EPostDec &);
  EPostDec(RValue *p1);
  ~EPostDec();
  virtual void accept(Visitor *v);
  virtual  EPostDec  *clone() const;
  void swap(EPostDec &);
};

class EAddress : public Expression
{
 public:
  Expression *expression_;

  EAddress(const EAddress &);
  EAddress &operator=(const EAddress &);
  EAddress(Expression *p1);
  ~EAddress();
  virtual void accept(Visitor *v);
  virtual  EAddress  *clone() const;
  void swap(EAddress &);
};

class EIntrinAddB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAddB(const EIntrinAddB &);
  EIntrinAddB &operator=(const EIntrinAddB &);
  EIntrinAddB(Expression *p1, Expression *p2);
  ~EIntrinAddB();
  virtual void accept(Visitor *v);
  virtual  EIntrinAddB  *clone() const;
  void swap(EIntrinAddB &);
};

class EIntrinSubB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSubB(const EIntrinSubB &);
  EIntrinSubB &operator=(const EIntrinSubB &);
  EIntrinSubB(Expression *p1, Expression *p2);
  ~EIntrinSubB();
  virtual void accept(Visitor *v);
  virtual  EIntrinSubB  *clone() const;
  void swap(EIntrinSubB &);
};

class EIntrinMulB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMulB(const EIntrinMulB &);
  EIntrinMulB &operator=(const EIntrinMulB &);
  EIntrinMulB(Expression *p1, Expression *p2);
  ~EIntrinMulB();
  virtual void accept(Visitor *v);
  virtual  EIntrinMulB  *clone() const;
  void swap(EIntrinMulB &);
};

class EIntrinUdivB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdivB(const EIntrinUdivB &);
  EIntrinUdivB &operator=(const EIntrinUdivB &);
  EIntrinUdivB(Expression *p1, Expression *p2);
  ~EIntrinUdivB();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdivB  *clone() const;
  void swap(EIntrinUdivB &);
};

class EIntrinSdivB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSdivB(const EIntrinSdivB &);
  EIntrinSdivB &operator=(const EIntrinSdivB &);
  EIntrinSdivB(Expression *p1, Expression *p2);
  ~EIntrinSdivB();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdivB  *clone() const;
  void swap(EIntrinSdivB &);
};

class EIntrinUremB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUremB(const EIntrinUremB &);
  EIntrinUremB &operator=(const EIntrinUremB &);
  EIntrinUremB(Expression *p1, Expression *p2);
  ~EIntrinUremB();
  virtual void accept(Visitor *v);
  virtual  EIntrinUremB  *clone() const;
  void swap(EIntrinUremB &);
};

class EIntrinSremB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSremB(const EIntrinSremB &);
  EIntrinSremB &operator=(const EIntrinSremB &);
  EIntrinSremB(Expression *p1, Expression *p2);
  ~EIntrinSremB();
  virtual void accept(Visitor *v);
  virtual  EIntrinSremB  *clone() const;
  void swap(EIntrinSremB &);
};

class EIntrinAndB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAndB(const EIntrinAndB &);
  EIntrinAndB &operator=(const EIntrinAndB &);
  EIntrinAndB(Expression *p1, Expression *p2);
  ~EIntrinAndB();
  virtual void accept(Visitor *v);
  virtual  EIntrinAndB  *clone() const;
  void swap(EIntrinAndB &);
};

class EIntrinOrB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinOrB(const EIntrinOrB &);
  EIntrinOrB &operator=(const EIntrinOrB &);
  EIntrinOrB(Expression *p1, Expression *p2);
  ~EIntrinOrB();
  virtual void accept(Visitor *v);
  virtual  EIntrinOrB  *clone() const;
  void swap(EIntrinOrB &);
};

class EIntrinXorB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinXorB(const EIntrinXorB &);
  EIntrinXorB &operator=(const EIntrinXorB &);
  EIntrinXorB(Expression *p1, Expression *p2);
  ~EIntrinXorB();
  virtual void accept(Visitor *v);
  virtual  EIntrinXorB  *clone() const;
  void swap(EIntrinXorB &);
};

class EIntrinShlB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinShlB(const EIntrinShlB &);
  EIntrinShlB &operator=(const EIntrinShlB &);
  EIntrinShlB(Expression *p1, Expression *p2);
  ~EIntrinShlB();
  virtual void accept(Visitor *v);
  virtual  EIntrinShlB  *clone() const;
  void swap(EIntrinShlB &);
};

class EIntrinLshrB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinLshrB(const EIntrinLshrB &);
  EIntrinLshrB &operator=(const EIntrinLshrB &);
  EIntrinLshrB(Expression *p1, Expression *p2);
  ~EIntrinLshrB();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshrB  *clone() const;
  void swap(EIntrinLshrB &);
};

class EIntrinAshrB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAshrB(const EIntrinAshrB &);
  EIntrinAshrB &operator=(const EIntrinAshrB &);
  EIntrinAshrB(Expression *p1, Expression *p2);
  ~EIntrinAshrB();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshrB  *clone() const;
  void swap(EIntrinAshrB &);
};

class EIntrinNotB : public Expression
{
 public:
  Expression *expression_;

  EIntrinNotB(const EIntrinNotB &);
  EIntrinNotB &operator=(const EIntrinNotB &);
  EIntrinNotB(Expression *p1);
  ~EIntrinNotB();
  virtual void accept(Visitor *v);
  virtual  EIntrinNotB  *clone() const;
  void swap(EIntrinNotB &);
};

class EIntrinNegB : public Expression
{
 public:
  Expression *expression_;

  EIntrinNegB(const EIntrinNegB &);
  EIntrinNegB &operator=(const EIntrinNegB &);
  EIntrinNegB(Expression *p1);
  ~EIntrinNegB();
  virtual void accept(Visitor *v);
  virtual  EIntrinNegB  *clone() const;
  void swap(EIntrinNegB &);
};

class EIntrinCEqB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCEqB(const EIntrinCEqB &);
  EIntrinCEqB &operator=(const EIntrinCEqB &);
  EIntrinCEqB(Expression *p1, Expression *p2);
  ~EIntrinCEqB();
  virtual void accept(Visitor *v);
  virtual  EIntrinCEqB  *clone() const;
  void swap(EIntrinCEqB &);
};

class EIntrinCNeB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCNeB(const EIntrinCNeB &);
  EIntrinCNeB &operator=(const EIntrinCNeB &);
  EIntrinCNeB(Expression *p1, Expression *p2);
  ~EIntrinCNeB();
  virtual void accept(Visitor *v);
  virtual  EIntrinCNeB  *clone() const;
  void swap(EIntrinCNeB &);
};

class EIntrinCLtB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLtB(const EIntrinCLtB &);
  EIntrinCLtB &operator=(const EIntrinCLtB &);
  EIntrinCLtB(Expression *p1, Expression *p2);
  ~EIntrinCLtB();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLtB  *clone() const;
  void swap(EIntrinCLtB &);
};

class EIntrinCGtB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGtB(const EIntrinCGtB &);
  EIntrinCGtB &operator=(const EIntrinCGtB &);
  EIntrinCGtB(Expression *p1, Expression *p2);
  ~EIntrinCGtB();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGtB  *clone() const;
  void swap(EIntrinCGtB &);
};

class EIntrinCLeB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLeB(const EIntrinCLeB &);
  EIntrinCLeB &operator=(const EIntrinCLeB &);
  EIntrinCLeB(Expression *p1, Expression *p2);
  ~EIntrinCLeB();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLeB  *clone() const;
  void swap(EIntrinCLeB &);
};

class EIntrinCGeB : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGeB(const EIntrinCGeB &);
  EIntrinCGeB &operator=(const EIntrinCGeB &);
  EIntrinCGeB(Expression *p1, Expression *p2);
  ~EIntrinCGeB();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGeB  *clone() const;
  void swap(EIntrinCGeB &);
};

class EIntrinAdd2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd2B(const EIntrinAdd2B &);
  EIntrinAdd2B &operator=(const EIntrinAdd2B &);
  EIntrinAdd2B(Expression *p1, Expression *p2);
  ~EIntrinAdd2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd2B  *clone() const;
  void swap(EIntrinAdd2B &);
};

class EIntrinSub2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub2B(const EIntrinSub2B &);
  EIntrinSub2B &operator=(const EIntrinSub2B &);
  EIntrinSub2B(Expression *p1, Expression *p2);
  ~EIntrinSub2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub2B  *clone() const;
  void swap(EIntrinSub2B &);
};

class EIntrinMul2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul2B(const EIntrinMul2B &);
  EIntrinMul2B &operator=(const EIntrinMul2B &);
  EIntrinMul2B(Expression *p1, Expression *p2);
  ~EIntrinMul2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul2B  *clone() const;
  void swap(EIntrinMul2B &);
};

class EIntrinUdiv2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv2B(const EIntrinUdiv2B &);
  EIntrinUdiv2B &operator=(const EIntrinUdiv2B &);
  EIntrinUdiv2B(Expression *p1, Expression *p2);
  ~EIntrinUdiv2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv2B  *clone() const;
  void swap(EIntrinUdiv2B &);
};

class EIntrinSdiv2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSdiv2B(const EIntrinSdiv2B &);
  EIntrinSdiv2B &operator=(const EIntrinSdiv2B &);
  EIntrinSdiv2B(Expression *p1, Expression *p2);
  ~EIntrinSdiv2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdiv2B  *clone() const;
  void swap(EIntrinSdiv2B &);
};

class EIntrinUrem2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem2B(const EIntrinUrem2B &);
  EIntrinUrem2B &operator=(const EIntrinUrem2B &);
  EIntrinUrem2B(Expression *p1, Expression *p2);
  ~EIntrinUrem2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem2B  *clone() const;
  void swap(EIntrinUrem2B &);
};

class EIntrinSrem2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSrem2B(const EIntrinSrem2B &);
  EIntrinSrem2B &operator=(const EIntrinSrem2B &);
  EIntrinSrem2B(Expression *p1, Expression *p2);
  ~EIntrinSrem2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSrem2B  *clone() const;
  void swap(EIntrinSrem2B &);
};

class EIntrinAnd2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAnd2B(const EIntrinAnd2B &);
  EIntrinAnd2B &operator=(const EIntrinAnd2B &);
  EIntrinAnd2B(Expression *p1, Expression *p2);
  ~EIntrinAnd2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAnd2B  *clone() const;
  void swap(EIntrinAnd2B &);
};

class EIntrinOr2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinOr2B(const EIntrinOr2B &);
  EIntrinOr2B &operator=(const EIntrinOr2B &);
  EIntrinOr2B(Expression *p1, Expression *p2);
  ~EIntrinOr2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinOr2B  *clone() const;
  void swap(EIntrinOr2B &);
};

class EIntrinXor2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinXor2B(const EIntrinXor2B &);
  EIntrinXor2B &operator=(const EIntrinXor2B &);
  EIntrinXor2B(Expression *p1, Expression *p2);
  ~EIntrinXor2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinXor2B  *clone() const;
  void swap(EIntrinXor2B &);
};

class EIntrinShl2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinShl2B(const EIntrinShl2B &);
  EIntrinShl2B &operator=(const EIntrinShl2B &);
  EIntrinShl2B(Expression *p1, Expression *p2);
  ~EIntrinShl2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinShl2B  *clone() const;
  void swap(EIntrinShl2B &);
};

class EIntrinLshr2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinLshr2B(const EIntrinLshr2B &);
  EIntrinLshr2B &operator=(const EIntrinLshr2B &);
  EIntrinLshr2B(Expression *p1, Expression *p2);
  ~EIntrinLshr2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshr2B  *clone() const;
  void swap(EIntrinLshr2B &);
};

class EIntrinAshr2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAshr2B(const EIntrinAshr2B &);
  EIntrinAshr2B &operator=(const EIntrinAshr2B &);
  EIntrinAshr2B(Expression *p1, Expression *p2);
  ~EIntrinAshr2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshr2B  *clone() const;
  void swap(EIntrinAshr2B &);
};

class EIntrinNot2B : public Expression
{
 public:
  Expression *expression_;

  EIntrinNot2B(const EIntrinNot2B &);
  EIntrinNot2B &operator=(const EIntrinNot2B &);
  EIntrinNot2B(Expression *p1);
  ~EIntrinNot2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinNot2B  *clone() const;
  void swap(EIntrinNot2B &);
};

class EIntrinNeg2B : public Expression
{
 public:
  Expression *expression_;

  EIntrinNeg2B(const EIntrinNeg2B &);
  EIntrinNeg2B &operator=(const EIntrinNeg2B &);
  EIntrinNeg2B(Expression *p1);
  ~EIntrinNeg2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinNeg2B  *clone() const;
  void swap(EIntrinNeg2B &);
};

class EIntrinCEq2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCEq2B(const EIntrinCEq2B &);
  EIntrinCEq2B &operator=(const EIntrinCEq2B &);
  EIntrinCEq2B(Expression *p1, Expression *p2);
  ~EIntrinCEq2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCEq2B  *clone() const;
  void swap(EIntrinCEq2B &);
};

class EIntrinCNe2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCNe2B(const EIntrinCNe2B &);
  EIntrinCNe2B &operator=(const EIntrinCNe2B &);
  EIntrinCNe2B(Expression *p1, Expression *p2);
  ~EIntrinCNe2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCNe2B  *clone() const;
  void swap(EIntrinCNe2B &);
};

class EIntrinCLt2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLt2B(const EIntrinCLt2B &);
  EIntrinCLt2B &operator=(const EIntrinCLt2B &);
  EIntrinCLt2B(Expression *p1, Expression *p2);
  ~EIntrinCLt2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLt2B  *clone() const;
  void swap(EIntrinCLt2B &);
};

class EIntrinCGt2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGt2B(const EIntrinCGt2B &);
  EIntrinCGt2B &operator=(const EIntrinCGt2B &);
  EIntrinCGt2B(Expression *p1, Expression *p2);
  ~EIntrinCGt2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGt2B  *clone() const;
  void swap(EIntrinCGt2B &);
};

class EIntrinCLe2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLe2B(const EIntrinCLe2B &);
  EIntrinCLe2B &operator=(const EIntrinCLe2B &);
  EIntrinCLe2B(Expression *p1, Expression *p2);
  ~EIntrinCLe2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLe2B  *clone() const;
  void swap(EIntrinCLe2B &);
};

class EIntrinCGe2B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGe2B(const EIntrinCGe2B &);
  EIntrinCGe2B &operator=(const EIntrinCGe2B &);
  EIntrinCGe2B(Expression *p1, Expression *p2);
  ~EIntrinCGe2B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGe2B  *clone() const;
  void swap(EIntrinCGe2B &);
};

class EIntrinAdd4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd4B(const EIntrinAdd4B &);
  EIntrinAdd4B &operator=(const EIntrinAdd4B &);
  EIntrinAdd4B(Expression *p1, Expression *p2);
  ~EIntrinAdd4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd4B  *clone() const;
  void swap(EIntrinAdd4B &);
};

class EIntrinSub4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub4B(const EIntrinSub4B &);
  EIntrinSub4B &operator=(const EIntrinSub4B &);
  EIntrinSub4B(Expression *p1, Expression *p2);
  ~EIntrinSub4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub4B  *clone() const;
  void swap(EIntrinSub4B &);
};

class EIntrinMul4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul4B(const EIntrinMul4B &);
  EIntrinMul4B &operator=(const EIntrinMul4B &);
  EIntrinMul4B(Expression *p1, Expression *p2);
  ~EIntrinMul4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul4B  *clone() const;
  void swap(EIntrinMul4B &);
};

class EIntrinUdiv4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv4B(const EIntrinUdiv4B &);
  EIntrinUdiv4B &operator=(const EIntrinUdiv4B &);
  EIntrinUdiv4B(Expression *p1, Expression *p2);
  ~EIntrinUdiv4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv4B  *clone() const;
  void swap(EIntrinUdiv4B &);
};

class EIntrinSdiv4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSdiv4B(const EIntrinSdiv4B &);
  EIntrinSdiv4B &operator=(const EIntrinSdiv4B &);
  EIntrinSdiv4B(Expression *p1, Expression *p2);
  ~EIntrinSdiv4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdiv4B  *clone() const;
  void swap(EIntrinSdiv4B &);
};

class EIntrinUrem4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem4B(const EIntrinUrem4B &);
  EIntrinUrem4B &operator=(const EIntrinUrem4B &);
  EIntrinUrem4B(Expression *p1, Expression *p2);
  ~EIntrinUrem4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem4B  *clone() const;
  void swap(EIntrinUrem4B &);
};

class EIntrinSrem4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSrem4B(const EIntrinSrem4B &);
  EIntrinSrem4B &operator=(const EIntrinSrem4B &);
  EIntrinSrem4B(Expression *p1, Expression *p2);
  ~EIntrinSrem4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSrem4B  *clone() const;
  void swap(EIntrinSrem4B &);
};

class EIntrinAnd4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAnd4B(const EIntrinAnd4B &);
  EIntrinAnd4B &operator=(const EIntrinAnd4B &);
  EIntrinAnd4B(Expression *p1, Expression *p2);
  ~EIntrinAnd4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAnd4B  *clone() const;
  void swap(EIntrinAnd4B &);
};

class EIntrinOr4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinOr4B(const EIntrinOr4B &);
  EIntrinOr4B &operator=(const EIntrinOr4B &);
  EIntrinOr4B(Expression *p1, Expression *p2);
  ~EIntrinOr4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinOr4B  *clone() const;
  void swap(EIntrinOr4B &);
};

class EIntrinXor4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinXor4B(const EIntrinXor4B &);
  EIntrinXor4B &operator=(const EIntrinXor4B &);
  EIntrinXor4B(Expression *p1, Expression *p2);
  ~EIntrinXor4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinXor4B  *clone() const;
  void swap(EIntrinXor4B &);
};

class EIntrinShl4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinShl4B(const EIntrinShl4B &);
  EIntrinShl4B &operator=(const EIntrinShl4B &);
  EIntrinShl4B(Expression *p1, Expression *p2);
  ~EIntrinShl4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinShl4B  *clone() const;
  void swap(EIntrinShl4B &);
};

class EIntrinLshr4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinLshr4B(const EIntrinLshr4B &);
  EIntrinLshr4B &operator=(const EIntrinLshr4B &);
  EIntrinLshr4B(Expression *p1, Expression *p2);
  ~EIntrinLshr4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshr4B  *clone() const;
  void swap(EIntrinLshr4B &);
};

class EIntrinAshr4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAshr4B(const EIntrinAshr4B &);
  EIntrinAshr4B &operator=(const EIntrinAshr4B &);
  EIntrinAshr4B(Expression *p1, Expression *p2);
  ~EIntrinAshr4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshr4B  *clone() const;
  void swap(EIntrinAshr4B &);
};

class EIntrinNot4B : public Expression
{
 public:
  Expression *expression_;

  EIntrinNot4B(const EIntrinNot4B &);
  EIntrinNot4B &operator=(const EIntrinNot4B &);
  EIntrinNot4B(Expression *p1);
  ~EIntrinNot4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinNot4B  *clone() const;
  void swap(EIntrinNot4B &);
};

class EIntrinNeg4B : public Expression
{
 public:
  Expression *expression_;

  EIntrinNeg4B(const EIntrinNeg4B &);
  EIntrinNeg4B &operator=(const EIntrinNeg4B &);
  EIntrinNeg4B(Expression *p1);
  ~EIntrinNeg4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinNeg4B  *clone() const;
  void swap(EIntrinNeg4B &);
};

class EIntrinCEq4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCEq4B(const EIntrinCEq4B &);
  EIntrinCEq4B &operator=(const EIntrinCEq4B &);
  EIntrinCEq4B(Expression *p1, Expression *p2);
  ~EIntrinCEq4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCEq4B  *clone() const;
  void swap(EIntrinCEq4B &);
};

class EIntrinCNe4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCNe4B(const EIntrinCNe4B &);
  EIntrinCNe4B &operator=(const EIntrinCNe4B &);
  EIntrinCNe4B(Expression *p1, Expression *p2);
  ~EIntrinCNe4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCNe4B  *clone() const;
  void swap(EIntrinCNe4B &);
};

class EIntrinCLt4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLt4B(const EIntrinCLt4B &);
  EIntrinCLt4B &operator=(const EIntrinCLt4B &);
  EIntrinCLt4B(Expression *p1, Expression *p2);
  ~EIntrinCLt4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLt4B  *clone() const;
  void swap(EIntrinCLt4B &);
};

class EIntrinCGt4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGt4B(const EIntrinCGt4B &);
  EIntrinCGt4B &operator=(const EIntrinCGt4B &);
  EIntrinCGt4B(Expression *p1, Expression *p2);
  ~EIntrinCGt4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGt4B  *clone() const;
  void swap(EIntrinCGt4B &);
};

class EIntrinCLe4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLe4B(const EIntrinCLe4B &);
  EIntrinCLe4B &operator=(const EIntrinCLe4B &);
  EIntrinCLe4B(Expression *p1, Expression *p2);
  ~EIntrinCLe4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLe4B  *clone() const;
  void swap(EIntrinCLe4B &);
};

class EIntrinCGe4B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGe4B(const EIntrinCGe4B &);
  EIntrinCGe4B &operator=(const EIntrinCGe4B &);
  EIntrinCGe4B(Expression *p1, Expression *p2);
  ~EIntrinCGe4B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGe4B  *clone() const;
  void swap(EIntrinCGe4B &);
};

class EIntrinAdd8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd8B(const EIntrinAdd8B &);
  EIntrinAdd8B &operator=(const EIntrinAdd8B &);
  EIntrinAdd8B(Expression *p1, Expression *p2);
  ~EIntrinAdd8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd8B  *clone() const;
  void swap(EIntrinAdd8B &);
};

class EIntrinSub8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub8B(const EIntrinSub8B &);
  EIntrinSub8B &operator=(const EIntrinSub8B &);
  EIntrinSub8B(Expression *p1, Expression *p2);
  ~EIntrinSub8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub8B  *clone() const;
  void swap(EIntrinSub8B &);
};

class EIntrinMul8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul8B(const EIntrinMul8B &);
  EIntrinMul8B &operator=(const EIntrinMul8B &);
  EIntrinMul8B(Expression *p1, Expression *p2);
  ~EIntrinMul8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul8B  *clone() const;
  void swap(EIntrinMul8B &);
};

class EIntrinUdiv8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv8B(const EIntrinUdiv8B &);
  EIntrinUdiv8B &operator=(const EIntrinUdiv8B &);
  EIntrinUdiv8B(Expression *p1, Expression *p2);
  ~EIntrinUdiv8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv8B  *clone() const;
  void swap(EIntrinUdiv8B &);
};

class EIntrinSdiv8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSdiv8B(const EIntrinSdiv8B &);
  EIntrinSdiv8B &operator=(const EIntrinSdiv8B &);
  EIntrinSdiv8B(Expression *p1, Expression *p2);
  ~EIntrinSdiv8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdiv8B  *clone() const;
  void swap(EIntrinSdiv8B &);
};

class EIntrinUrem8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem8B(const EIntrinUrem8B &);
  EIntrinUrem8B &operator=(const EIntrinUrem8B &);
  EIntrinUrem8B(Expression *p1, Expression *p2);
  ~EIntrinUrem8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem8B  *clone() const;
  void swap(EIntrinUrem8B &);
};

class EIntrinSrem8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSrem8B(const EIntrinSrem8B &);
  EIntrinSrem8B &operator=(const EIntrinSrem8B &);
  EIntrinSrem8B(Expression *p1, Expression *p2);
  ~EIntrinSrem8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinSrem8B  *clone() const;
  void swap(EIntrinSrem8B &);
};

class EIntrinAnd8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAnd8B(const EIntrinAnd8B &);
  EIntrinAnd8B &operator=(const EIntrinAnd8B &);
  EIntrinAnd8B(Expression *p1, Expression *p2);
  ~EIntrinAnd8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAnd8B  *clone() const;
  void swap(EIntrinAnd8B &);
};

class EIntrinOr8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinOr8B(const EIntrinOr8B &);
  EIntrinOr8B &operator=(const EIntrinOr8B &);
  EIntrinOr8B(Expression *p1, Expression *p2);
  ~EIntrinOr8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinOr8B  *clone() const;
  void swap(EIntrinOr8B &);
};

class EIntrinXor8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinXor8B(const EIntrinXor8B &);
  EIntrinXor8B &operator=(const EIntrinXor8B &);
  EIntrinXor8B(Expression *p1, Expression *p2);
  ~EIntrinXor8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinXor8B  *clone() const;
  void swap(EIntrinXor8B &);
};

class EIntrinShl8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinShl8B(const EIntrinShl8B &);
  EIntrinShl8B &operator=(const EIntrinShl8B &);
  EIntrinShl8B(Expression *p1, Expression *p2);
  ~EIntrinShl8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinShl8B  *clone() const;
  void swap(EIntrinShl8B &);
};

class EIntrinLshr8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinLshr8B(const EIntrinLshr8B &);
  EIntrinLshr8B &operator=(const EIntrinLshr8B &);
  EIntrinLshr8B(Expression *p1, Expression *p2);
  ~EIntrinLshr8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshr8B  *clone() const;
  void swap(EIntrinLshr8B &);
};

class EIntrinAshr8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAshr8B(const EIntrinAshr8B &);
  EIntrinAshr8B &operator=(const EIntrinAshr8B &);
  EIntrinAshr8B(Expression *p1, Expression *p2);
  ~EIntrinAshr8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshr8B  *clone() const;
  void swap(EIntrinAshr8B &);
};

class EIntrinNot8B : public Expression
{
 public:
  Expression *expression_;

  EIntrinNot8B(const EIntrinNot8B &);
  EIntrinNot8B &operator=(const EIntrinNot8B &);
  EIntrinNot8B(Expression *p1);
  ~EIntrinNot8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinNot8B  *clone() const;
  void swap(EIntrinNot8B &);
};

class EIntrinNeg8B : public Expression
{
 public:
  Expression *expression_;

  EIntrinNeg8B(const EIntrinNeg8B &);
  EIntrinNeg8B &operator=(const EIntrinNeg8B &);
  EIntrinNeg8B(Expression *p1);
  ~EIntrinNeg8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinNeg8B  *clone() const;
  void swap(EIntrinNeg8B &);
};

class EIntrinCEq8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCEq8B(const EIntrinCEq8B &);
  EIntrinCEq8B &operator=(const EIntrinCEq8B &);
  EIntrinCEq8B(Expression *p1, Expression *p2);
  ~EIntrinCEq8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCEq8B  *clone() const;
  void swap(EIntrinCEq8B &);
};

class EIntrinCNe8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCNe8B(const EIntrinCNe8B &);
  EIntrinCNe8B &operator=(const EIntrinCNe8B &);
  EIntrinCNe8B(Expression *p1, Expression *p2);
  ~EIntrinCNe8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCNe8B  *clone() const;
  void swap(EIntrinCNe8B &);
};

class EIntrinCLt8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLt8B(const EIntrinCLt8B &);
  EIntrinCLt8B &operator=(const EIntrinCLt8B &);
  EIntrinCLt8B(Expression *p1, Expression *p2);
  ~EIntrinCLt8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLt8B  *clone() const;
  void swap(EIntrinCLt8B &);
};

class EIntrinCGt8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGt8B(const EIntrinCGt8B &);
  EIntrinCGt8B &operator=(const EIntrinCGt8B &);
  EIntrinCGt8B(Expression *p1, Expression *p2);
  ~EIntrinCGt8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGt8B  *clone() const;
  void swap(EIntrinCGt8B &);
};

class EIntrinCLe8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCLe8B(const EIntrinCLe8B &);
  EIntrinCLe8B &operator=(const EIntrinCLe8B &);
  EIntrinCLe8B(Expression *p1, Expression *p2);
  ~EIntrinCLe8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCLe8B  *clone() const;
  void swap(EIntrinCLe8B &);
};

class EIntrinCGe8B : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinCGe8B(const EIntrinCGe8B &);
  EIntrinCGe8B &operator=(const EIntrinCGe8B &);
  EIntrinCGe8B(Expression *p1, Expression *p2);
  ~EIntrinCGe8B();
  virtual void accept(Visitor *v);
  virtual  EIntrinCGe8B  *clone() const;
  void swap(EIntrinCGe8B &);
};

class EIntrinAddB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAddB4V(const EIntrinAddB4V &);
  EIntrinAddB4V &operator=(const EIntrinAddB4V &);
  EIntrinAddB4V(Expression *p1, Expression *p2);
  ~EIntrinAddB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinAddB4V  *clone() const;
  void swap(EIntrinAddB4V &);
};

class EIntrinSubB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSubB4V(const EIntrinSubB4V &);
  EIntrinSubB4V &operator=(const EIntrinSubB4V &);
  EIntrinSubB4V(Expression *p1, Expression *p2);
  ~EIntrinSubB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSubB4V  *clone() const;
  void swap(EIntrinSubB4V &);
};

class EIntrinMulB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMulB4V(const EIntrinMulB4V &);
  EIntrinMulB4V &operator=(const EIntrinMulB4V &);
  EIntrinMulB4V(Expression *p1, Expression *p2);
  ~EIntrinMulB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinMulB4V  *clone() const;
  void swap(EIntrinMulB4V &);
};

class EIntrinUdivB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdivB4V(const EIntrinUdivB4V &);
  EIntrinUdivB4V &operator=(const EIntrinUdivB4V &);
  EIntrinUdivB4V(Expression *p1, Expression *p2);
  ~EIntrinUdivB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdivB4V  *clone() const;
  void swap(EIntrinUdivB4V &);
};

class EIntrinSdivB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSdivB4V(const EIntrinSdivB4V &);
  EIntrinSdivB4V &operator=(const EIntrinSdivB4V &);
  EIntrinSdivB4V(Expression *p1, Expression *p2);
  ~EIntrinSdivB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdivB4V  *clone() const;
  void swap(EIntrinSdivB4V &);
};

class EIntrinUremB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUremB4V(const EIntrinUremB4V &);
  EIntrinUremB4V &operator=(const EIntrinUremB4V &);
  EIntrinUremB4V(Expression *p1, Expression *p2);
  ~EIntrinUremB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinUremB4V  *clone() const;
  void swap(EIntrinUremB4V &);
};

class EIntrinSremB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSremB4V(const EIntrinSremB4V &);
  EIntrinSremB4V &operator=(const EIntrinSremB4V &);
  EIntrinSremB4V(Expression *p1, Expression *p2);
  ~EIntrinSremB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSremB4V  *clone() const;
  void swap(EIntrinSremB4V &);
};

class EIntrinShlB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinShlB4V(const EIntrinShlB4V &);
  EIntrinShlB4V &operator=(const EIntrinShlB4V &);
  EIntrinShlB4V(Expression *p1, Expression *p2);
  ~EIntrinShlB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinShlB4V  *clone() const;
  void swap(EIntrinShlB4V &);
};

class EIntrinLshrB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinLshrB4V(const EIntrinLshrB4V &);
  EIntrinLshrB4V &operator=(const EIntrinLshrB4V &);
  EIntrinLshrB4V(Expression *p1, Expression *p2);
  ~EIntrinLshrB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshrB4V  *clone() const;
  void swap(EIntrinLshrB4V &);
};

class EIntrinAshrB4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAshrB4V(const EIntrinAshrB4V &);
  EIntrinAshrB4V &operator=(const EIntrinAshrB4V &);
  EIntrinAshrB4V(Expression *p1, Expression *p2);
  ~EIntrinAshrB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshrB4V  *clone() const;
  void swap(EIntrinAshrB4V &);
};

class EIntrinNegB4V : public Expression
{
 public:
  Expression *expression_;

  EIntrinNegB4V(const EIntrinNegB4V &);
  EIntrinNegB4V &operator=(const EIntrinNegB4V &);
  EIntrinNegB4V(Expression *p1);
  ~EIntrinNegB4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinNegB4V  *clone() const;
  void swap(EIntrinNegB4V &);
};

class EIntrinAddB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAddB8V(const EIntrinAddB8V &);
  EIntrinAddB8V &operator=(const EIntrinAddB8V &);
  EIntrinAddB8V(Expression *p1, Expression *p2);
  ~EIntrinAddB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinAddB8V  *clone() const;
  void swap(EIntrinAddB8V &);
};

class EIntrinSubB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSubB8V(const EIntrinSubB8V &);
  EIntrinSubB8V &operator=(const EIntrinSubB8V &);
  EIntrinSubB8V(Expression *p1, Expression *p2);
  ~EIntrinSubB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSubB8V  *clone() const;
  void swap(EIntrinSubB8V &);
};

class EIntrinMulB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMulB8V(const EIntrinMulB8V &);
  EIntrinMulB8V &operator=(const EIntrinMulB8V &);
  EIntrinMulB8V(Expression *p1, Expression *p2);
  ~EIntrinMulB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinMulB8V  *clone() const;
  void swap(EIntrinMulB8V &);
};

class EIntrinUdivB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdivB8V(const EIntrinUdivB8V &);
  EIntrinUdivB8V &operator=(const EIntrinUdivB8V &);
  EIntrinUdivB8V(Expression *p1, Expression *p2);
  ~EIntrinUdivB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdivB8V  *clone() const;
  void swap(EIntrinUdivB8V &);
};

class EIntrinSdivB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSdivB8V(const EIntrinSdivB8V &);
  EIntrinSdivB8V &operator=(const EIntrinSdivB8V &);
  EIntrinSdivB8V(Expression *p1, Expression *p2);
  ~EIntrinSdivB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSdivB8V  *clone() const;
  void swap(EIntrinSdivB8V &);
};

class EIntrinUremB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUremB8V(const EIntrinUremB8V &);
  EIntrinUremB8V &operator=(const EIntrinUremB8V &);
  EIntrinUremB8V(Expression *p1, Expression *p2);
  ~EIntrinUremB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinUremB8V  *clone() const;
  void swap(EIntrinUremB8V &);
};

class EIntrinSremB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSremB8V(const EIntrinSremB8V &);
  EIntrinSremB8V &operator=(const EIntrinSremB8V &);
  EIntrinSremB8V(Expression *p1, Expression *p2);
  ~EIntrinSremB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSremB8V  *clone() const;
  void swap(EIntrinSremB8V &);
};

class EIntrinShlB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinShlB8V(const EIntrinShlB8V &);
  EIntrinShlB8V &operator=(const EIntrinShlB8V &);
  EIntrinShlB8V(Expression *p1, Expression *p2);
  ~EIntrinShlB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinShlB8V  *clone() const;
  void swap(EIntrinShlB8V &);
};

class EIntrinLshrB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinLshrB8V(const EIntrinLshrB8V &);
  EIntrinLshrB8V &operator=(const EIntrinLshrB8V &);
  EIntrinLshrB8V(Expression *p1, Expression *p2);
  ~EIntrinLshrB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinLshrB8V  *clone() const;
  void swap(EIntrinLshrB8V &);
};

class EIntrinAshrB8V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAshrB8V(const EIntrinAshrB8V &);
  EIntrinAshrB8V &operator=(const EIntrinAshrB8V &);
  EIntrinAshrB8V(Expression *p1, Expression *p2);
  ~EIntrinAshrB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinAshrB8V  *clone() const;
  void swap(EIntrinAshrB8V &);
};

class EIntrinNegB8V : public Expression
{
 public:
  Expression *expression_;

  EIntrinNegB8V(const EIntrinNegB8V &);
  EIntrinNegB8V &operator=(const EIntrinNegB8V &);
  EIntrinNegB8V(Expression *p1);
  ~EIntrinNegB8V();
  virtual void accept(Visitor *v);
  virtual  EIntrinNegB8V  *clone() const;
  void swap(EIntrinNegB8V &);
};

class EIntrinAdd2F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd2F(const EIntrinAdd2F &);
  EIntrinAdd2F &operator=(const EIntrinAdd2F &);
  EIntrinAdd2F(Expression *p1, Expression *p2);
  ~EIntrinAdd2F();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd2F  *clone() const;
  void swap(EIntrinAdd2F &);
};

class EIntrinSub2F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub2F(const EIntrinSub2F &);
  EIntrinSub2F &operator=(const EIntrinSub2F &);
  EIntrinSub2F(Expression *p1, Expression *p2);
  ~EIntrinSub2F();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub2F  *clone() const;
  void swap(EIntrinSub2F &);
};

class EIntrinMul2F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul2F(const EIntrinMul2F &);
  EIntrinMul2F &operator=(const EIntrinMul2F &);
  EIntrinMul2F(Expression *p1, Expression *p2);
  ~EIntrinMul2F();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul2F  *clone() const;
  void swap(EIntrinMul2F &);
};

class EIntrinUdiv2F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv2F(const EIntrinUdiv2F &);
  EIntrinUdiv2F &operator=(const EIntrinUdiv2F &);
  EIntrinUdiv2F(Expression *p1, Expression *p2);
  ~EIntrinUdiv2F();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv2F  *clone() const;
  void swap(EIntrinUdiv2F &);
};

class EIntrinUrem2F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem2F(const EIntrinUrem2F &);
  EIntrinUrem2F &operator=(const EIntrinUrem2F &);
  EIntrinUrem2F(Expression *p1, Expression *p2);
  ~EIntrinUrem2F();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem2F  *clone() const;
  void swap(EIntrinUrem2F &);
};

class EIntrinAdd4F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd4F(const EIntrinAdd4F &);
  EIntrinAdd4F &operator=(const EIntrinAdd4F &);
  EIntrinAdd4F(Expression *p1, Expression *p2);
  ~EIntrinAdd4F();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd4F  *clone() const;
  void swap(EIntrinAdd4F &);
};

class EIntrinSub4F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub4F(const EIntrinSub4F &);
  EIntrinSub4F &operator=(const EIntrinSub4F &);
  EIntrinSub4F(Expression *p1, Expression *p2);
  ~EIntrinSub4F();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub4F  *clone() const;
  void swap(EIntrinSub4F &);
};

class EIntrinMul4F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul4F(const EIntrinMul4F &);
  EIntrinMul4F &operator=(const EIntrinMul4F &);
  EIntrinMul4F(Expression *p1, Expression *p2);
  ~EIntrinMul4F();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul4F  *clone() const;
  void swap(EIntrinMul4F &);
};

class EIntrinUdiv4F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv4F(const EIntrinUdiv4F &);
  EIntrinUdiv4F &operator=(const EIntrinUdiv4F &);
  EIntrinUdiv4F(Expression *p1, Expression *p2);
  ~EIntrinUdiv4F();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv4F  *clone() const;
  void swap(EIntrinUdiv4F &);
};

class EIntrinUrem4F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem4F(const EIntrinUrem4F &);
  EIntrinUrem4F &operator=(const EIntrinUrem4F &);
  EIntrinUrem4F(Expression *p1, Expression *p2);
  ~EIntrinUrem4F();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem4F  *clone() const;
  void swap(EIntrinUrem4F &);
};

class EIntrinAdd8F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd8F(const EIntrinAdd8F &);
  EIntrinAdd8F &operator=(const EIntrinAdd8F &);
  EIntrinAdd8F(Expression *p1, Expression *p2);
  ~EIntrinAdd8F();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd8F  *clone() const;
  void swap(EIntrinAdd8F &);
};

class EIntrinSub8F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub8F(const EIntrinSub8F &);
  EIntrinSub8F &operator=(const EIntrinSub8F &);
  EIntrinSub8F(Expression *p1, Expression *p2);
  ~EIntrinSub8F();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub8F  *clone() const;
  void swap(EIntrinSub8F &);
};

class EIntrinMul8F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul8F(const EIntrinMul8F &);
  EIntrinMul8F &operator=(const EIntrinMul8F &);
  EIntrinMul8F(Expression *p1, Expression *p2);
  ~EIntrinMul8F();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul8F  *clone() const;
  void swap(EIntrinMul8F &);
};

class EIntrinUdiv8F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv8F(const EIntrinUdiv8F &);
  EIntrinUdiv8F &operator=(const EIntrinUdiv8F &);
  EIntrinUdiv8F(Expression *p1, Expression *p2);
  ~EIntrinUdiv8F();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv8F  *clone() const;
  void swap(EIntrinUdiv8F &);
};

class EIntrinUrem8F : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem8F(const EIntrinUrem8F &);
  EIntrinUrem8F &operator=(const EIntrinUrem8F &);
  EIntrinUrem8F(Expression *p1, Expression *p2);
  ~EIntrinUrem8F();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem8F  *clone() const;
  void swap(EIntrinUrem8F &);
};

class EIntrinAdd4F4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinAdd4F4V(const EIntrinAdd4F4V &);
  EIntrinAdd4F4V &operator=(const EIntrinAdd4F4V &);
  EIntrinAdd4F4V(Expression *p1, Expression *p2);
  ~EIntrinAdd4F4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinAdd4F4V  *clone() const;
  void swap(EIntrinAdd4F4V &);
};

class EIntrinSub4F4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinSub4F4V(const EIntrinSub4F4V &);
  EIntrinSub4F4V &operator=(const EIntrinSub4F4V &);
  EIntrinSub4F4V(Expression *p1, Expression *p2);
  ~EIntrinSub4F4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinSub4F4V  *clone() const;
  void swap(EIntrinSub4F4V &);
};

class EIntrinMul4F4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinMul4F4V(const EIntrinMul4F4V &);
  EIntrinMul4F4V &operator=(const EIntrinMul4F4V &);
  EIntrinMul4F4V(Expression *p1, Expression *p2);
  ~EIntrinMul4F4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinMul4F4V  *clone() const;
  void swap(EIntrinMul4F4V &);
};

class EIntrinUdiv4F4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUdiv4F4V(const EIntrinUdiv4F4V &);
  EIntrinUdiv4F4V &operator=(const EIntrinUdiv4F4V &);
  EIntrinUdiv4F4V(Expression *p1, Expression *p2);
  ~EIntrinUdiv4F4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinUdiv4F4V  *clone() const;
  void swap(EIntrinUdiv4F4V &);
};

class EIntrinUrem4F4V : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EIntrinUrem4F4V(const EIntrinUrem4F4V &);
  EIntrinUrem4F4V &operator=(const EIntrinUrem4F4V &);
  EIntrinUrem4F4V(Expression *p1, Expression *p2);
  ~EIntrinUrem4F4V();
  virtual void accept(Visitor *v);
  virtual  EIntrinUrem4F4V  *clone() const;
  void swap(EIntrinUrem4F4V &);
};

class ELnot : public Expression
{
 public:
  Expression *expression_;

  ELnot(const ELnot &);
  ELnot &operator=(const ELnot &);
  ELnot(Expression *p1);
  ~ELnot();
  virtual void accept(Visitor *v);
  virtual  ELnot  *clone() const;
  void swap(ELnot &);
};

class EPreInc : public Expression
{
 public:
  RValue *rvalue_;

  EPreInc(const EPreInc &);
  EPreInc &operator=(const EPreInc &);
  EPreInc(RValue *p1);
  ~EPreInc();
  virtual void accept(Visitor *v);
  virtual  EPreInc  *clone() const;
  void swap(EPreInc &);
};

class EPreDec : public Expression
{
 public:
  RValue *rvalue_;

  EPreDec(const EPreDec &);
  EPreDec &operator=(const EPreDec &);
  EPreDec(RValue *p1);
  ~EPreDec();
  virtual void accept(Visitor *v);
  virtual  EPreDec  *clone() const;
  void swap(EPreDec &);
};

class ENeg : public Expression
{
 public:
  Expression *expression_;

  ENeg(const ENeg &);
  ENeg &operator=(const ENeg &);
  ENeg(Expression *p1);
  ~ENeg();
  virtual void accept(Visitor *v);
  virtual  ENeg  *clone() const;
  void swap(ENeg &);
};

class EBnot : public Expression
{
 public:
  Expression *expression_;

  EBnot(const EBnot &);
  EBnot &operator=(const EBnot &);
  EBnot(Expression *p1);
  ~EBnot();
  virtual void accept(Visitor *v);
  virtual  EBnot  *clone() const;
  void swap(EBnot &);
};

class EPos : public Expression
{
 public:
  Expression *expression_;

  EPos(const EPos &);
  EPos &operator=(const EPos &);
  EPos(Expression *p1);
  ~EPos();
  virtual void accept(Visitor *v);
  virtual  EPos  *clone() const;
  void swap(EPos &);
};

class EMul : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Expression *p1, Expression *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual  EMul  *clone() const;
  void swap(EMul &);
};

class EDiv : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Expression *p1, Expression *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual  EDiv  *clone() const;
  void swap(EDiv &);
};

class EMod : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EMod(const EMod &);
  EMod &operator=(const EMod &);
  EMod(Expression *p1, Expression *p2);
  ~EMod();
  virtual void accept(Visitor *v);
  virtual  EMod  *clone() const;
  void swap(EMod &);
};

class EAdd : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Expression *p1, Expression *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual  EAdd  *clone() const;
  void swap(EAdd &);
};

class ESub : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Expression *p1, Expression *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual  ESub  *clone() const;
  void swap(ESub &);
};

class ELSh : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELSh(const ELSh &);
  ELSh &operator=(const ELSh &);
  ELSh(Expression *p1, Expression *p2);
  ~ELSh();
  virtual void accept(Visitor *v);
  virtual  ELSh  *clone() const;
  void swap(ELSh &);
};

class ERSh : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ERSh(const ERSh &);
  ERSh &operator=(const ERSh &);
  ERSh(Expression *p1, Expression *p2);
  ~ERSh();
  virtual void accept(Visitor *v);
  virtual  ERSh  *clone() const;
  void swap(ERSh &);
};

class ELT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELT(const ELT &);
  ELT &operator=(const ELT &);
  ELT(Expression *p1, Expression *p2);
  ~ELT();
  virtual void accept(Visitor *v);
  virtual  ELT  *clone() const;
  void swap(ELT &);
};

class EGT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EGT(const EGT &);
  EGT &operator=(const EGT &);
  EGT(Expression *p1, Expression *p2);
  ~EGT();
  virtual void accept(Visitor *v);
  virtual  EGT  *clone() const;
  void swap(EGT &);
};

class ELE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELE(const ELE &);
  ELE &operator=(const ELE &);
  ELE(Expression *p1, Expression *p2);
  ~ELE();
  virtual void accept(Visitor *v);
  virtual  ELE  *clone() const;
  void swap(ELE &);
};

class EGE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EGE(const EGE &);
  EGE &operator=(const EGE &);
  EGE(Expression *p1, Expression *p2);
  ~EGE();
  virtual void accept(Visitor *v);
  virtual  EGE  *clone() const;
  void swap(EGE &);
};

class EE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EE(const EE &);
  EE &operator=(const EE &);
  EE(Expression *p1, Expression *p2);
  ~EE();
  virtual void accept(Visitor *v);
  virtual  EE  *clone() const;
  void swap(EE &);
};

class ENE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ENE(const ENE &);
  ENE &operator=(const ENE &);
  ENE(Expression *p1, Expression *p2);
  ~ENE();
  virtual void accept(Visitor *v);
  virtual  ENE  *clone() const;
  void swap(ENE &);
};

class EBand : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBand(const EBand &);
  EBand &operator=(const EBand &);
  EBand(Expression *p1, Expression *p2);
  ~EBand();
  virtual void accept(Visitor *v);
  virtual  EBand  *clone() const;
  void swap(EBand &);
};

class EBor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBor(const EBor &);
  EBor &operator=(const EBor &);
  EBor(Expression *p1, Expression *p2);
  ~EBor();
  virtual void accept(Visitor *v);
  virtual  EBor  *clone() const;
  void swap(EBor &);
};

class EBxor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBxor(const EBxor &);
  EBxor &operator=(const EBxor &);
  EBxor(Expression *p1, Expression *p2);
  ~EBxor();
  virtual void accept(Visitor *v);
  virtual  EBxor  *clone() const;
  void swap(EBxor &);
};

class ELand : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELand(const ELand &);
  ELand &operator=(const ELand &);
  ELand(Expression *p1, Expression *p2);
  ~ELand();
  virtual void accept(Visitor *v);
  virtual  ELand  *clone() const;
  void swap(ELand &);
};

class ELor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELor(const ELor &);
  ELor &operator=(const ELor &);
  ELor(Expression *p1, Expression *p2);
  ~ELor();
  virtual void accept(Visitor *v);
  virtual  ELor  *clone() const;
  void swap(ELor &);
};

class ELxor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELxor(const ELxor &);
  ELxor &operator=(const ELxor &);
  ELxor(Expression *p1, Expression *p2);
  ~ELxor();
  virtual void accept(Visitor *v);
  virtual  ELxor  *clone() const;
  void swap(ELxor &);
};

class EConditional : public Expression
{
 public:
  Expression *expression_1, *expression_2, *expression_3;

  EConditional(const EConditional &);
  EConditional &operator=(const EConditional &);
  EConditional(Expression *p1, Expression *p2, Expression *p3);
  ~EConditional();
  virtual void accept(Visitor *v);
  virtual  EConditional  *clone() const;
  void swap(EConditional &);
};

class EAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EAssign(const EAssign &);
  EAssign &operator=(const EAssign &);
  EAssign(RValue *p1, Expression *p2);
  ~EAssign();
  virtual void accept(Visitor *v);
  virtual  EAssign  *clone() const;
  void swap(EAssign &);
};

class EAddAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EAddAssign(const EAddAssign &);
  EAddAssign &operator=(const EAddAssign &);
  EAddAssign(RValue *p1, Expression *p2);
  ~EAddAssign();
  virtual void accept(Visitor *v);
  virtual  EAddAssign  *clone() const;
  void swap(EAddAssign &);
};

class ESubAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  ESubAssign(const ESubAssign &);
  ESubAssign &operator=(const ESubAssign &);
  ESubAssign(RValue *p1, Expression *p2);
  ~ESubAssign();
  virtual void accept(Visitor *v);
  virtual  ESubAssign  *clone() const;
  void swap(ESubAssign &);
};

class EMulAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EMulAssign(const EMulAssign &);
  EMulAssign &operator=(const EMulAssign &);
  EMulAssign(RValue *p1, Expression *p2);
  ~EMulAssign();
  virtual void accept(Visitor *v);
  virtual  EMulAssign  *clone() const;
  void swap(EMulAssign &);
};

class EDivAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EDivAssign(const EDivAssign &);
  EDivAssign &operator=(const EDivAssign &);
  EDivAssign(RValue *p1, Expression *p2);
  ~EDivAssign();
  virtual void accept(Visitor *v);
  virtual  EDivAssign  *clone() const;
  void swap(EDivAssign &);
};

class EModAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EModAssign(const EModAssign &);
  EModAssign &operator=(const EModAssign &);
  EModAssign(RValue *p1, Expression *p2);
  ~EModAssign();
  virtual void accept(Visitor *v);
  virtual  EModAssign  *clone() const;
  void swap(EModAssign &);
};

class EAndAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EAndAssign(const EAndAssign &);
  EAndAssign &operator=(const EAndAssign &);
  EAndAssign(RValue *p1, Expression *p2);
  ~EAndAssign();
  virtual void accept(Visitor *v);
  virtual  EAndAssign  *clone() const;
  void swap(EAndAssign &);
};

class EOrAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EOrAssign(const EOrAssign &);
  EOrAssign &operator=(const EOrAssign &);
  EOrAssign(RValue *p1, Expression *p2);
  ~EOrAssign();
  virtual void accept(Visitor *v);
  virtual  EOrAssign  *clone() const;
  void swap(EOrAssign &);
};

class EXorAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  EXorAssign(const EXorAssign &);
  EXorAssign &operator=(const EXorAssign &);
  EXorAssign(RValue *p1, Expression *p2);
  ~EXorAssign();
  virtual void accept(Visitor *v);
  virtual  EXorAssign  *clone() const;
  void swap(EXorAssign &);
};

class ELShAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  ELShAssign(const ELShAssign &);
  ELShAssign &operator=(const ELShAssign &);
  ELShAssign(RValue *p1, Expression *p2);
  ~ELShAssign();
  virtual void accept(Visitor *v);
  virtual  ELShAssign  *clone() const;
  void swap(ELShAssign &);
};

class ERShAssign : public Expression
{
 public:
  RValue *rvalue_;
  Expression *expression_;

  ERShAssign(const ERShAssign &);
  ERShAssign &operator=(const ERShAssign &);
  ERShAssign(RValue *p1, Expression *p2);
  ~ERShAssign();
  virtual void accept(Visitor *v);
  virtual  ERShAssign  *clone() const;
  void swap(ERShAssign &);
};


class ListTLDeclaration : public Visitable
{
 public:
  TLDeclaration *tldeclaration_;
  ListTLDeclaration *listtldeclaration_;

  ListTLDeclaration(const ListTLDeclaration &);
  ListTLDeclaration &operator=(const ListTLDeclaration &);
  ListTLDeclaration(TLDeclaration *p1, ListTLDeclaration *p2);
  ListTLDeclaration(TLDeclaration *p);
  ~ListTLDeclaration();
  ListTLDeclaration* reverse();
  ListTLDeclaration* reverse(ListTLDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListTLDeclaration *clone() const;
  void swap(ListTLDeclaration &);
};
class ListDeclaration : public Visitable
{
 public:
  Declaration *declaration_;
  ListDeclaration *listdeclaration_;

  ListDeclaration(const ListDeclaration &);
  ListDeclaration &operator=(const ListDeclaration &);
  ListDeclaration(Declaration *p1, ListDeclaration *p2);
  ListDeclaration(Declaration *p);
  ~ListDeclaration();
  ListDeclaration* reverse();
  ListDeclaration* reverse(ListDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListDeclaration *clone() const;
  void swap(ListDeclaration &);
};
class ListStatement : public Visitable
{
 public:
  Statement *statement_;
  ListStatement *liststatement_;

  ListStatement(const ListStatement &);
  ListStatement &operator=(const ListStatement &);
  ListStatement(Statement *p1, ListStatement *p2);
  ListStatement(Statement *p);
  ~ListStatement();
  ListStatement* reverse();
  ListStatement* reverse(ListStatement *l);
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
  void swap(ListStatement &);
};
class ListTypeSpecifier : public Visitable
{
 public:
  TypeSpecifier *typespecifier_;
  ListTypeSpecifier *listtypespecifier_;

  ListTypeSpecifier(const ListTypeSpecifier &);
  ListTypeSpecifier &operator=(const ListTypeSpecifier &);
  ListTypeSpecifier(TypeSpecifier *p1, ListTypeSpecifier *p2);
  ListTypeSpecifier(TypeSpecifier *p);
  ~ListTypeSpecifier();
  ListTypeSpecifier* reverse();
  ListTypeSpecifier* reverse(ListTypeSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListTypeSpecifier *clone() const;
  void swap(ListTypeSpecifier &);
};
class ListConversionSpecifier : public Visitable
{
 public:
  ConversionSpecifier *conversionspecifier_;
  ListConversionSpecifier *listconversionspecifier_;

  ListConversionSpecifier(const ListConversionSpecifier &);
  ListConversionSpecifier &operator=(const ListConversionSpecifier &);
  ListConversionSpecifier(ConversionSpecifier *p1, ListConversionSpecifier *p2);
  ListConversionSpecifier(ConversionSpecifier *p);
  ~ListConversionSpecifier();
  ListConversionSpecifier* reverse();
  ListConversionSpecifier* reverse(ListConversionSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListConversionSpecifier *clone() const;
  void swap(ListConversionSpecifier &);
};
class ListFunctionSpecifier : public Visitable
{
 public:
  FunctionSpecifier *functionspecifier_;
  ListFunctionSpecifier *listfunctionspecifier_;

  ListFunctionSpecifier(const ListFunctionSpecifier &);
  ListFunctionSpecifier &operator=(const ListFunctionSpecifier &);
  ListFunctionSpecifier(FunctionSpecifier *p1, ListFunctionSpecifier *p2);
  ListFunctionSpecifier(FunctionSpecifier *p);
  ~ListFunctionSpecifier();
  ListFunctionSpecifier* reverse();
  ListFunctionSpecifier* reverse(ListFunctionSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListFunctionSpecifier *clone() const;
  void swap(ListFunctionSpecifier &);
};
class ListVariableSpecifier : public Visitable
{
 public:
  VariableSpecifier *variablespecifier_;
  ListVariableSpecifier *listvariablespecifier_;

  ListVariableSpecifier(const ListVariableSpecifier &);
  ListVariableSpecifier &operator=(const ListVariableSpecifier &);
  ListVariableSpecifier(VariableSpecifier *p1, ListVariableSpecifier *p2);
  ListVariableSpecifier(VariableSpecifier *p);
  ~ListVariableSpecifier();
  ListVariableSpecifier* reverse();
  ListVariableSpecifier* reverse(ListVariableSpecifier *l);
  virtual void accept(Visitor *v);
  virtual ListVariableSpecifier *clone() const;
  void swap(ListVariableSpecifier &);
};
class ListStructMemberDeclaration : public Visitable
{
 public:
  StructMemberDeclaration *structmemberdeclaration_;
  ListStructMemberDeclaration *liststructmemberdeclaration_;

  ListStructMemberDeclaration(const ListStructMemberDeclaration &);
  ListStructMemberDeclaration &operator=(const ListStructMemberDeclaration &);
  ListStructMemberDeclaration(StructMemberDeclaration *p1, ListStructMemberDeclaration *p2);
  ListStructMemberDeclaration(StructMemberDeclaration *p);
  ~ListStructMemberDeclaration();
  ListStructMemberDeclaration* reverse();
  ListStructMemberDeclaration* reverse(ListStructMemberDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListStructMemberDeclaration *clone() const;
  void swap(ListStructMemberDeclaration &);
};
class ListGenericParam : public Visitable
{
 public:
  GenericParam *genericparam_;
  ListGenericParam *listgenericparam_;

  ListGenericParam(const ListGenericParam &);
  ListGenericParam &operator=(const ListGenericParam &);
  ListGenericParam(GenericParam *p1, ListGenericParam *p2);
  ListGenericParam(GenericParam *p);
  ~ListGenericParam();
  ListGenericParam* reverse();
  ListGenericParam* reverse(ListGenericParam *l);
  virtual void accept(Visitor *v);
  virtual ListGenericParam *clone() const;
  void swap(ListGenericParam &);
};
class ListParameterDeclaration : public Visitable
{
 public:
  ParameterDeclaration *parameterdeclaration_;
  ListParameterDeclaration *listparameterdeclaration_;

  ListParameterDeclaration(const ListParameterDeclaration &);
  ListParameterDeclaration &operator=(const ListParameterDeclaration &);
  ListParameterDeclaration(ParameterDeclaration *p1, ListParameterDeclaration *p2);
  ListParameterDeclaration(ParameterDeclaration *p);
  ~ListParameterDeclaration();
  ListParameterDeclaration* reverse();
  ListParameterDeclaration* reverse(ListParameterDeclaration *l);
  virtual void accept(Visitor *v);
  virtual ListParameterDeclaration *clone() const;
  void swap(ListParameterDeclaration &);
};
class ListExpression : public Visitable
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  ListExpression(const ListExpression &);
  ListExpression &operator=(const ListExpression &);
  ListExpression(Expression *p1, ListExpression *p2);
  ListExpression(Expression *p);
  ~ListExpression();
  ListExpression* reverse();
  ListExpression* reverse(ListExpression *l);
  virtual void accept(Visitor *v);
  virtual ListExpression *clone() const;
  void swap(ListExpression &);
};


#endif
